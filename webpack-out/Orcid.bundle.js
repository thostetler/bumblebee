/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/components/api_feedback.js":
/*!*******************************************!*\
  !*** ./src/js/components/api_feedback.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! backbone */ \"./src/libs/backbone.js\"), __webpack_require__(/*! js/mixins/hardened */ \"./src/js/mixins/hardened.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, Backbone, Hardened) {\n  var ApiFeedback = function ApiFeedback(options) {\n    _.extend(this, _.defaults(options || {}, {\n      code: 200,\n      msg: undefined\n    }));\n\n    this.setCode(this.code);\n  };\n\n  ApiFeedback.CODES = {\n    INVALID_PASSWORD: 498,\n    ACCOUNT_NOT_FOUND: 495,\n    // Account not found during signin\n    ALREADY_LOGGED_IN: 493,\n    // Already signed during signup\n    REQUIRES_LOGIN: 491,\n    TOO_MANY_CHARACTERS: 486,\n    BAD_REQUEST: 400,\n    UNAUTHORIZED: 401,\n    NOT_FOUND: 404,\n    INTERNAL_SERVER_ERROR: 500,\n    BAD_GATEWAY: 502,\n    SERVER_ERROR: 503,\n    TOO_MANY_FAILURES: 580,\n    ALL_FINE: 200,\n    KEEP_WAITING: 190,\n    TESTING: 0,\n    // Internal events\n    MAKE_SPACE: -1,\n    UNMAKE_SPACE: -1.1,\n    SEARCH_CYCLE_STARTED: -2,\n    SEARCH_CYCLE_FAILED_TO_START: -3,\n    SEARCH_CYCLE_PROGRESS: -4,\n    SEARCH_CYCLE_STOP_MONITORING: -5,\n    SEARCH_CYCLE_FINISHED: -6,\n    QUERY_ASSISTANT: -7,\n    ALERT: -8,\n    CANNOT_ROUTE: -9,\n    API_REQUEST_ERROR: -10,\n    BIBCODE_DATA_REQUESTED: -11\n  };\n  var _codes = {};\n\n  _.each(_.pairs(ApiFeedback.CODES), function (p) {\n    _codes[p[1]] = p[0];\n  });\n\n  _.extend(ApiFeedback.prototype, {\n    hardenedInterface: {\n      code: 'integer value of the code',\n      msg: 'string message',\n      toJSON: 'for cloning',\n      getApiRequest: 'to get the original request',\n      getSenderKey: 'retrieve the senders key'\n    },\n    initialize: function initialize() {},\n    toJSON: function toJSON() {\n      return {\n        code: this.code,\n        msg: this.msg\n      };\n    },\n    setCode: function setCode(c) {\n      if (!_codes[c]) {\n        throw new Error('This code is not in the list ApiCodes - please extend js/components/api_feedback first:', this.code);\n      }\n\n      this.code = c;\n    },\n    setApiRequest: function setApiRequest(apiRequest) {\n      this.req = apiRequest;\n    },\n    getApiRequest: function getApiRequest() {\n      return this.req;\n    },\n    setMsg: function setMsg(msg) {\n      this.msg = msg;\n    },\n    getSenderKey: function getSenderKey() {\n      return this.senderKey;\n    },\n    setSenderKey: function setSenderKey(key) {\n      this.senderKey = key;\n    }\n  }, Hardened);\n\n  ApiFeedback.extend = Backbone.Model.extend;\n  return ApiFeedback;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/api_feedback.js?");

/***/ }),

/***/ "./src/js/components/api_query.js":
/*!****************************************!*\
  !*** ./src/js/components/api_query.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n A facade: api query exposing only the set of functions that we allow. This is\n the module that you want to load in the application (do not load the concrete\n implementaions, such as solr_params !)\n\n Put in your config:\n map: {\n 'your/module': {\n 'api_query_impl': 'js/components/specific_impl_of_the_api_query'\n }\n },\n\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! backbone */ \"./src/libs/backbone.js\"), __webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! js/components/solr_params */ \"./src/js/components/solr_params.js\"), __webpack_require__(/*! js/components/facade */ \"./src/js/components/facade.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Backbone, _, ApiQueryImplementation, Facade) {\n  var hardenedInterface = {\n    add: 'add values',\n    set: 'set (replace existing)',\n    get: 'get values',\n    has: 'has a key',\n    hasVal: 'more specific `has` using _.isEmpty',\n    url: 'url string of the params',\n    load: 'loads query as a string',\n    clear: 'clears all values',\n    unset: 'removes a key',\n    toJSON: 'values back as JSON object',\n    clone: 'make a copy',\n    isLocked: true,\n    lock: true,\n    unlock: true,\n    pairs: 'get all values as pairs',\n    keys: 'as keys',\n    values: 'only values',\n    hasChanged: 'whether this object has modification (since its creation)',\n    previousAttributes: 'get all changed attributes',\n    previous: 'previous values for a given attribute'\n  };\n\n  var ApiQuery = function ApiQuery(data, options) {\n    // Facade pattern, we want to expose only limited API\n    // despite the fact that the underlying instance has\n    // all power of the Backbone.Model\n    if (data instanceof ApiQueryImplementation) {\n      this.innerQuery = new Facade(hardenedInterface, data);\n    } else {\n      this.innerQuery = new Facade(hardenedInterface, new ApiQueryImplementation(data, options));\n    }\n  };\n\n  var toInsert = {};\n\n  _.each(_.keys(hardenedInterface), function (element, index, list) {\n    toInsert[element] = function () {\n      return this.innerQuery[element].apply(this.innerQuery, arguments);\n    };\n  });\n\n  _.extend(ApiQuery.prototype, toInsert, {\n    clone: function clone() {\n      var clone = this.innerQuery.clone.apply(this.innerQuery, arguments);\n      return new ApiQuery(clone);\n    },\n    load: function load() {\n      var clone = this.innerQuery.load.apply(this.innerQuery, arguments);\n      return new ApiQuery(clone);\n    }\n  });\n\n  return ApiQuery;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/api_query.js?");

/***/ }),

/***/ "./src/js/components/api_query_updater.js":
/*!************************************************!*\
  !*** ./src/js/components/api_query_updater.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Created by rchyla on 5/24/14.\n *\n * Set of utilities for manipulating ApiQuery object. These are mainly\n * useful for widgets that often do the same operations with the\n * query.\n *\n * The object must be initialized with an 'identifier' -- this identifier\n * will represent a context; so we'll be touching all elements that\n * belong to the context\n *\n * TODO: need to distinguish globalOperator from 'operator' inside clauses\n * TODO: the 'globalOperator' joins clauses; 'operator' joins elements of the\n * TODO: clauses\n *\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! js/components/api_query */ \"./src/js/components/api_query.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, ApiQuery) {\n  var ApiQueryUpdater = function ApiQueryUpdater(contextIdentifier, options) {\n    if (!contextIdentifier || !_.isString(contextIdentifier)) {\n      throw new Error('You must initialize the ApiQueryUpdater with a context (which is a string)');\n    }\n\n    this.context = contextIdentifier;\n    this.defaultOperator = ' ';\n    this.operators = [' ', 'AND', 'OR', 'NOT', 'NEAR'];\n    this.defaultMode = 'limit';\n    this.operationModes = ['limit', 'exclude', 'expand', 'replace', 'remove'];\n    this.impossibleString = \"\\uFFFC\\uFFFC\\uFFFC\";\n\n    _.extend(this, options);\n  };\n\n  _.extend(ApiQueryUpdater.prototype, {\n    /**\n     * Modifies the query - it will search for a string inside the query (using previously\n     * saved state) and update the query 'parameter'\n     *\n     * @param field\n     *      this is the name of the parameter we are changing inside apiQeury\n     * @param apiQuery\n     *      the apiQuery object we are updating\n     * @param queryCondition\n     *      String|[String] - new conditions to set\n     * @param operator\n     *      String: this will serve as concatenator for the conditions\n     */\n    updateQuery: function updateQuery(apiQuery, field, mode, queryCondition, options) {\n      options = _.defaults({}, options, {\n        prefix: '__'\n      });\n\n      if (!field || !_.isString(field)) {\n        throw new Error('You must tell us what parameter to update in the ApiQuery');\n      } // globalOperator = this._sanitizeOperator(globalOperator);\n      // local name\n\n\n      var n = this._n(field, options.prefix); // create copy of the field\n\n\n      var q = _.clone(apiQuery.get(field));\n\n      var oldConditionAsString;\n      var newConditionAsString;\n      var newConditions;\n      var existingConditions; // first check if we have any existing conditions\n\n      existingConditions = this._getExistingVals(apiQuery, n);\n      queryCondition = this._sanitizeConditionAsArray(queryCondition);\n      mode = this._sanitizeMode(mode);\n      var operator;\n\n      if (mode == 'limit') {\n        operator = 'AND';\n      } else if (mode == 'exclude') {\n        operator = 'NOT';\n      } else if (mode == 'expand') {\n        operator = 'OR';\n      } else if (mode == 'replace') {\n        this._closeExistingVals(apiQuery, this._n(field, options.prefix));\n\n        apiQuery.set(this._n(field, options.prefix), ['AND', queryCondition[0]]);\n        return apiQuery.set(field, queryCondition[0]);\n      } else if (mode == 'remove') {\n        operator = existingConditions[0];\n      } else {\n        throw new Error('Unsupported mode/operator:', mode);\n      }\n\n      if (!apiQuery.has(field)) {\n        var conditions = [operator].concat(queryCondition);\n        apiQuery.set(field, this._buildQueryFromConditions(conditions));\n        apiQuery.set(this._n(field, options.prefix), conditions);\n        return;\n      }\n\n      if (existingConditions) {\n        // if the operators differ, it means we cannot safely update the query\n        // we must treat it as a new query\n        if (existingConditions[0] !== operator) {\n          this._closeExistingVals(apiQuery, n);\n\n          return this.updateQuery(apiQuery, field, mode, queryCondition);\n        }\n\n        oldConditionAsString = this._buildQueryFromConditions(existingConditions);\n      } else {\n        existingConditions = [operator]; // first value is always operator\n\n        if (q.length == 1) {\n          // we got a string, but that string could be a whole phrase\n          if (q[0].indexOf(' ') == -1) {\n            // simple string\n            oldConditionAsString = q[0];\n            existingConditions.push(q[0]);\n          } else {\n            oldConditionAsString = q[0];\n            var sillyTest = q[0].toLowerCase();\n\n            if (sillyTest.indexOf(' and ') > -1 || sillyTest.indexOf(' or ') > -1 || sillyTest.indexOf(' not ') > -1 || sillyTest.indexOf(' near') > -1 || sillyTest.indexOf('(') > 2) {\n              existingConditions.push('(' + q[0] + ')'); // enclose the expression in brackets, just to be safe\n            } else {\n              existingConditions.push(q[0]);\n            }\n          }\n        } else {\n          oldConditionAsString = this.impossibleString;\n        }\n      } // 'limit' means that the broader query will become 'narrower'\n      // by gaining more AND'ed 'conditions'\n      // 'expand' means that the query is becoming broader by gaining\n      // more conditions (these are OR'ed)\n\n\n      if (mode == 'limit' || mode == 'expand') {\n        // join the old and the new conditoins (remove the duplicates)\n        // we are basically trying to update the existing query\n        // by adding more conditions into the same clause\n        newConditions = _.union(existingConditions, queryCondition);\n        newConditionAsString = this._buildQueryFromConditions(newConditions);\n\n        var testq = _.clone(q); // try to find the pre-condition and replace it with a new value\n\n\n        if (this._modifyArrayReplaceString(testq, oldConditionAsString, newConditionAsString)) {\n          apiQuery.set(field, testq); // success\n          // save the values inside the query (so that we can use them if we are called next time)\n\n          apiQuery.set(n, newConditions);\n          return;\n        }\n      } // 'exclude' means that we are ADDING more conditions to the query; the query\n      // was broader; not it will explicitly 'exclude' some documents; again - there\n      // can also be 'exclude' conditions; so if possible, we'll enlarge their number\n\n\n      if (mode == 'exclude') {\n        var modifiedExisting = _.clone(existingConditions);\n\n        modifiedExisting[0] = 'OR';\n        oldConditionAsString = ' NOT ' + this._buildQueryFromConditions(modifiedExisting);\n        newConditions = _.union(existingConditions, queryCondition);\n\n        var modifiedConditions = _.clone(newConditions);\n\n        modifiedConditions[0] = 'OR';\n        newConditionAsString = ' NOT ' + this._buildQueryFromConditions(modifiedConditions);\n\n        var testq = _.clone(q); // try to find the pre-condition and replace it with a new value\n\n\n        if (this._modifyArrayReplaceString(testq, oldConditionAsString, newConditionAsString)) {\n          apiQuery.set(field, testq); // success\n          // save the values inside the query (so that we can use them if we are called next time)\n\n          apiQuery.set(n, newConditions);\n          return;\n        }\n      } else if (mode == 'remove') {\n        newConditions = _.difference(existingConditions, queryCondition);\n        newConditionAsString = this._buildQueryFromConditions(newConditions); // we'll be deleting\n\n        var testq = _.clone(q); // try to find the pre-condition and replace it with a new value\n\n\n        if (this._modifyArrayReplaceString(testq, oldConditionAsString, newConditionAsString)) {\n          apiQuery.set(field, testq); // success\n          // save the values inside the query (so that we can use them if we are called next time)\n\n          apiQuery.set(n, newConditions);\n          return;\n        }\n      } // we didn't find an old query that could be updated, so this means that we have\n      // to add a new logical condition to the existing query string.\n\n\n      if (mode == 'limit') {\n        newConditions = this._modifyArrayAddString(q, queryCondition, 'AND');\n      } else if (mode == 'exclude') {\n        newConditions = this._modifyArrayAddString(q, queryCondition, 'NOT');\n      } else if (mode == 'expand') {\n        newConditions = this._modifyArrayAddString(q, queryCondition, 'OR');\n      }\n\n      apiQuery.set(n, newConditions);\n      apiQuery.set(field, q);\n    },\n\n    /**\n     * Tells whether the string needs escaping (it ignores empty space)\n     *\n     * @param value\n     */\n    needsEscape: function needsEscape(s) {\n      var sb = [];\n      var c;\n\n      for (var i = 0; i < s.length; i++) {\n        c = s[i]; // These characters are part of the query syntax and must be escaped\n\n        if (c == '\\\\' || c == '+' || c == '-' || c == '!' || c == '(' || c == ')' || c == ':' || c == '^' || c == '[' || c == ']' || c == '\"' || c == '{' || c == '}' || c == '~' || c == '*' || c == '?' || c == '|' || c == '&' || c == '/') {\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n    /**\n     * Escapes special characters (but not whitespace)\n     *\n     * @param value\n     */\n    escape: function escape(s) {\n      var sb = [];\n      var c;\n\n      for (var i = 0; i < s.length; i++) {\n        c = s[i]; // These characters are part of the query syntax and must be escaped\n\n        if (c == '\\\\' || c == '+' || c == '-' || c == '!' || c == '(' || c == ')' || c == ':' || c == '^' || c == '[' || c == ']' || c == '\"' || c == '{' || c == '}' || c == '~' || c == '*' || c == '?' || c == '|' || c == '&' || c == '/') {\n          sb.push('\\\\');\n        }\n\n        sb.push(c);\n      }\n\n      return sb.join('');\n    },\n    escapeInclWhitespace: function escapeInclWhitespace(s) {\n      var sb = [];\n      var c;\n\n      for (var i = 0; i < s.length; i++) {\n        c = s[i]; // These characters are part of the query syntax and must be escaped\n\n        if (c == '\\\\' || c == '+' || c == '-' || c == '!' || c == '(' || c == ')' || c == ':' || c == '^' || c == '[' || c == ']' || c == '\"' || c == '{' || c == '}' || c == '~' || c == '*' || c == '?' || c == '|' || c == '&' || c == '/' || c == ' ' || c == '\\t') {\n          sb.push('\\\\');\n        }\n\n        sb.push(c);\n      }\n\n      return sb.join('');\n    },\n\n    /**\n     * Wraps string between quotes - and escapes any quotes if present\n     * @param s\n     * @returns {string}\n     */\n    quoteIfNecessary: function quoteIfNecessary(s, quoteChar, quoteCharEnd) {\n      return this.quote(s, quoteChar, quoteCharEnd, true);\n    },\n\n    /**\n     * Wraps string between quotes - and escapes any quotes if present\n     * @param s\n     * @returns {string}\n     */\n    quote: function quote(s, quoteChar, quoteCharEnd, onlyIfNecessary) {\n      if (!quoteChar) quoteChar = '\"';\n      if (!quoteCharEnd) quoteCharEnd = quoteChar;\n      if (_.isUndefined(onlyIfNecessary)) onlyIfNecessary = false;\n      var sb = [];\n      var c;\n      var needsQuotes = false;\n\n      for (var i = 0; i < s.length; i++) {\n        c = s[i];\n\n        if (c == '\\\\' || c == '+' || c == '-' || c == '!' || c == '(' || c == ')' || c == ':' || c == '^' || c == '[' || c == ']' || c == '\"' || c == '{' || c == '}' || c == '~' || // || c == '*' || c == '?'\n        c == '|' || c == '&' || c == '/' || c == ' ' || c == '\\t') {\n          needsQuotes = true;\n        }\n\n        if ((c == quoteChar || c == quoteCharEnd) && (i == 0 || i > 0 && s[i - 1] !== '\\\\')) {\n          sb.push('\\\\');\n        }\n\n        sb.push(c);\n      } // detect presence of quotes in the original string\n\n\n      if (onlyIfNecessary == true && sb[0] == '\\\\' && sb[1] == '\"' && sb[sb.length - 2] == '\\\\' && sb[sb.length - 1] == '\"') {\n        sb[0] = '';\n        sb[sb.length - 2] = '';\n        return sb.join('');\n      }\n\n      if (needsQuotes || onlyIfNecessary == false) {\n        return quoteChar + sb.join('') + quoteCharEnd;\n      }\n\n      return sb.join('');\n    },\n\n    /**\n     * Attaches to the ApiQuery object a storage of tmp values; these are\n     * not affecting anything inside the query; but the query is carrying them\n     * around as long as it was not cloned() etc\n     *\n     * @param key\n     * @param value\n     */\n    saveTmpEntry: function saveTmpEntry(apiQuery, key, value) {\n      var storage = this._getTmpStorage(apiQuery, true);\n\n      var oldVal;\n\n      if (key in storage) {\n        oldVal = storage[key];\n      }\n\n      storage[key] = value;\n      return oldVal;\n    },\n    removeTmpEntry: function removeTmpEntry(apiQuery, key) {\n      var storage = this._getTmpStorage(apiQuery, true);\n\n      var val = storage[key];\n      delete storage[key];\n      return val;\n    },\n    getTmpEntry: function getTmpEntry(apiQuery, key, defaultValue) {\n      var storage;\n\n      if (defaultValue) {\n        storage = this._getTmpStorage(apiQuery, true);\n      } else {\n        storage = this._getTmpStorage(apiQuery, false);\n      }\n\n      if (key in storage) {\n        return storage[key];\n      }\n\n      storage[key] = defaultValue;\n      return defaultValue;\n    },\n    hasTmpEntry: function hasTmpEntry(apiQuery, key) {\n      var storage = this._getTmpStorage(apiQuery);\n\n      return key in storage;\n    },\n    _getTmpStorage: function _getTmpStorage(apiQuery, createIfNotExists) {\n      var n = this._n('__tmpStorage');\n\n      if (!apiQuery.hasOwnProperty(n)) {\n        if (!createIfNotExists) return {};\n        apiQuery[n] = {};\n      }\n\n      return apiQuery[n];\n    },\n    _n: function _n(name, prefix) {\n      return (_.isString(prefix) ? prefix : '__') + this.context + '_' + name;\n    },\n    _buildQueryFromConditions: function _buildQueryFromConditions(conditions) {\n      if (conditions.length <= 1) {\n        throw new Error('Violation of contract: first condition is always an operator');\n      }\n\n      var op = conditions[0];\n\n      if (op != ' ') {\n        op = ' ' + op + ' ';\n      }\n\n      return '(' + conditions.slice(1).join(op) + ')';\n    },\n\n    /**\n     * Searches for values inside the array and replaces sections\n     * Returns number of modifications made\n     *\n     * @param arr\n     * @param search\n     * @param replace\n     * @param maxNumMod\n     *    maximum number of modifications to make; you can choose to\n     *    replace only the first value found\n     * @returns {integer}\n     * @private\n     */\n    _modifyArrayReplaceString: function _modifyArrayReplaceString(arr, search, replace, maxNumMod) {\n      var numMod = 0;\n      if (!maxNumMod) maxNumMod = -1;\n\n      if (!search) {\n        throw new Error('Your search is empty, you fool');\n      }\n\n      var modified = false;\n\n      _.each(arr, function (text, i) {\n        if (maxNumMod > 0 && numMod > maxNumMod) {\n          return;\n        }\n\n        if (text.indexOf(search) > -1) {\n          arr[i] = text.replace(search, replace);\n          numMod += 1;\n        }\n      });\n\n      return numMod;\n    },\n\n    /**\n     * Adds the new value into the array\n     * @param arr\n     * @param conditions\n     * @private\n     */\n    _modifyArrayAddString: function _modifyArrayAddString(arr, conditions, operator) {\n      // will always add to the latest string\n      if ((arr.length == 0 || arr[arr.length - 1].trim() == '') && (operator == 'NOT' || operator == 'NEAR')) {\n        throw new Error('Invalid operation; cannot apply NOT/NEAR on single clause');\n      }\n\n      var newQ = arr[arr.length - 1];\n      var newConditions = [operator, newQ].concat(conditions);\n      arr[arr.length - 1] = this._buildQueryFromConditions(newConditions);\n      return newConditions;\n    },\n\n    /**\n     * Gets the valus of the condition\n     * @param apiQuery\n     * @param key\n     *    the conditon 'name', typically st like __condition_author_q; it differs based on the\n     *    operation (type of update/widget/filter etc)\n     * @param defaults\n     *    what to return if 'key' is not present\n     * @returns {*}\n     * @private\n     */\n    _getExistingVals: function _getExistingVals(apiQuery, key, defaults) {\n      if (apiQuery.has(key)) {\n        return apiQuery.get(key);\n      }\n\n      return defaults;\n    },\n\n    /**\n     * When we have conditions for the previous context; but their operator is\n     * different, it means that the new conditions represent a new clause. So\n     * we need to do something with the old conditions (we could stack them\n     * but for now, the simple/robust solution is to simply remove them ->\n     * this means they will not be available for updates/manipulation -->\n     * theh query will be extended)\n     *\n     * @param condName\n     * @private\n     */\n    _closeExistingVals: function _closeExistingVals(apiQuery, condName) {\n      apiQuery.unset(condName);\n    },\n    _sanitizeMode: function _sanitizeMode(mode) {\n      if (!mode) {\n        return this.defaultMode;\n      }\n\n      var i = _.indexOf(this.operationModes, mode);\n\n      if (i == -1) {\n        throw new Error('Unkwnown mode: ' + mode);\n      }\n\n      return this.operationModes[i];\n    },\n    _sanitizeOperator: function _sanitizeOperator(operator) {\n      if (!operator) {\n        return this.defaultOperator;\n      }\n\n      if (_.isString(operator)) {\n        if (operator.trim() == '') {\n          return this.defaultOperator;\n        }\n      } else {\n        throw new Error('Operator must be a string');\n      }\n\n      operator = operator.toUpperCase();\n\n      var i = _.indexOf(this.operators, operator);\n\n      if (i == -1) {\n        throw new Error('Unknown operator: ', operator);\n      }\n\n      return this.operators[i];\n    },\n    _sanitizeConditionAsArray: function _sanitizeConditionAsArray(condition) {\n      if (!condition) {\n        throw new Error('The condition must be set (string/array of strings)');\n      }\n\n      if (_.isString(condition)) {\n        return [condition];\n      }\n\n      condition = _.without(_.flatten(condition), '', false, null, undefined, NaN);\n\n      if (condition.length == 0) {\n        throw new Error('After removing empty values, no condition was left');\n      }\n\n      return condition;\n    },\n\n    /**\n     * Cleans up the *clone* of the apiQuery by removing all the entries\n     * that are inserted into ApiQuery by the query updater.\n     *\n     * @param apiQuery\n     */\n    clean: function clean(apiQuery) {\n      var q = {};\n\n      if (apiQuery && apiQuery.keys) {\n        _.each(apiQuery.keys(), function (key) {\n          if (!(key.substring(0, 2) == '__')) {\n            q[key] = apiQuery.get(key);\n          }\n        });\n      }\n\n      return new ApiQuery(q);\n    }\n  });\n\n  return ApiQueryUpdater;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/api_query_updater.js?");

/***/ }),

/***/ "./src/js/components/api_request.js":
/*!******************************************!*\
  !*** ./src/js/components/api_request.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Created by rchyla on 3/28/14.\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! backbone */ \"./src/libs/backbone.js\"), __webpack_require__(/*! js/components/facade */ \"./src/js/components/facade.js\"), __webpack_require__(/*! js/components/default_request */ \"./src/js/components/default_request.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, Backbone, Facade, ApiRequestImpl) {\n  var hardenedInterface = {\n    // add makes no sense with request\n    get: 'get a key',\n    set: 'set (replace existing)',\n    url: 'url string defining this request',\n    has: 'has a key',\n    load: 'loads request as a string',\n    clear: 'clears all values',\n    unset: 'removes a key',\n    toJSON: 'values back as JSON object',\n    clone: 'make a copy',\n    isLocked: true,\n    lock: true,\n    unlock: true,\n    pairs: 'get all values as pairs',\n    keys: 'as keys',\n    values: 'only values',\n    hasChanged: 'whether this object has modification (since its creation)',\n    previousAttributes: 'get all changed attributes',\n    previous: 'previous values for a given attribute'\n  };\n\n  var ApiRequest = function ApiRequest(data, options) {\n    // Facade pattern, we want to expose only limited API\n    // despite the fact that the underlying instance has\n    // all power of the Backbone.Model\n    if (data instanceof ApiRequestImpl) {\n      this.innerRequest = new Facade(hardenedInterface, data);\n    } else {\n      this.innerRequest = new Facade(hardenedInterface, new ApiRequestImpl(data, options));\n    }\n  };\n\n  var toInsert = {};\n\n  _.each(_.keys(hardenedInterface), function (element, index, list) {\n    toInsert[element] = function () {\n      return this.innerRequest[element].apply(this.innerRequest, arguments);\n    };\n  });\n\n  _.extend(ApiRequest.prototype, toInsert, {\n    clone: function clone() {\n      var clone = this.innerRequest.clone.apply(this.innerRequest, arguments);\n      return new ApiRequest(clone);\n    },\n    load: function load() {\n      var clone = this.innerRequest.load.apply(this.innerRequest, arguments);\n      return new ApiRequest(clone);\n    }\n  });\n\n  return ApiRequest;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/api_request.js?");

/***/ }),

/***/ "./src/js/components/api_targets.js":
/*!******************************************!*\
  !*** ./src/js/components/api_targets.js ***!
  \******************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Created by rchyla on 1/20/15\n *\n * contains api targets\n * and any related limits\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n  var config = {\n    BOOTSTRAP: '/accounts/bootstrap',\n    SEARCH: 'search/query',\n    QTREE: 'search/qtree',\n    BIGQUERY: 'search/bigquery',\n    EXPORT: 'export/',\n    SERVICE_AUTHOR_NETWORK: 'vis/author-network',\n    SERVICE_PAPER_NETWORK: 'vis/paper-network',\n    SERVICE_WORDCLOUD: 'vis/word-cloud',\n    SERVICE_METRICS: 'metrics',\n    SERVICE_OBJECTS: 'objects',\n    SERVICE_OBJECTS_QUERY: 'objects/query',\n    SERVICE_CITATION_HELPER: 'citation_helper',\n    SERVICE_AUTHOR_AFFILIATION_EXPORT: 'authoraff',\n    MYADS_STORAGE: 'vault',\n    MYADS_NOTIFICATIONS: 'vault/_notifications',\n    AUTHOR_AFFILIATION_SEARCH: 'author-affiliation/search',\n    AUTHOR_AFFILIATION_EXPORT: 'author-affiliation/export',\n    RESOLVER: 'resolver',\n    CSRF: 'accounts/csrf',\n    USER: 'accounts/user',\n    USER_DATA: 'vault/user-data',\n    SITE_CONFIGURATION: 'vault/configuration',\n    TOKEN: 'accounts/user/token',\n    LOGIN: 'accounts/user/login',\n    LOGOUT: 'accounts/user/logout',\n    VERIFY: 'accounts/verify',\n    RESEND_VERIFY: \"accounts/user/{email}/verify\",\n    RESET_PASSWORD: 'accounts/user/reset-password',\n    CHANGE_PASSWORD: 'accounts/user/change-password',\n    CHANGE_EMAIL: 'accounts/user/change-email',\n    INFO: 'accounts/info',\n    PROTECTED: 'accounts/protected',\n    STATUS: 'accounts/status',\n    RECOMMENDER: 'recommender',\n    GRAPHICS: 'graphics',\n    FEEDBACK: 'feedback',\n    // library import from classic\n    LIBRARY_IMPORT_CLASSIC_AUTH: 'harbour/auth/classic',\n    LIBRARY_IMPORT_CLASSIC_MIRRORS: 'harbour/mirrors',\n    LIBRARY_IMPORT_CLASSIC_TO_BBB: 'biblib/classic',\n    // library import from 2.0\n    LIBRARY_IMPORT_ADS2_AUTH: 'harbour/auth/twopointoh',\n    LIBRARY_IMPORT_ADS2_TO_BBB: 'biblib/twopointoh',\n    LIBRARY_IMPORT_ZOTERO: 'harbour/export/twopointoh/zotero',\n    LIBRARY_IMPORT_MENDELEY: 'harbour/export/twopointoh/mendeley',\n    // returns credentials from both classic and 2.0 if they exist\n    LIBRARY_IMPORT_CREDENTIALS: 'harbour/user',\n    // store ADS information connected with ORCID here\n    ORCID_PREFERENCES: 'orcid/preferences',\n    ORCID_NAME: 'orcid/orcid-name',\n    // library endpoints\n    // can get info about all libraries, or list of bibcodes associated w/specific lib (libraries/id)\n    // post to /libraries/ to create a library\n    LIBRARIES: 'biblib/libraries',\n    LIBRARY_TRANSFER: 'biblib/transfer',\n    // can post, put, and delete changes to individual libs using this endpoint\n    DOCUMENTS: 'biblib/documents',\n    PERMISSIONS: 'biblib/permissions',\n    REFERENCE: 'reference/text',\n\n    /*\n     * this is used by the mixin 'user_change_rows' to set max allowed/default requested\n     */\n    _limits: {\n      // use the same name from discovery.config.js\n      ExportWidget: {\n        default: 500,\n        limit: 3000\n      },\n      Metrics: {\n        default: 7000,\n        limit: 7000\n      },\n      AuthorNetwork: {\n        default: 400,\n        limit: 1000\n      },\n      PaperNetwork: {\n        default: 400,\n        limit: 1000\n      },\n      ConceptCloud: {\n        default: 150,\n        limit: 150\n      },\n      BubbleChart: {\n        // default == limit\n        default: 1500\n      }\n    }\n  }; // add credential info\n  // doesn't require cross domain cookies\n\n  config._doesntNeedCredentials = [config.SEARCH, config.QTREE, config.BIGQUERY, config.EXPORT, config.SERVICE_AUTHOR_NETWORK, config.SERVICE_PAPER_NETWORK, config.SERVICE_WORDCLOUD, config.SERVICE_METRICS, config.RECOMMENDER, config.GRAPHICS, config.FEEDBACK];\n  return config;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/api_targets.js?");

/***/ }),

/***/ "./src/js/components/default_request.js":
/*!**********************************************!*\
  !*** ./src/js/components/default_request.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Created by rchyla on 3/28/14.\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! backbone */ \"./src/libs/backbone.js\"), __webpack_require__(/*! js/components/api_query */ \"./src/js/components/api_query.js\"), __webpack_require__(/*! js/components/multi_params */ \"./src/js/components/multi_params.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, Backbone, ApiQuery, MultiParams) {\n  var basicCheck = function basicCheck(s) {\n    if (_.isString(s)) {\n      return true;\n    }\n\n    if (_.isArray(s)) {\n      var l = s.length;\n\n      for (var i = 0; i < l; i++) {\n        var x = s[i];\n\n        if (!(_.isString(x) || _.isNumber(x))) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n\n  var allowedAttrs = {\n    query: function query(v) {\n      if (_.isUndefined(v)) {\n        return true;\n      }\n\n      return v instanceof ApiQuery;\n    },\n    target: basicCheck,\n    sender: basicCheck,\n    options: basicCheck\n  };\n  var checker = {\n    target: function target(s) {\n      if (s && s.substring(0, 1) !== '/') {\n        return '/' + s;\n      }\n    }\n  };\n  var Request = MultiParams.extend({\n    /**\n     * Internal method: we allow only certain keys\n     *\n     * @param attributes\n     * @param options\n     * @returns {boolean}\n     * @private\n     */\n    _validate: function _validate(attributes, options) {\n      _.forOwn(attributes, function (val, attr) {\n        var tempVal = attributes[attr];\n\n        if (!(attr in allowedAttrs)) {\n          throw new Error('Invalid attr: ' + attr);\n        }\n\n        if (!allowedAttrs[attr].call(allowedAttrs, tempVal)) {\n          throw new Error('Invalid value:key ' + attr + tempVal);\n        }\n      });\n\n      return true;\n    },\n\n    /**\n     * Modified version of the multi-valued set(); we do not insist\n     * on having the values in array\n     *\n     * @param key\n     * @param val\n     * @param options\n     * @returns {Request}\n     */\n    set: function set(key, val, options) {\n      this._checkLock();\n\n      var attrs;\n      if (key == null) return this; // Handle both `\"key\", value` and `{key: value}` -style arguments.\n\n      if (_typeof(key) === 'object') {\n        attrs = key;\n        options = val;\n      } else {\n        (attrs = {})[key] = val;\n      }\n\n      Backbone.Model.prototype.set.call(this, attrs, options);\n    },\n    // for requests, we use all components: path, query, hash\n    _checkParsed: function _checkParsed(attrs) {\n      if (_.isObject(attrs)) {\n        var ret = {};\n\n        if ('#query' in attrs && !_.isEmpty(attrs['#query'])) {\n          ret.query = new ApiQuery(attrs['#query']);\n        }\n\n        if ('#path' in attrs) {\n          ret.target = attrs['#path'][0];\n        }\n\n        if ('#hash' in attrs) {\n          _.extend(ret, _.each(attrs['#hash'], function (val, key, obj) {\n            if (val.length == 1) {\n              obj[key] = val[0];\n            }\n          }));\n        }\n\n        return ret;\n      }\n\n      return attrs;\n    },\n\n    /*\n     * Return the url string encoding all parameters that made\n     * this request. The parameters will be sorted alphabetically\n     * by their keys and URL encoded so that they can be used\n     * in requests.\n     */\n    url: function url(whatToSort) {\n      if (!whatToSort) {\n        whatToSort = this.attributes;\n      }\n\n      var target = whatToSort.target;\n      var url = target ? _.isArray(target) ? target.join('/') : target : '';\n\n      if ('query' in whatToSort) {\n        url += '?' + whatToSort.query.url();\n      }\n\n      if ('sender' in whatToSort) {\n        url += '#' + MultiParams.prototype.url.call(this, {\n          sender: whatToSort.sender\n        });\n      }\n\n      return url;\n    },\n\n    /**\n     * Re-constructs the query from the url string, returns the json attributes;\n     * cannot be used it the instance is locked\n     *\n     * @param query (String)\n     * @returns {Model}\n     */\n    load: function load(query) {\n      return MultiParams.prototype.load.call(this, query.indexOf('?') > -1 ? query : query + '?');\n    }\n  });\n  return Request;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/default_request.js?");

/***/ }),

/***/ "./src/js/components/facade.js":
/*!*************************************!*\
  !*** ./src/js/components/facade.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Created by rchyla on 3/16/14. inspiration: http://jsfiddle.net/pajtai/GD5qR/35/\n */\n\n/*\n * // Interface\n *  var remoteInterface = {\n *    on: 'turn on'\n *  };\n *  // Implementation\n *  var htmlRemote = {\n *    on: function() { console.log(\"remote on\"); return this; }\n *  };\n *  // Protecting the implementation\n *  var htmlInterface = new Facade(remoteInterface, htmlRemote);\n *\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! js/components/facade */ \"./src/js/components/facade.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, Facade) {\n  // The Facade encapsulates objectIn according to the description\n  // The exposed facade is guaranteed to have exactly the functions described in description.\n  var Facade = function Facade(description, objectIn) {\n    var facade; // TODO: add enforce of \"new\"\n\n    facade = {};\n    this.mixIn(description, objectIn, facade); // TODO: check that \"mixIn\" is not taken\n\n    facade.mixIn = this.mixIn;\n    return facade;\n  };\n\n  Facade.prototype.mixIn = function (description, objectIn, facade) {\n    var property;\n    var propertyValue;\n    facade = facade || this;\n\n    for (property in description) {\n      propertyValue = description[property];\n\n      if (property in objectIn) {\n        var p = objectIn[property];\n\n        if (typeof propertyValue === 'function') {\n          // redefining the method\n          facade[property] = _.bind(propertyValue, objectIn);\n        } else if (typeof p === 'function') {\n          // exposing the method\n          facade[property] = _.bind(p, objectIn);\n        } else if (_.isUndefined(p)) {// pass\n        } else if (_.isString(p) || _.isNumber(p) || _.isBoolean(p) || _.isDate(p) || _.isNull(p) || _.isRegExp(p)) {\n          // build getter method\n          facade['get' + property.substring(0, 1).toUpperCase() + property.substring(1)] = _.bind(function () {\n            return this.ctx[this.name];\n          }, {\n            ctx: objectIn,\n            name: property\n          });\n          facade[property] = p; // copy the value (it is immutable anyways)\n        } else if (p.hasOwnProperty('__facade__') && p.__facade__) {\n          // exposing internal facade\n          facade[property] = p;\n        } else if (_.isObject(p) && 'getHardenedInstance' in p) {\n          // builds a facade\n          facade[property] = p.getHardenedInstance();\n        } else {\n          throw new Error(\"Sorry, you can't wrap '\" + property + \"': \" + p);\n        }\n      } else if (typeof propertyValue === 'function') {\n        facade[property] = _.bind(propertyValue, objectIn);\n      } else {\n        throw new Error('Unknown key: ' + property + '(' + propertyValue + ')');\n      }\n    }\n\n    if (objectIn) {\n      // .name is not supported in IE\n      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n      facade.__facade__ = Boolean(objectIn.constructor ? objectIn.constructor.name ? objectIn.constructor.name : true : true);\n    } else {\n      facade.__facade__ = true;\n    } // TODO:rca - shall we use?\n    // if (Object.freeze)\n    //  facade = Object.freeze(facade);\n\n\n    return facade;\n  };\n\n  return Facade;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/facade.js?");

/***/ }),

/***/ "./src/js/components/generic_module.js":
/*!*********************************************!*\
  !*** ./src/js/components/generic_module.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * A generic class to be used for building modules (the Marionette.Module)\n * just complicates things. For simple things, just use this class.\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! backbone */ \"./src/libs/backbone.js\"), __webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Backbone, _) {\n  // A list of options to be attached directly to the module, if provided.\n  var moduleOptions = ['className', 'activate'];\n\n  var Module = function Module(options) {\n    var defaults;\n    options = options || {};\n    this.mid = _.uniqueId('module');\n\n    _.extend(this, _.pick(options, moduleOptions));\n\n    this.initialize.call(this, options);\n  }; // every module has the Events mixin\n\n\n  _.extend(Module.prototype, Backbone.Events, {\n    className: 'GenericModule',\n    initialize: function initialize() {},\n    destroy: function destroy() {},\n    activate: function activate(options) {\n      _.extend(this, _.pick(options, moduleOptions));\n    }\n  }); // give the module subclassing functionality\n\n\n  Module.extend = Backbone.Model.extend;\n  return Module;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/generic_module.js?");

/***/ }),

/***/ "./src/js/components/multi_params.js":
/*!*******************************************!*\
  !*** ./src/js/components/multi_params.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*\n multi_params is a generic class to store any parameters;\n it is backed by BB.Model and has all the functionality\n the values are always stored as an array of values; so\n even if you try to set strings, you will always have\n list of strings\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! backbone */ \"./src/libs/backbone.js\"), __webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! jquery */ \"./src/libs/jquery.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Backbone, _, $) {\n  var Model = Backbone.Model.extend({\n    locked: false,\n    _checkLock: function _checkLock() {\n      if (this.locked === true) {\n        throw Error('Object locked for modifications');\n      }\n    },\n    isLocked: function isLocked() {\n      return this.locked;\n    },\n    lock: function lock() {\n      this.locked = true;\n    },\n    unlock: function unlock() {\n      this.locked = false;\n    },\n    clone: function clone() {\n      if (this.isLocked()) {\n        var c = new this.constructor(this.attributes);\n        c.lock();\n        return c;\n      }\n\n      return new this.constructor(this.attributes);\n    },\n    hasVal: function hasVal(key) {\n      return !_.isEmpty(this.get(key));\n    },\n    // we allow only strings and numbers; instead of sending\n    // signal we throw a direct error\n    _validate: function _validate(attributes, options) {\n      // check we have only numbers and/or finite numbers\n      for (var attr in attributes) {\n        if (!_.isString(attr)) {\n          throw new Error('Keys must be strings, not: ' + attr);\n        } // remove empty strings\n\n\n        var tempVal = attributes[attr];\n        tempVal = _.without(_.flatten(tempVal), '', false, null, undefined, NaN);\n\n        if (!_.isArray(tempVal)) {\n          throw new Error('Values were not converted to an Array');\n        }\n\n        if (_.isEmpty(tempVal) && options.unset !== true) {\n          throw new Error('Empty values not allowed');\n        }\n\n        if (!_.every(tempVal, function (v) {\n          return _.isString(v) || _.isNumber(v) && !_.isNaN(v);\n        })) {\n          throw new Error('Invalid value (not a string or number): ' + tempVal);\n        }\n\n        attributes[attr] = tempVal;\n      }\n\n      return true;\n    },\n    // Every value is going to be multi-valued by default\n    // in this way we can treat all objects in the same way\n    set: function set(key, val, options) {\n      this._checkLock();\n\n      var attrs;\n      if (key == null) return this; // Handle both `\"key\", value` and `{key: value}` -style arguments.\n\n      if (_typeof(key) === 'object') {\n        attrs = key;\n        options = val;\n      } else {\n        (attrs = {})[key] = val;\n      }\n\n      for (var attr in attrs) {\n        var tempVal = attrs[attr]; // convert to array if necessary\n\n        if (!_.isArray(tempVal)) {\n          attrs[attr] = _.flatten([tempVal]);\n        }\n      }\n\n      Backbone.Model.prototype.set.call(this, attrs, options);\n    },\n    unset: function unset() {\n      this._checkLock();\n\n      Backbone.Model.prototype.unset.apply(this, arguments);\n    },\n    // adds values to existing (like set, but keeps the old vals)\n    add: function add(key, val, options) {\n      this._checkLock();\n\n      var attrs;\n      if (key == null) return this; // Handle both `\"key\", value` and `{key: value}` -style arguments.\n\n      if (_typeof(key) === 'object') {\n        attrs = key;\n        options = val;\n      } else {\n        (attrs = {})[key] = val;\n      }\n\n      for (var attr in attrs) {\n        var tempVal = attrs[attr]; // convert to array if necessary\n\n        if (!_.isArray(tempVal)) {\n          tempVal = _.flatten([tempVal]);\n        }\n\n        if (this.has(attr)) {\n          tempVal = _.clone(this.get(attr)).concat(tempVal);\n        }\n\n        attrs[attr] = tempVal;\n      }\n\n      Backbone.Model.prototype.set.call(this, attrs, options);\n    },\n    // synchronization is disabled\n    sync: function sync() {\n      throw Error('MultiParams cannot be saved to server');\n    },\n\n    /*\n     * Return the url string encoding all parameters that made\n     * this query. The parameters will be sorted alphabetically\n     * by their keys and URL encoded so that they can be used\n     * in requests.\n     */\n    url: function url(whatToSort) {\n      if (!whatToSort) {\n        whatToSort = this.attributes;\n      } // sort keys alphabetically\n\n\n      var sorted = _.pairs(whatToSort).sort(function (a, b) {\n        return a[0] > b[0] ? 1 : a[0] < b[0] ? -1 : 0;\n      }); // June1:rca - I need to preserve order of values (becuaes of the query modifications/updates) the logic\n      // just requires us to be careful and we need order to be preserved when the query is cloned\n      // also sort values\n      // var s = {};\n      // sorted.map(function(item) { s[item[0]] = (_.isArray(item[1]) ? item[1].sort() : item[1]) });\n      // we have to double encode certain elements\n      // sorted = _.map(sorted, function(pair) { return [pair[0], _.map(pair[1], function(v) {return (v.indexOf && v.indexOf('=') > -1) ? encodeURIComponent(v) : v })]});\n      // use traditional encoding\n      // use %20 instead of + (url encoding instead of form encoding)\n\n\n      var encoded = $.param(_.object(sorted), true);\n      encoded = encoded.replace(/\\+/g, '%20'); // Replace funky unicode quotes with normal ones\n\n      encoded = encoded.replace(/%E2%80%9[ECD]/g, '%22');\n      return encoded;\n    },\n\n    /**\n     * Parses string (urlparams) and returns it as an object\n     * @param resp\n     * @param options\n     * @returns {*}\n     */\n    parse: function parse(resp, options) {\n      if (_.isString(resp)) {\n        var attrs = {};\n        resp = decodeURI(resp);\n\n        if (resp.indexOf('?') > -1) {\n          attrs['#path'] = [resp.slice(0, resp.indexOf('?'))];\n          resp = resp.slice(resp.indexOf('?') + 1);\n        }\n\n        if (resp.indexOf('#') > -1) {\n          attrs['#hash'] = this._parse(resp.slice(resp.indexOf('#') + 1));\n          resp = resp.slice(0, resp.indexOf('#'));\n        }\n\n        attrs['#query'] = this._parse(resp);\n        return this._checkParsed(attrs);\n      }\n\n      return this._checkParsed(resp); // else return resp object\n    },\n    _parse: function _parse(resp) {\n      var attrs = {};\n      var hash;\n\n      if (!resp.trim()) {\n        return attrs;\n      }\n\n      var hashes = resp.slice(resp.indexOf('?') + 1).split('&'); // resp = decodeURIComponent(resp);\n\n      var key;\n      var value;\n\n      for (var i = 0; i < hashes.length; i++) {\n        hash = hashes[i].split('=');\n        key = decodeURIComponent(hash[0].split('+').join(' ')); // optimized: .replace(/\\+/g, \" \")\n\n        var vall = hash[1];\n\n        if (hash.length > 2) {\n          hash.shift();\n          vall = hash.join('=');\n        } // replace literal '%' with code and '+' become literal spaces\n\n\n        value = decodeURIComponent(vall.replace(/%(?!\\d|[ABCDEF]+)/gi, '%25').split('+').join(' '));\n\n        if (attrs[key] !== undefined) {\n          attrs[key].push(value);\n        } else {\n          attrs[key] = [value];\n        }\n      }\n\n      return attrs;\n    },\n    // default behaviour is just to keep the query parameters\n    // after the string was parsed, you can override it to suit other needs\n    _checkParsed: function _checkParsed(attrs) {\n      if (_.isObject(attrs)) {\n        if ('#query' in attrs) {\n          return attrs['#query'];\n        }\n      }\n\n      return attrs;\n    },\n\n    /**\n     * Re-constructs the query from the url string, returns the json attributes;\n     * cannot be used it the instance is locked\n     *\n     * @param query (String)\n     * @returns {Model}\n     */\n    load: function load(query) {\n      this._checkLock();\n\n      var vals = this.parse(query);\n      this.clear();\n      this.set(vals);\n      return this;\n    }\n  });\n  return Model;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/multi_params.js?");

/***/ }),

/***/ "./src/js/components/pubsub_events.js":
/*!********************************************!*\
  !*** ./src/js/components/pubsub_events.js ***!
  \********************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Created by rchyla on 3/30/14.\n */\n\n/**\n * Catalogue of PubSub events; we assume this:\n *\n *  - FC = the component lives in the 'Forbidden City'\n *         inside Application, typically this is a PubSub or Api, Mediator\n *         or any component with elevated access\n *\n *  - OC = Outer City: the suburbs of the application; these are typically\n *         UI components (behind the wall), untrusted citizens of the\n *         BumbleBee state\n *\n *  WARNING: do not use spaces; events with spaces are considered to be\n *        multiple events! (e.g. '[PubSub] New-Query' will be two events)\n *\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n  var PubSubEvents = {\n    /**\n     * Usually called by OC's as a first step in the query processing.\n     * It means: 'user did something', we need to start reacting. The OC\n     * will build a new ApiQuery and send it together with this event\n     */\n    START_SEARCH: '[PubSub]-New-Query',\n\n    /**\n     * Called by FC's (usually: Mediator) - this is a signal to *all* OC's\n     * they should receive ApiQuery object, compare it against their\n     * own query; find diff and create a new ApiRequest (asking for a data)\n     * and send that back\n     */\n    INVITING_REQUEST: '[PubSub]-Inviting-Request',\n\n    /**\n     * Will be called by OC's, this is response to ApiQuery input.\n     */\n    DELIVERING_REQUEST: '[PubSub]-New-Request',\n\n    /**\n     * Will be called by OC's, this is one-time forget action (outside of the\n     * the search cycle); use this for any query that needs to be executed\n     * and not be tracked by search cycle\n     */\n    EXECUTE_REQUEST: '[PubSub]-Execute-Request',\n\n    /**\n     * Called from the router, the QID will be passed; the query needs to be\n     * loaded and executed\n     */\n    EXECUTE_STORED_QUERY: '[PubSub]-Execute-Stored-Query',\n\n    /**\n     * Published by FC's - typically Mediator - when a response has been retrieved\n     * for a given ApiRequest.\n     *\n     * OC's should subscribe to this event when they want to receive data\n     * from the treasury (api)\n     *\n     *  - input: ApiRequest\n     *  - output: ApiResponse\n     */\n    DELIVERING_RESPONSE: '[PubSub]-New-Response',\n\n    /**\n     * The walls of the FC are being closed; and no new requests will be served\n     */\n    CLOSING_GATES: '[PubSub]-Closing',\n\n    /**\n     * PubSub will not receive any requests any more\n     */\n    CLOSED_FOR_BUSINESS: '[PubSub]-Closed',\n\n    /**\n     * ForbiddenCity is about to receive requests\n     */\n    OPENING_GATES: '[PubSub]-Opening',\n\n    /**\n     * Called after PubSub became ready - it is fully operational\n     */\n    OPEN_FOR_BUSINESS: '[PubSub]-Ready',\n\n    /**\n     *  Set of error warnings issues by PubSub - or by some other FC's - to\n     *  deal with congestion or other problems\n     */\n    SMALL_FIRE: '[PubSub]-Problem',\n    BIG_FIRE: '[PubSub]-Big-Problem',\n    CITY_BURNING: '[PubSub]-Disaster',\n\n    /**\n     * A message containing feedback from the FC; traveling towards OC\n     * The feedback will be instance of ApiFeedback\n     */\n    FEEDBACK: '[FC]-FeedBack',\n\n    /**\n     * A message from the router requesting showing citizens of the\n     * city\n     */\n    DISPLAY_DOCUMENTS: '[Router]-Display-Documents',\n    DISPLAY_DOCUMENTS_DETAILS: '[Router]-Display-Documents-Details',\n\n    /**\n     * Used by OC to request parsed query tree - to check a query\n     * for example\n     */\n    GET_QTREE: '[FC]-GetQTree',\n    NAVIGATE: '[Router]-Navigate-With-Trigger',\n\n    /*\n     * so navigator can notify interested widgets about a change\n     * from search page to user page, for instance-- navigator cannot\n     * to this since it listens to many events including widget-show events\n     * */\n    PAGE_CHANGE: '[Navigator]Page-Changed',\n\n    /* for custom widget-to-widget events */\n    CUSTOM_EVENT: '[PubSub]-Custom-Event',\n    ARIA_ANNOUNCEMENT: '[PubSub]-Aria-Announcement',\n\n    /* anything to do with changing the state of the user, including session events */\n    USER_ANNOUNCEMENT: '[PubSub]-User-Announcement',\n\n    /**\n     * A message/action that should be displayed to the user (on prominent)\n     * place\n     */\n    ALERT: '[Alert]-Message',\n    ORCID_ANNOUNCEMENT: '[PubSub]-Orcid-Announcement',\n\n    /**\n     * Happens during the main cycle of the application birth\n     *  LOADED = when all components were successfuly loaded\n     *  BOOTSTRAPPED = + when all dynamic config was loaded\n     *  STARTING = + right before the router and history objects start()\n     *  STARTED = app is alive and handling requests\n     */\n    APP_LOADED: '[App]-Application-Loaded',\n    APP_BOOTSTRAPPED: '[App]-Application-Bootstrapped',\n    APP_STARTING: '[App]-Application-Starting',\n    APP_STARTED: '[App]-Application-Started',\n    APP_EXIT: '[App]-Exit',\n\n    /**\n     * Is triggered when user selects/deselects records\n     */\n    PAPER_SELECTION: '[User]-Paper-Selection',\n    // instead of toggling, adds all papers\n    BULK_PAPER_SELECTION: '[User]-Bulk-Paper-Selection',\n\n    /*\n     * is triggered by app storage itself when list of selected papers changes\n     * */\n    STORAGE_PAPER_UPDATE: '[User]-Paper-Update',\n    LIBRARY_CHANGE: '[PubSub]-Library-Change'\n  };\n  return PubSubEvents;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/pubsub_events.js?");

/***/ }),

/***/ "./src/js/components/pubsub_key.js":
/*!*****************************************!*\
  !*** ./src/js/components/pubsub_key.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Created by rchyla on 3/14/14.\n */\n\n/*\n * A simple, yet important, class - every subscriber\n * to the PubSub must contain one key. This class\n * should be instantiated in a safe manner. ie.\n *\n * PubSubKey.newInstance({creator: this});\n *\n * But beware that as long as the subscriber is alive\n * reference to the creator will be saved inside\n * the key! So choose carefully whether you use this\n * functionality\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_) {\n  var PubSubKey = function PubSubKey(options) {\n    _.extend(this, options);\n  };\n\n  _.extend(PubSubKey, {\n    /*\n     * Creates a new Instances of the PubSubKey\n     * with a storage that cannot be changed.\n     * To double sign the key, you can pass\n     * an object that identifies creator of the\n     * key and test identity, eg.\n     *\n     * var creator = {};\n     * var k = PubSubKey(creator);\n     * k.getCreator() === k;\n     *\n     */\n    newInstance: function newInstance(options) {\n      var priv = {\n        id: _.has(options, 'id') ? options.id : _.uniqueId(':psk'),\n        creator: _.has(options, 'creator') ? options.creator : null\n      };\n      return new PubSubKey({\n        getId: function getId() {\n          return priv.id;\n        },\n        getCreator: function getCreator() {\n          return priv.creator;\n        }\n      });\n    }\n  });\n\n  return PubSubKey;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/pubsub_key.js?");

/***/ }),

/***/ "./src/js/components/solr_params.js":
/*!******************************************!*\
  !*** ./src/js/components/solr_params.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\nSubclass of the multi-param with a functionality specific for\nSOLR queries. Do not use this class directly inside your app!\nInstead, import 'api_query' and configure it properly\n\n * <p>For a list of possible parameters, please consult the links below.</p>\n *\n * @see http://wiki.apache.org/solr/CoreQueryParameters\n * @see http://wiki.apache.org/solr/CommonQueryParameters\n * @see http://wiki.apache.org/solr/SimpleFacetParameters\n * @see http://wiki.apache.org/solr/HighlightingParameters\n * @see http://wiki.apache.org/solr/MoreLikeThis\n * @see http://wiki.apache.org/solr/SpellCheckComponent\n * @see http://wiki.apache.org/solr/StatsComponent\n * @see http://wiki.apache.org/solr/TermsComponent\n * @see http://wiki.apache.org/solr/TermVectorComponent\n * @see http://wiki.apache.org/solr/LocalParams\n *\n * @param properties A map of fields to set. Refer to the list of public fields.\n * @class ParameterStore\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! js/components/multi_params */ \"./src/js/components/multi_params.js\"), __webpack_require__(/*! backbone */ \"./src/libs/backbone.js\"), __webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! jquery */ \"./src/libs/jquery.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (MultiParams, Backbone, _, $) {\n  var SolrParams = MultiParams.extend({\n    fieldsToConcatenate: [],\n    defaultOperator: ' ',\n    fieldProcessors: {\n      '*': function _(vals, self) {\n        return [vals.join(self.defaultOperator)];\n      }\n    },\n    initialize: function initialize(attributes, options) {\n      if (options) {\n        _.extend(this, _.pick(options, ['fieldsToConcatenate', 'defaultOperator', 'fieldProcessors']));\n      }\n    },\n    url: function url(resp, options) {\n      // first massage the fields, but do not touch the original values\n      // lodash has a parameter isDeep that can be set to true, but\n      // for compatibility reasons with underscore, lets' not use it\n      // the values should always be only one level deep\n      var values = _.clone(this.attributes);\n\n      var l = this.fieldsToConcatenate.length;\n      var k = '';\n\n      for (var i = 0; i < l; i++) {\n        k = this.fieldsToConcatenate[i];\n\n        if (this.has(k)) {\n          if (this.fieldProcessors[k]) {\n            values[k] = this.fieldProcessors[k](this.get(k), this);\n          } else {\n            values[k] = this.fieldProcessors['*'](this.get(k), this);\n          }\n        }\n      } // then call the default implementation of the url handling\n\n\n      return MultiParams.prototype.url.call(this, values);\n    }\n  });\n  return SolrParams;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/solr_params.js?");

/***/ }),

/***/ "./src/js/mixins/dependon.js":
/*!***********************************!*\
  !*** ./src/js/mixins/dependon.js ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Created by rchyla on 3/13/14.\n */\n\n/*\n * This module contains a set of utilities that can be added to classes\n * to give them certain functionality\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! js/components/pubsub_events */ \"./src/js/components/pubsub_events.js\"), __webpack_require__(/*! js/components/pubsub_key */ \"./src/js/components/pubsub_key.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, PubSubEvents, PubSubKey) {\n  var Mixin = {\n    /*\n     * BeeHive is the object that allows modules to get access to objects\n     * of the application (but we make sure these objects are protected\n     * and only application can set/change them). This mixin gives objects\n     * functions to query 'BeeHive'\n     */\n    BeeHive: {\n      // called by parents (app) to give modules access\n      setBeeHive: function setBeeHive(brundibar) {\n        if (_.isEmpty(brundibar)) throw new Error('Huh? Empty Beehive? Trying to be funny?');\n        this.__beehive = brundibar;\n      },\n      getBeeHive: function getBeeHive() {\n        if (!this.hasBeeHive()) throw new Error('The BeeHive is inactivate (or dead :<})');\n        return this.__beehive;\n      },\n      hasBeeHive: function hasBeeHive() {\n        if (this.__beehive && (this.__beehive.active || this.__beehive.__facade__ && this.__beehive.getActive())) {\n          return true;\n        }\n\n        return false;\n      },\n\n      /**\n       * Method which returns a masked instance of PubSub (unless the PubSub\n       * is already a hardened instance; which carries its own key)\n       *\n       * You can call pubsub.publish() without having to supply the pubsub key\n       * (which is what most controllers want to do; there are only some\n       * exceptions to this rule; ie. query-mediator). If you need to get\n       * access to the full PubSub (and you have it inside BeeHive) then do\n       * this.getBeeHive().getService('PubSub')\n       */\n      getPubSub: function getPubSub() {\n        if (!this.hasBeeHive()) throw new Error('The BeeHive is inactive (or dead >:})');\n        if (!this.__ctx) this.__ctx = {};\n        if (this.__ctx.pubsub) return this.__ctx.pubsub;\n\n        var pubsub = this.__beehive.getService('PubSub');\n\n        if (pubsub && pubsub.__facade__) return pubsub; // build a unique key for this instance\n\n        this.__ctx.pubsub = {\n          _key: pubsub.getPubSubKey(),\n          _exec: function _exec(name, args) {\n            args = _.toArray(args);\n            if (args[0] instanceof PubSubKey) throw Error('You have given us a PubSub key, this.publish() method does not need it.');\n            args.unshift(this._key);\n            pubsub[name].apply(pubsub, args);\n          },\n          publish: function publish() {\n            this._exec('publish', arguments);\n          },\n          subscribe: function subscribe() {\n            this._exec('subscribe', arguments);\n          },\n          subscribeOnce: function subscribeOnce() {\n            this._exec('subscribeOnce', arguments);\n          },\n          unsubscribe: function unsubscribe() {\n            this._exec('unsubscribe', arguments);\n          },\n          getCurrentPubSubKey: function getCurrentPubSubKey() {\n            return this._key;\n          }\n        };\n\n        _.extend(this.__ctx.pubsub, PubSubEvents);\n\n        return this.__ctx.pubsub;\n      },\n      hasPubSub: function hasPubSub() {\n        if (this.hasBeeHive()) return _.isObject(this.__beehive.getService('PubSub'));\n        return false;\n      }\n    },\n    App: {\n      setApp: function setApp(app) {\n        if (_.isUndefined(app)) throw new Error('App object cannot be empty');\n        this.__app = app;\n      },\n      getApp: function getApp() {\n        return this.__app;\n      },\n      hasApp: function hasApp() {\n        return !_.isEmpty(this.__app);\n      }\n    }\n  };\n  return Mixin;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/mixins/dependon.js?");

/***/ }),

/***/ "./src/js/mixins/hardened.js":
/*!***********************************!*\
  !*** ./src/js/mixins/hardened.js ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Created by rchyla on 3/18/14.\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! js/components/facade */ \"./src/js/components/facade.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, Facade) {\n  var Mixin = {\n    /*\n     * Creates a hardened instance of itself, it uses\n     * interface description from 'hardenedInterface'\n     * Implementations need to populate 'hardenedInterface'\n     * with list of properties and methods that should be exposed\n     * through the Facade\n     */\n    _getHardenedInstance: function _getHardenedInstance(iface, objectIn) {\n      if (!('hardenedInterface' in this) && !iface) {\n        throw Error('Error: this.hardenedInterface is not defined');\n      }\n\n      return new Facade(iface || ('hardenedInterface' in this ? this.hardenedInterface : {}), objectIn);\n    },\n    getHardenedInstance: function getHardenedInstance(iface) {\n      return this._getHardenedInstance(iface, this);\n    }\n  };\n  return Mixin;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/mixins/hardened.js?");

/***/ }),

/***/ "./src/js/mixins/link_generator_mixin.js":
/*!***********************************************!*\
  !*** ./src/js/mixins/link_generator_mixin.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! js/mixins/openurl_generator */ \"./src/js/mixins/openurl_generator.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, _ref) {\n  var getOpenUrl = _ref.getOpenUrl;\n  var GATEWAY_BASE_URL = '/link_gateway/';\n  var DEFAULT_ORDERING = ['ADS_PDF', 'ADS_SCAN', 'INSTITUTION', 'PUB_PDF', 'PUB_HTML', 'EPRINT_PDF', 'EPRINT_HTML', 'AUTHOR_PDF', 'AUTHOR_HTML'];\n\n  var sortByDefaultOrdering = function sortByDefaultOrdering(sources) {\n    // initially sort the whole list by the DEFAULT_ORDERING array\n    var sortedSources = sources.sort(function (a, b) {\n      var aIndex = DEFAULT_ORDERING.indexOf(a.rawType);\n      var bIndex = DEFAULT_ORDERING.indexOf(b.rawType); // If both elements are in the DEFAULT_ORDERING array, sort based on their indices\n\n      if (aIndex !== -1 && bIndex !== -1) {\n        return aIndex - bIndex;\n      } // If only 'a' is in DEFAULT_ORDERING, move it before 'b'\n\n\n      if (aIndex !== -1) {\n        return -1;\n      } // If only 'b' is in DEFAULT_ORDERING, move it before 'a'\n\n\n      if (bIndex !== -1) {\n        return 1;\n      } // If both elements are not in DEFAULT_ORDERING, maintain their relative order\n\n\n      return 0;\n    }); // then make sure that sources in DEFAULT_ORDERING are pushed to the top\n\n    return [].concat(_toConsumableArray(sortedSources.filter(function (source) {\n      return DEFAULT_ORDERING.includes(source.rawType);\n    })), _toConsumableArray(sortedSources.filter(function (source) {\n      return !DEFAULT_ORDERING.includes(source.rawType);\n    })));\n  };\n  /**\n   * @typedef {Object} LinkType\n   * @property {string} name - Full name\n   * @property {string} shortName - shorter name for display\n   * @property {string} description - longer description\n   * @property {('PDF' | 'SCAN' | 'HTML')} type - Resource type\n   */\n\n  /**\n   * set of link types and descriptions\n   * @type {Object.<string, LinkType>}\n   */\n\n\n  var LINK_TYPES = {\n    '4TU.ResearchData': {\n      shortName: '4TU.ResearchData',\n      description: 'International data repository for science, engineering and design'\n    },\n    AcA: {\n      shortName: 'AcA',\n      description: 'Acta Astronomica Data Files'\n    },\n    ADS_PDF: {\n      name: 'ADS PDF',\n      shortName: 'ADS',\n      description: 'ADS PDF',\n      type: 'PDF'\n    },\n    ADS_SCAN: {\n      name: 'ADS Scanned Article',\n      description: 'ADS scanned article',\n      shortName: 'ADS',\n      type: 'SCAN'\n    },\n    AHED: {\n      shortName: 'AHED',\n      description: 'Astrobiology Habitable Environments Database'\n    },\n    ALMA: {\n      shortName: 'ALMA',\n      description: 'Atacama Large Millimeter/submillimeter Array'\n    },\n    ArcticData: {\n      shortName: 'ArcticData',\n      description: 'Arctic Data Center'\n    },\n    ARI: {\n      shortName: 'ARI',\n      description: 'Astronomisches Rechen-Institut'\n    },\n    ARTEMIS: {\n      shortName: 'ARTEMIS',\n      description: 'Acceleration Reconnection Turbulence & Electrodynamics of Moon Interaction with the Sun'\n    },\n    AstroGeo: {\n      shortName: 'AstroGeo',\n      description: 'USGS Astrogeology Science Center'\n    },\n    Astroverse: {\n      shortName: 'Astroverse',\n      description: 'CfA Dataverse'\n    },\n    ASU: {\n      shortName: 'ASU',\n      description: 'Arizona State University'\n    },\n    ATNF: {\n      shortName: 'ATNF',\n      description: 'Australia Telescope Online Archive'\n    },\n    Author: {\n      shortName: 'Author',\n      description: 'Author Hosted Dataset'\n    },\n    AUTHOR_HTML: {\n      name: 'Author Article',\n      shortName: 'Author',\n      description: 'Link to HTML page provided by author',\n      type: 'HTML'\n    },\n    AUTHOR_PDF: {\n      name: 'Author PDF',\n      shortName: 'Author',\n      description: 'Link to PDF page provided by author',\n      type: 'PDF'\n    },\n    BAS: {\n      shortName: 'BAS',\n      description: 'British Antarctic Survey'\n    },\n    BAVJ: {\n      shortName: 'BAVJ',\n      description: 'Data of the German Association for Variable Stars'\n    },\n    BICEP2: {\n      shortName: 'BICEP2',\n      description: 'BICEP/Keck Data'\n    },\n    CADC: {\n      shortName: 'CADC',\n      description: 'Canadian Astronomy Data Center'\n    },\n    Caltech: {\n      shortName: 'Caltech',\n      description: 'California Institute of Technology'\n    },\n    CDS: {\n      shortName: 'CDS',\n      description: 'Strasbourg Astronomical Data Center'\n    },\n    Chandra: {\n      shortName: 'Chandra',\n      description: 'Chandra X-Ray Observatory'\n    },\n    ClimateDataStore: {\n      shortName: 'ClimateDataStore',\n      description: 'Climate Data Store'\n    },\n    CMDN: {\n      shortName: 'CMDN',\n      description: 'China Meteorological Data Service Centre'\n    },\n    CXO: {\n      shortName: 'CXO',\n      description: 'Chandra Data Archive'\n    },\n    DARTS: {\n      shortName: 'DARTS',\n      description: 'Data ARchives and Transmission System'\n    },\n    Dataverse: {\n      shortName: 'Dataverse',\n      description: 'Dataverse Project'\n    },\n    Dryad: {\n      shortName: 'Dryad',\n      description: 'International Repository of Research Data'\n    },\n    EARTHCHEM: {\n      shortName: 'EARTHCHEM',\n      description: 'Open-access repository for geochemical datasets'\n    },\n    ECMWF: {\n      shortName: 'ECMWF',\n      description: 'European Centre for Medium-Range Weather Forecasts'\n    },\n    EMFISIS: {\n      shortName: 'EMFISIS',\n      description: 'An instrument suite on the Van Allen Probes'\n    },\n    EPRINT_HTML: {\n      name: 'Preprint Article',\n      shortName: 'Preprint',\n      description: 'Preprint article',\n      type: 'HTML'\n    },\n    EPRINT_PDF: {\n      name: 'Preprint PDF',\n      shortName: 'Preprint',\n      description: 'Preprint PDF',\n      type: 'PDF'\n    },\n    ERGSC: {\n      shortName: 'ERGSC',\n      description: 'ERG Science Center'\n    },\n    ESA: {\n      shortName: 'ESA',\n      description: 'ESAC Science Data Center'\n    },\n    ESGF: {\n      shortName: 'ESGF',\n      description: 'Earth System Grid Federation'\n    },\n    ESO: {\n      shortName: 'ESO',\n      description: 'European Southern Observatory'\n    },\n    ETHZ: {\n      shortName: 'ETHZ',\n      description: 'ETH Zurich Research Collection'\n    },\n    FDSN: {\n      shortName: 'FDSN',\n      description: 'International Federation of Digital Seismograph Networks'\n    },\n    Figshare: {\n      shortName: 'Figshare',\n      description: 'Online Open Access Repository'\n    },\n    figshare: {\n      shortName: 'figshare',\n      description: 'Online Open Access Repository'\n    },\n    GCPD: {\n      shortName: 'GCPD',\n      description: 'The General Catalogue of Photometric Data'\n    },\n    Gemini: {\n      shortName: 'Gemini',\n      description: 'Gemini Observatory Archive'\n    },\n    Github: {\n      shortName: 'Github',\n      description: 'Web-based version-control and collaboration platform for software developers.'\n    },\n    GRAS: {\n      shortName: 'GRAS',\n      description: 'Lunar and Planet Exploration Program Ground Application System'\n    },\n    GTC: {\n      shortName: 'GTC',\n      description: 'Gran Telescopio CANARIAS Public Archive'\n    },\n    HEASARC: {\n      shortName: 'HEASARC',\n      description: 'NASA High Energy Astrophysics Science Archive Research Center'\n    },\n    Herschel: {\n      shortName: 'Herschel',\n      description: 'Herschel Science Center'\n    },\n    IBVS: {\n      shortName: 'IBVS',\n      description: 'Information Bulletin on Variable Stars'\n    },\n    INES: {\n      shortName: 'INES',\n      description: 'IUE Newly Extracted Spectra'\n    },\n    IRIS: {\n      shortName: 'IRIS',\n      description: 'Incorporated Research Institutions for Seismology'\n    },\n    IRSA: {\n      shortName: 'IRSA',\n      description: 'NASA/IPAC Infrared Science Archive'\n    },\n    ISO: {\n      shortName: 'ISO',\n      description: 'Infrared Space Observatory'\n    },\n    JOSS: {\n      shortName: 'JOSS',\n      description: 'Journal of Open Source Software'\n    },\n    JWST: {\n      shortName: 'JWST',\n      description: 'JWST Proposal Info'\n    },\n    KOA: {\n      shortName: 'KOA',\n      description: 'Keck Observatory Archive'\n    },\n    LAADS: {\n      shortName: 'LAADS',\n      description: 'Level-1 and Atmosphere Archive & Distribution System Distributed Active Archive Center'\n    },\n    label: {\n      shortName: 'label',\n      description: 'name'\n    },\n    LASP: {\n      shortName: 'LASP',\n      description: 'Laboratory for Atmospheric and Space Physics'\n    },\n    LPL: {\n      shortName: 'LPL',\n      description: 'Lunar and Planetary Laboratory'\n    },\n    MAST: {\n      shortName: 'MAST',\n      description: 'Mikulski Archive for Space Telescopes'\n    },\n    MetOffice: {\n      shortName: 'MetOffice',\n      description: 'Met Office'\n    },\n    MIT: {\n      shortName: 'MIT',\n      description: 'Massachusetts Institute of Technology'\n    },\n    NASA: {\n      shortName: 'NASA',\n      description: 'NASA Data Portal'\n    },\n    NCAR: {\n      shortName: 'NCAR',\n      description: 'National Center for Atmospheric Research'\n    },\n    NED: {\n      shortName: 'NED',\n      description: 'NASA/IPAC Extragalactic Database'\n    },\n    NExScI: {\n      shortName: 'NExScI',\n      description: 'NASA Exoplanet Archive'\n    },\n    NOAA: {\n      shortName: 'NOAA',\n      description: 'National Oceanic and Atmospheric Administration'\n    },\n    NOAO: {\n      shortName: 'NOAO',\n      description: 'National Optical Astronomy Observatory'\n    },\n    OSF: {\n      shortName: 'OSF',\n      description: 'Open Science Foundation'\n    },\n    PANGAEA: {\n      shortName: 'PANGAEA',\n      description: 'Digital Data Library and a Data Publisher for Earth System Science'\n    },\n    pangaea: {\n      shortName: 'pangaea',\n      description: 'Digital Data Library and a Data Publisher for Earth System Science'\n    },\n    PASA: {\n      shortName: 'PASA',\n      description: 'Publication of the Astronomical Society of Australia Datasets'\n    },\n    PDG: {\n      shortName: 'PDG',\n      description: 'Particle Data Group'\n    },\n    PDS: {\n      shortName: 'PDS',\n      description: 'The NASA Planetary Data System'\n    },\n    PDSS: {\n      shortName: 'PDSS',\n      description: 'The NASA Planetary Data System'\n    },\n    PIK: {\n      shortName: 'PIK',\n      description: 'Potsdam Institute for Climate Impact Research'\n    },\n    protocols: {\n      shortName: 'protocols',\n      description: 'Collaborative Platform and Preprint Server for Science Methods and Protocols'\n    },\n    PUB_HTML: {\n      name: 'Publisher Article',\n      shortName: 'Publisher',\n      description: 'Electronic on-line publisher article (HTML)',\n      type: 'HTML'\n    },\n    PUB_PDF: {\n      name: 'Publisher PDF',\n      shortName: 'Publisher',\n      description: 'Publisher PDF',\n      type: 'PDF'\n    },\n    ScienceBase: {\n      shortName: 'ScienceBase',\n      description: 'ScienceBase'\n    },\n    SIMBAD: {\n      shortName: 'SIMBAD',\n      description: 'SIMBAD Database at the CDS'\n    },\n    Spitzer: {\n      shortName: 'Spitzer',\n      description: 'Spitzer Space Telescope'\n    },\n    TDR: {\n      shortName: 'TDR',\n      description: 'Texas Data Respository'\n    },\n    THEMIS: {\n      shortName: 'THEMIS',\n      description: 'Time History of Events and Macroscopic Interactions During Substorms'\n    },\n    TNS: {\n      shortName: 'TNS',\n      description: 'Transient Name Server'\n    },\n    UNAVCO: {\n      shortName: 'UNAVCO',\n      description: 'UNAVCO'\n    },\n    Vizier: {\n      shortName: 'VizieR',\n      description: 'VizieR Catalog Service'\n    },\n    XMM: {\n      shortName: 'XMM',\n      description: 'XMM Newton Science Archive'\n    },\n    Zenodo: {\n      shortName: 'Zenodo',\n      description: 'Zenodo Archive'\n    }\n  };\n\n  var enc = function enc(str) {\n    return encodeURIComponent(str);\n  };\n  /**\n   * Create the resolver url\n   * @param {string} bibcode - the bibcode\n   * @param {string} target - the source target (i.e. PUB_HTML)\n   * @returns {string} - the new url\n   */\n\n\n  var _createGatewayUrl = function _createGatewayUrl(bibcode, target) {\n    if (_.isString(bibcode) && _.isString(target)) {\n      return GATEWAY_BASE_URL + enc(bibcode) + '/' + target;\n    }\n\n    return '';\n  };\n  /**\n   * process the link data\n   *\n   * Proceeds in this manner:\n   * 1. Check the property to find ESOURCE and DATA\n   * 2. If there, find the property on the parent object\n   * 3. Process by some rules\n   *  3.1. If OPENACCESS property is present, then all esourses ending with _HTML are open\n   *  3.2. If <field>_OPENACCESS property is present, then the corresponding esource field is open\n   *  3.3. If electr field is present, check if a linkServer is provided among some other things\n   *\n   * @param {object} data - the data object to process\n   * @returns {object} - the fulltext and data sources\n   */\n\n\n  var _processLinkData = function _processLinkData(data) {\n    var createGatewayUrl = this._createGatewayUrl;\n    var fullTextSources = [];\n    var dataProducts = [];\n    var countOpenUrls = 0;\n    var property = data.property; // check the esources property\n\n    _.forEach(data.esources, function (el) {\n      var parts = el.split('_');\n      var linkInfo = LINK_TYPES[el];\n      var linkServer = data.link_server;\n      var identifier = data.doi || data.issn || data.isbn; // Create an OpenURL\n      // Only create an openURL if the following is true:\n      //   - The article HAS an Identifier (doi, issn, isbn)\n      //   - The user is authenticated\n      //   - the user HAS a library link server\n\n      if (identifier && linkServer && countOpenUrls < 1) {\n        fullTextSources.push({\n          url: getOpenUrl({\n            metadata: data,\n            linkServer: linkServer\n          }),\n          openUrl: true,\n          type: 'INSTITUTION',\n          shortName: 'My Institution',\n          name: 'My Institution',\n          description: 'Find Article At My Institution',\n          rawType: 'INSTITUTION'\n        });\n        countOpenUrls += 1;\n      }\n\n      if (parts.length > 1) {\n        // if the entry is a publisher link, we need to do an extra step\n        if (parts[0] === 'PUB') {\n          fullTextSources.push({\n            url: createGatewayUrl(data.bibcode, el),\n            open: _.contains(property, parts[0] + '_OPENACCESS'),\n            // if the publisher field is present, use it as the shortName & name\n            shortName: data.publisher || linkInfo && linkInfo.shortName || el,\n            name: data.publisher || linkInfo && linkInfo.name || el,\n            type: linkInfo && linkInfo.type || 'HTML',\n            description: linkInfo && linkInfo.description,\n            rawType: el\n          });\n        } else {\n          fullTextSources.push({\n            url: createGatewayUrl(data.bibcode, el),\n            open: _.contains(property, parts[0] + '_OPENACCESS'),\n            shortName: linkInfo && linkInfo.shortName || el,\n            name: linkInfo && linkInfo.name || el,\n            type: linkInfo && linkInfo.type || 'HTML',\n            description: linkInfo && linkInfo.description,\n            rawType: el\n          });\n        } // if entry cannot be split, then it will not be open access\n\n      } else {\n        fullTextSources.push({\n          url: createGatewayUrl(data.bibcode, el),\n          open: false,\n          shortName: linkInfo && linkInfo.shortName || el,\n          name: linkInfo && linkInfo.name || el,\n          type: linkInfo && linkInfo.type || 'HTML',\n          description: linkInfo && linkInfo.description,\n          rawType: el\n        });\n      }\n    }); // if no preprint link is present, check links_data as well to make sure\n\n\n    var hasEprint = _.find(fullTextSources, {\n      name: LINK_TYPES.EPRINT_PDF.name\n    });\n\n    if (!hasEprint && _.isArray(data.links_data)) {\n      _.forEach(data.links_data, function (linkData) {\n        var link = JSON.parse(linkData);\n\n        if (/preprint/i.test(link.type)) {\n          var info = LINK_TYPES.EPRINT_PDF;\n          fullTextSources.push({\n            url: link.url,\n            open: true,\n            shortName: info && info.shortName || link.type,\n            name: info && info.name || link.type,\n            type: info && info.type || 'HTML',\n            description: info && info.description,\n            rawType: 'EPRINT_PDF'\n          });\n        }\n      });\n    } // check the data property\n\n\n    _.forEach(data.data, function (product) {\n      var parts = product.split(':');\n      var linkInfo = LINK_TYPES[parts[0]]; // are there any without a count? just make them 1\n\n      if (parts.length > 1) {\n        dataProducts.push({\n          url: createGatewayUrl(data.bibcode, parts[0]),\n          count: parts[1],\n          name: linkInfo ? linkInfo.shortName : parts[0],\n          description: linkInfo ? linkInfo.description : parts[0]\n        });\n      } else {\n        dataProducts.push({\n          url: createGatewayUrl(data.bibcode, product),\n          count: '1',\n          name: linkInfo ? linkInfo.shortName : product,\n          description: linkInfo ? linkInfo.description : product\n        });\n      }\n    }); // sort the data products by descending by count\n\n\n    dataProducts = _.sortBy(dataProducts, 'count').reverse();\n    return {\n      fullTextSources: sortByDefaultOrdering(fullTextSources),\n      dataProducts: dataProducts\n    };\n  };\n  /**\n   * Parse a data object to pull out the references/citations and table of contents\n   * it will also return a copy of the data object with a links property added\n   * @param {object} _data - the data object to parse\n   * @returns {object} - copy of the data object with links prop added\n   */\n\n\n  var _parseLinksDataForModel = function _parseLinksDataForModel(_data, linksData) {\n    var links = {\n      list: [],\n      data: [],\n      text: []\n    };\n\n    var data = _.extend({}, _data, {\n      links: links\n    }); // map linksData to links object\n\n\n    if (_.isPlainObject(linksData)) {\n      links = _.assign(links, {\n        data: links.data.concat(linksData.dataProducts || []),\n        text: links.text.concat(linksData.fullTextSources || [])\n      });\n    }\n\n    if (_.isPlainObject(data)) {\n      // check for the citations property\n      if (_.isPlainObject(data['[citations]']) && _.isString(data.bibcode)) {\n        var citations = data['[citations]']; // push it onto the links if the citation count is higher than 0\n\n        if (_.isNumber(citations.num_citations) && citations.num_citations > 0) {\n          links.list.push({\n            letter: 'C',\n            name: 'Citations (' + citations.num_citations + ')',\n            url: '#abs/' + enc(data.bibcode) + '/citations'\n          });\n        } // push onto the links if the reference count is higher than 0\n\n\n        if (_.isNumber(citations.num_references) && citations.num_references > 0) {\n          links.list.push({\n            letter: 'R',\n            name: 'References (' + citations.num_references + ')',\n            url: '#abs/' + enc(data.bibcode) + '/references'\n          });\n        }\n      } // check that we have property and whether table of contents is found\n\n\n      if (_.isArray(data.property) && _.isString(data.bibcode)) {\n        if (_.contains(data.property, 'TOC')) {\n          links.list.push({\n            letter: 'T',\n            name: 'Table of Contents',\n            url: '#abs/' + enc(data.bibcode) + '/toc'\n          });\n        }\n      }\n    } else {\n      throw new Error('data must be a plain object');\n    }\n\n    return data;\n  };\n  /**\n   * Takes data--a json object from apiResponse--and augments it with a \"links\"\n   * object. This is used for item views in the results widget. This is to be called\n   * by the processData method of a widget.\n   *\n   */\n\n\n  var parseLinksData = function parseLinksData(data) {\n    var parseLinksDataForModel = _.bind(this._parseLinksDataForModel, this);\n\n    var parseResourcesData = _.bind(this.parseResourcesData, this);\n\n    if (_.isArray(data)) {\n      return _.map(data, function (d) {\n        try {\n          var linkData = parseResourcesData(d);\n          return parseLinksDataForModel(d, linkData);\n        } catch (e) {\n          return d;\n        }\n      });\n    }\n\n    return [];\n  };\n  /**\n   * Check that data is an object and that it has the correct properties\n   *\n   * @param {object} data - the data to parse\n   */\n\n\n  var parseResourcesData = function parseResourcesData(data) {\n    var processLinkData = _.bind(this._processLinkData, this); // data must have 'property' and sub-props\n\n\n    if (_.isPlainObject(data)) {\n      if (_.isArray(data.property) && _.isString(data.bibcode)) {\n        // make sure if property has a esource or data, we find it on data as well\n        if (_.contains(data.property, 'ESOURCE') && !_.has(data, 'esources')) {\n          throw new Error('if `property` property contains `ESOURCE`, then data must have `esources` field');\n        }\n\n        if (_.contains(data.property, 'DATA') && !_.has(data, 'data')) {\n          throw new Error('if `property` property contains `DATA`, then data must have `data` field');\n        }\n\n        return processLinkData(_.extend({}, data));\n      }\n\n      throw new Error('data must have `property` and `bibcode`');\n    } else {\n      throw new Error('data must be a plain object');\n    }\n  };\n  /**\n   * Takes in a type and an identifier and will generate a link\n   * @param {string} bibcode - the bibcode\n   * @param {string} type - the type of identifier\n   * @param {string|array} identifier - the identifier to use to build the url\n   * @returns {string}\n   */\n\n\n  var createUrlByType = function createUrlByType(bibcode, type, identifier) {\n    var id = identifier;\n\n    if (_.isArray(id)) {\n      id = id[0];\n    }\n\n    if (_.isString(bibcode) && _.isString(type) && _.isString(id)) {\n      return GATEWAY_BASE_URL + bibcode + '/' + type + ':' + id;\n    }\n\n    return '';\n  };\n\n  return {\n    LINK_TYPES: LINK_TYPES,\n    parseLinksData: parseLinksData,\n    parseResourcesData: parseResourcesData,\n    createUrlByType: createUrlByType,\n    _createGatewayUrl: _createGatewayUrl,\n    _processLinkData: _processLinkData,\n    _parseLinksDataForModel: _parseLinksDataForModel\n  };\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/mixins/link_generator_mixin.js?");

/***/ }),

/***/ "./src/js/mixins/openurl_generator.js":
/*!********************************************!*\
  !*** ./src/js/mixins/openurl_generator.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? Object(arguments[i]) : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_) {\n  /**\n   * @typedef Metadata\n   * @property {string[]} page\n   * @property {string[]} doi\n   * @property {string} doctype\n   * @property {string} bibcode\n   * @property {string} author\n   * @property {string} issue\n   * @property {string} volume\n   * @property {string} pub\n   * @property {string} year\n   * @property {string[]} title\n   * @property {string[]} issn\n   * @property {string[]} isbn\n   */\n\n  /**\n   * check if value is string\n   * @param {any} val value to test\n   * @returns {boolean}\n   */\n  var isString = function isString(val) {\n    return _.isString(val);\n  };\n  /**\n   * Check if value is an array\n   * @param {any} val value to test\n   * @returns {boolean}\n   */\n\n\n  var isArray = function isArray(val) {\n    return _.isArray(val);\n  };\n  /**\n   * ADS specific fields\n   */\n\n\n  var STATIC_FIELDS = {\n    url_ver: 'Z39.88-2004',\n    rft_val_fmt: 'info:ofi/fmt:kev:mtx:',\n    rfr_id: 'info:sid/ADS',\n    sid: 'ADS'\n  };\n  /**\n   * Generates an OpenUrl using metadata and a linkServer\n   * @param {object} options\n   * @param {Metadata} options.metadata field data from database\n   * @param {string} options.linkServer base url to use for generating link\n   * @returns {string} the openUrl url\n   */\n\n  var getOpenUrl = function getOpenUrl(options) {\n    var _ref = options || {},\n        metadata = _ref.metadata,\n        _ref$linkServer = _ref.linkServer,\n        linkServer = _ref$linkServer === void 0 ? '' : _ref$linkServer;\n\n    var _ref2 = metadata || {},\n        page = _ref2.page,\n        doi = _ref2.doi,\n        doctype = _ref2.doctype,\n        bibcode = _ref2.bibcode,\n        author = _ref2.author,\n        issue = _ref2.issue,\n        volume = _ref2.volume,\n        pub = _ref2.pub,\n        year = _ref2.year,\n        title = _ref2.title,\n        issn = _ref2.issn,\n        isbn = _ref2.isbn; // parse out degree based on bibcode\n\n\n    var degree = isString(bibcode) && (bibcode.includes('PhDT') ? 'PhD' : bibcode.includes('MsT') ? 'Masters' : false); // genre is \"disseration\" for phd thesis, otherwise use doctype/article\n\n    var genre = isString(doctype) && isString(bibcode) && bibcode.includes('PhDT') ? 'dissertation' : isString(doctype) ? doctype : 'article'; // parse various fields to create a context object\n\n    var parsed = _objectSpread({}, STATIC_FIELDS, {\n      'rft.spage': isArray(page) ? page[0].split('-')[0] : false,\n      id: isArray(doi) ? 'doi:' + doi[0] : false,\n      genre: genre,\n      rft_id: [isArray(doi) ? 'info:doi/' + doi[0] : false, isString(bibcode) ? 'info:bibcode/' + bibcode : false],\n      'rft.degree': degree,\n      'rft.aulast': isString(author) ? author.split(', ')[0] : false,\n      'rft.aufirst': isString(author) ? author.split(', ')[1] : false,\n      'rft.issue': isString(issue) ? issue : false,\n      'rft.volume': isString(volume) ? volume : false,\n      'rft.jtitle': isString(pub) ? pub : false,\n      'rft.date': isString(year) ? year : false,\n      'rft.atitle': isArray(title) ? title[0] : false,\n      'rft.issn': isArray(issn) ? issn[0] : false,\n      'rft.isbn': isArray(isbn) ? isbn[0] : false,\n      'rft.genre': genre,\n      rft_val_fmt: STATIC_FIELDS.rft_val_fmt + (isString(doctype) ? doctype : 'article')\n    }); // add extra fields to context object\n\n\n    var context = _objectSpread({}, parsed, {\n      spage: parsed['rft.spage'],\n      volume: parsed['rft.volume'],\n      title: parsed['rft.jtitle'],\n      atitle: parsed['rft.atitle'],\n      aulast: parsed['rft.aulast'],\n      aufirst: parsed['rft.aufirst'],\n      date: parsed['rft.date'],\n      isbn: parsed['rft.isbn'],\n      issn: parsed['rft.issn']\n    }); // if the linkServer has query string, just append to the end\n\n\n    var openUrl = linkServer.includes('?') ? linkServer + '&' : linkServer + '?'; // generate array of query params from the context object\n\n    var fields = Object.keys(context).filter(function (k) {\n      return context[k];\n    }).map(function (key) {\n      if (context[key]) {\n        if (isArray(context[key])) {\n          return context[key].filter(function (v) {\n            return v;\n          }).map(function (val) {\n            return \"\".concat(key, \"=\").concat(val);\n          }).join('&');\n        }\n\n        return \"\".concat(key, \"=\").concat(context[key]);\n      }\n    });\n    return encodeURI(openUrl + fields.join('&'));\n  };\n\n  return {\n    getOpenUrl: getOpenUrl\n  };\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/mixins/openurl_generator.js?");

/***/ }),

/***/ "./src/js/modules/orcid/bio.js":
/*!*************************************!*\
  !*** ./src/js/modules/orcid/bio.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! jsonpath */ \"./src/libs/jsonpath.js\"), __webpack_require__(/*! js/modules/orcid/work */ \"./src/js/modules/orcid/work.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, jp, Work) {\n  var PATHS = {\n    firstName: '$.name[\"given-names\"].value',\n    lastName: '$.name[\"family-name\"].value',\n    orcid: '$.name.path'\n  };\n\n  var Bio = function Bio(bio) {\n    this._root = bio || {};\n\n    this.get = function (path) {\n      var val = jp.query(this._root, path);\n      return val[0];\n    };\n\n    this.toADSFormat = function () {\n      return {\n        responseHeader: {\n          params: {\n            orcid: this.getOrcid(),\n            firstName: this.getFirstName(),\n            lastName: this.getLastName()\n          }\n        }\n      };\n    }; // generate getters for each path on PATHS\n\n\n    _.reduce(PATHS, function (obj, p, k) {\n      if (_.isString(k) && k.slice) {\n        var prop = k[0].toUpperCase() + k.slice(1);\n        obj['get' + prop] = _.partial(obj.get, p);\n      }\n\n      return obj;\n    }, this);\n  };\n\n  return Bio;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/modules/orcid/bio.js?");

/***/ }),

/***/ "./src/js/modules/orcid/module.js":
/*!****************************************!*\
  !*** ./src/js/modules/orcid/module.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * ORCID module is the main component for enabling communication with ORCID Api\n *\n * It should be installed through discovery.config.js, it needs to go into\n * the controllers section (because it will create an instance of the OrcidApi\n * and insert that into services)\n *\n * You config should look like:\n *\n *   'js/apps/discovery/main': {\n *\n *      core: {\n *       controllers: {\n *         Orcid: 'js/modules/orcid/module'\n *         ....\n *         }\n *   }\n *\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! backbone */ \"./src/libs/backbone.js\"), __webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! js/components/generic_module */ \"./src/js/components/generic_module.js\"), __webpack_require__(/*! js/modules/orcid/orcid_api */ \"./src/js/modules/orcid/orcid_api.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Backbone, _, GenericModule, OrcidApi) {\n  var OrcidModule = GenericModule.extend({\n    activate: function activate(beehive) {\n      var config = beehive.getObject('DynamicConfig');\n\n      if (!config) {\n        throw new Error('DynamicConfig is not available to Orcid module');\n      }\n\n      var redirectUrlBase = config.orcidRedirectUrlBase || location.protocol + '//' + location.host;\n      var orcidClientId = config.orcidClientId;\n      var orcidApiEndpoint = config.orcidApiEndpoint;\n      var orcidLoginEndpoint = config.orcidLoginEndpoint;\n\n      if (!orcidClientId || !orcidApiEndpoint) {\n        throw new Error('Missing configuration for ORCID module: orcidApiEndpoint, orcidClientId');\n      } // TODO:rca - clean up this\n\n\n      var opts = {\n        redirectUrlBase: redirectUrlBase,\n        apiEndpoint: orcidApiEndpoint,\n        clientId: orcidClientId,\n        worksUrl: orcidApiEndpoint + '/{0}/orcid-works',\n        loginUrl: orcidLoginEndpoint + '?scope=/orcid-profile/read-limited%20/orcid-works/create%20/orcid-works/update&response_type=code&access_type=offline' + '&show_login=true' + '&client_id=' + orcidClientId,\n        exchangeTokenUrl: orcidApiEndpoint + '/exchangeOAuthCode'\n      };\n\n      _.extend(config, {\n        Orcid: opts\n      });\n\n      this.activateDependencies(beehive);\n    },\n    activateDependencies: function activateDependencies(beehive) {\n      var orcidApi = beehive.getService('OrcidApi');\n\n      if (orcidApi) {\n        // already activated\n        return;\n      }\n\n      orcidApi = new OrcidApi();\n      orcidApi.activate(beehive);\n      beehive.addService('OrcidApi', orcidApi);\n    }\n  });\n  return function () {\n    return {\n      activate: function activate(beehive) {\n        var om = new OrcidModule();\n        om.activate(beehive);\n      }\n    };\n  };\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/modules/orcid/module.js?");

/***/ }),

/***/ "./src/js/modules/orcid/orcid_api.js":
/*!*******************************************!*\
  !*** ./src/js/modules/orcid/orcid_api.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * This is the core of the ORCID implementation\n * Written by (rca) - totally re-implemented the\n * initial implementation.\n *\n * The important details are:\n *\n *  - all communication with ORCID happens in JSON\n *  - there are multiple access points\n *    addWork()\n *    updateWork()\n *    deleteWork()\n *\n *    But in reality, the ORCID API allows the following\n *    operations:\n *\n *      reading (GET)\n *      adding (POST)\n *      updating (PUT)\n *      deleting (DELETE)\n *\n * This module will be contacting a web-service, such\n * a service needs to allows CORS requests (since we\n * run inside a browser)\n *\n * Our implementation of the orcid-proxy can be found\n * at:  http://github.com/adsabs/orcid-service\n *\n * The important configuration details are configured\n * in the ./module.js (the module will actually create\n * OrcidApi and insert it into the beehive)\n *\n *\n * TODO:\n *  - error handling (discover more error situations and\n *    take care of them; such as duplicated put-codes)\n *\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! bootstrap */ \"./src/libs/bootstrap/bootstrap.js\"), __webpack_require__(/*! jquery */ \"./src/libs/jquery.js\"), __webpack_require__(/*! backbone */ \"./src/libs/backbone.js\"), __webpack_require__(/*! js/components/generic_module */ \"./src/js/components/generic_module.js\"), __webpack_require__(/*! js/mixins/dependon */ \"./src/js/mixins/dependon.js\"), __webpack_require__(/*! js/components/pubsub_events */ \"./src/js/components/pubsub_events.js\"), __webpack_require__(/*! js/mixins/link_generator_mixin */ \"./src/js/mixins/link_generator_mixin.js\"), __webpack_require__(/*! js/components/api_query */ \"./src/js/components/api_query.js\"), __webpack_require__(/*! js/components/api_request */ \"./src/js/components/api_request.js\"), __webpack_require__(/*! js/mixins/hardened */ \"./src/js/mixins/hardened.js\"), __webpack_require__(/*! js/components/api_targets */ \"./src/js/components/api_targets.js\"), __webpack_require__(/*! js/components/api_query_updater */ \"./src/js/components/api_query_updater.js\"), __webpack_require__(/*! js/components/api_feedback */ \"./src/js/components/api_feedback.js\"), __webpack_require__(/*! js/modules/orcid/work */ \"./src/js/modules/orcid/work.js\"), __webpack_require__(/*! js/modules/orcid/profile */ \"./src/js/modules/orcid/profile.js\"), __webpack_require__(/*! js/modules/orcid/bio */ \"./src/js/modules/orcid/bio.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, Bootstrap, $, Backbone, GenericModule, Mixins, PubSubEvents, LinkGeneratorMixin, ApiQuery, ApiRequest, HardenedMixin, ApiTargets, ApiQueryUpdater, ApiFeedback, Work, Profile, Bio) {\n  var OrcidApi = GenericModule.extend({\n    /**\n     * Initialize the service\n     */\n    initialize: function initialize() {\n      this.userData = {};\n      this.addCache = [];\n      this.deleteCache = [];\n      this.getUserProfileCache = [];\n      this.authData = null;\n      this.addWait = 3000;\n      this.deleteWait = 100;\n      this.profileWait = 100;\n      this.maxAddChunkSize = 100;\n      this.maxDeleteChunkSize = 10;\n      this.db = {};\n      this.clearDBWait = 30000;\n      this.dbUpdatePromise = null;\n      this.maxQuerySize = 100;\n      this.queryUpdater = new ApiQueryUpdater('orcid_api');\n      this.orcidApiTimeout = 30000; // 30 seconds\n\n      this.adsQueryTimeout = 10; // 10 seconds\n\n      this.dirty = true; // initialize as dirty, so it updates\n    },\n\n    /**\n     * Activate the service.  Setup the configuration and\n     * save the current ORCID preferences.\n     *\n     * @param {BeeHive} beehive\n     */\n    activate: function activate(beehive) {\n      var storage = beehive.getService('PersistentStorage');\n      var config = beehive.getObject('DynamicConfig');\n      this.setBeeHive(beehive);\n      this.config = {};\n\n      _.extend(this.config, config.Orcid);\n\n      if (storage) {\n        var orcid = storage.get('Orcid');\n\n        if (orcid && orcid.authData) {\n          this.saveAccessData(orcid.authData);\n        }\n      }\n\n      this._addWork = _.debounce(this._addWork, this.addWait);\n      this._getUserProfile = _.debounce(this._getUserProfile, this.profileWait);\n      this._deleteWork = _.debounce(this._deleteWork, this.deleteWait);\n    },\n\n    /**\n     * Checks access to ORCID api by making request for a user profile\n     * returns a promise; done() means success, fail() no access\n     *\n     * @returns {jQuery.Promise}\n     */\n    checkAccessOrcidApiAccess: function checkAccessOrcidApiAccess() {\n      if (this.hasAccess()) {\n        return this.getUserProfile();\n      }\n\n      return $.Deferred().reject().promise();\n    },\n\n    /**\n     * Checks to see if the api has been given authentication information\n     * from ORCiD, and if that information has expired or not\n     * @returns {boolean}\n     */\n    hasAccess: function hasAccess() {\n      if (this.authData && this.authData.expires) {\n        return this.authData.expires > new Date().getTime();\n      }\n\n      return false;\n    },\n\n    /**\n     * Redirects to ORCID where the user logs in and ORCID will forward\n     * user back to us\n     *\n     * @param {String} [targetRoute='#user/orcid'] targetRoute\n     */\n    signIn: function signIn(targetRoute) {\n      this.getPubSub().publish(this.getPubSub().APP_EXIT, {\n        type: 'orcid',\n        url: this.config.loginUrl + '&redirect_uri=' + encodeURIComponent(this.config.redirectUrlBase + (targetRoute || '/user/orcid'))\n      }); // make sure to redirect to the proper page after sign in\n\n      this.getPubSub().publish(this.getPubSub().ORCID_ANNOUNCEMENT, 'login');\n    },\n\n    /**\n     * Set the preferences for the user\n     *\n     * @param {Object} userData - user data to update\n     * @returns {*|jQuery.Promise}\n     */\n    setADSUserData: function setADSUserData(userData) {\n      var url = this.getBeeHive().getService('Api').url + ApiTargets.ORCID_PREFERENCES + '/' + this.authData.orcid;\n      var request = this.createRequest(url, {\n        method: 'POST'\n      }, userData);\n      request.fail(function () {\n        var msg = 'ADS ORCiD preferences could not be set';\n        console.error.apply(console, [msg].concat(arguments));\n      });\n      return request;\n    },\n\n    /**\n     * Uses the ADS ORCID preferences endpoint to grab the preferences\n     * for this user\n     *\n     * @returns {*|jQuery.Promise}\n     */\n    getADSUserData: function getADSUserData() {\n      var self = this;\n      var url = this.getBeeHive().getService('Api').url + ApiTargets.ORCID_PREFERENCES + '/' + this.authData.orcid;\n      var request = this.createRequest(url);\n      request.fail(function () {\n        self.signOut();\n        self.getBeeHive().getObject('User').setOrcidMode(0);\n        var title = 'Expired ORCID login';\n        var msg = ['Your ORCID login has expired.', 'Please reload the page and sign in again to access the page.', '', '<button onclick=\"location.reload()\" class=\"btn btn-primary\" role=\"button\">Reload</button>'];\n        var pubSub = self.getPubSub();\n        pubSub.publish(pubSub.ALERT, new ApiFeedback({\n          title: title,\n          msg: msg.join('<br/>'),\n          modal: true,\n          type: 'warning'\n        }));\n      });\n      return request;\n    },\n    getUserBio: function getUserBio() {\n      var dd = new $.Deferred();\n      var url = this.getBeeHive().getService('Api').url + ApiTargets.ORCID_NAME + '/' + this.authData.orcid;\n      var request = this.createRequest(url);\n      request.fail(function () {\n        var msg = 'ADS name could not be retrieved';\n        console.error.apply(console, [msg].concat(arguments));\n        dd.reject();\n      });\n      request.done(function (bio) {\n        var orcidBio = new Bio(bio);\n        dd.resolve(orcidBio);\n      });\n      return dd.promise();\n    },\n\n    /**\n     * Forgets the OAuth access_token\n     */\n    signOut: function signOut() {\n      this.saveAccessData(null);\n      this.getPubSub().publish(this.getPubSub().ORCID_ANNOUNCEMENT, 'logout');\n    },\n\n    /**\n     * Checks if the exchange code is present on the string\n     *\n     * @param {String} searchString\n     * @returns {boolean}\n     */\n    hasExchangeCode: function hasExchangeCode(searchString) {\n      return !!this.getExchangeCode(searchString);\n    },\n\n    /**\n     * Get the exchange token from the location string or one specified\n     * @param {String} [searchString=window.location.search] searchString\n     * @returns {*|String|Undefined}\n     */\n    getExchangeCode: function getExchangeCode(searchString) {\n      return this.getUrlParameter('code', searchString || window.location.search);\n    },\n\n    /**\n     * Extract values from the URL (used to get code from redirects)\n     *\n     * @param {String} sParam - parameter to find\n     * @param {String} searchString - string to search\n     * @returns {String|Undefined} - value of param, if found\n     */\n    getUrlParameter: function getUrlParameter(sParam, searchString) {\n      var sPageURL = searchString.substring(1);\n      var sURLVariables = sPageURL.split('&');\n\n      for (var i = 0; i < sURLVariables.length; i++) {\n        var sParameterName = sURLVariables[i].split('=');\n\n        if (sParameterName[0] === sParam) {\n          return decodeURIComponent(sParameterName[1]);\n        }\n      }\n    },\n\n    /**\n     * Using access code retrieve the access_token from ORCID\n     *\n     * Example response:\n     *  {\"access_token\":\"4274a0f1-36a1-4152-9a6b-4246f166bafe\",\"token_type\":\"Bearer\",\"ex\n     *  pires_in\":3599,\"scope\":\"/orcid-works/create /orcid-profile/read-limited /orcid-w\n     *  orks/update\",\"orcid\":\"0000-0001-8178-9506\",\"name\":\"Roman Chyla\"}\n     *\n     * @param {String} oAuthCode\n     * @returns {jQuery.Promise}\n     */\n    getAccessData: function getAccessData(oAuthCode) {\n      var api = this.getBeeHive().getService('Api');\n      var promise = $.Deferred();\n      var opts = {\n        url: this.config.exchangeTokenUrl,\n        done: _.bind(promise.resolve, promise),\n        fail: _.bind(promise.reject, promise),\n        always: _.bind(promise.always, promise),\n        headers: {\n          Accept: 'application/json',\n          Authorization: api.access_token\n        }\n      };\n      api.request(new ApiRequest({\n        target: this.config.exchangeTokenUrl,\n        query: new ApiQuery({\n          code: oAuthCode\n        })\n      }), opts);\n      return promise.promise();\n    },\n\n    /**\n     * Save the passed in authentication data from orcid\n     * into user persistent storage for safe keeping.\n     *\n     * @param {object} authData - the authentication data\n     */\n    saveAccessData: function saveAccessData(authData) {\n      var beehive = this.getBeeHive();\n\n      if (authData && !authData.expires && authData.expires_in) {\n        authData.expires = new Date().getTime() + (authData.expires_in * 1000 - 1000);\n      }\n\n      this.authData = authData;\n      var storage = beehive.getService('PersistentStorage');\n\n      if (storage) {\n        var orcid = storage.get('Orcid') || {};\n        orcid.authData = authData;\n        storage.set('Orcid', orcid);\n      }\n    },\n\n    /**\n     * ===============================================================================\n     * API ORCID access points\n     * ===============================================================================\n     */\n\n    /**\n     * Convenience method for converting target short name into the full url\n     * @param {String} name - short name for endpoint\n     * @param {Array|Number} [putCodes] putCodes - putcodes to append to end of url\n     * @returns {string} - the url\n     */\n    getUrl: function getUrl(name, putCodes) {\n      var targets = {\n        profile_bib: '/orcid-profile/simple',\n        profile_full: '/orcid-profile/full?update=True',\n        works: '/orcid-works',\n        work: '/orcid-work'\n      };\n      var url = this.config.apiEndpoint + '/' + this.authData.orcid + targets[name];\n      var end = _.isArray(putCodes) ? putCodes.join(',') : putCodes;\n\n      if (end) {\n        url += '/' + end;\n      }\n\n      return url;\n    },\n\n    /**\n     * Create a new request and filter success/fail always to appropriate methods\n     * @param {String} url - url to send request to\n     * @param {Object} [options={}] options - options for request\n     * @param {Object} [data] data - payload of message\n     * @returns {jQuery.Promise} promise object for request\n     */\n    createRequest: function createRequest(url, options, data) {\n      if (_.isUndefined(url)) {\n        throw new Error('Url must be defined');\n      }\n\n      var $dd = $.Deferred();\n      var prom = this.sendData(url, data, options || {});\n      prom.done(_.bind($dd.resolve, $dd));\n      prom.fail(_.bind($dd.reject, $dd));\n      prom.always(_.bind($dd.always, $dd));\n      return $dd.promise();\n    },\n\n    /**\n     * Debounced method for keeping lots of request for the profile at bay.\n     * This method will resolve all awaiting promises when there has been an\n     * idle period following the initial request.\n     *\n     * Different from getWorks, because with profile we are only concerned\n     * with the most up-to-date response.  So a single response to resolve them\n     * all is good enough.\n     */\n    _getUserProfile: function _getUserProfile() {\n      var self = this;\n      var request = this.createRequest(this.getUrl('profile_full')); // get everything so far in the cache\n\n      var cache = self.getUserProfileCache.splice(0);\n      request.done(function (profile) {\n        _.forEach(cache, function (promise) {\n          orcidProfile = new Profile(profile);\n          promise.resolve(orcidProfile.setWorks(_.map(profile, function (profile, idx) {\n            return new Work(profile);\n          })));\n        });\n      });\n      request.fail(function () {\n        var args = arguments;\n\n        _.forEach(cache, function (promise) {\n          promise.reject.apply(promise, args);\n        });\n      });\n    },\n\n    /**\n     * Retrieves user profile\n     * Must have scope: /orcid-profile/read-limited\n     *\n     * Adds to the internal profile cache, which\n     *\n     * @returns {jQuery.Promise<Profile>} - Promise that resolves with profile\n     */\n    getUserProfile: function getUserProfile() {\n      var $dd = $.Deferred();\n      this.getUserProfileCache.push($dd);\n\n      this._getUserProfile.call(this);\n\n      return $dd.promise();\n    },\n\n    /**\n     * Retrieve an entire work entry from ORCiD\n     * This is different than the summary, it includes all information they\n     * have in their system for the entry.\n     *\n     * This is necessary to get the author information\n     *\n     * @param {Number} putCode - putcode to be retrieved\n     * @returns {jQuery.Promise<Work>} - promise that resolves with the work\n     */\n    getWork: function getWork(putCode) {\n      var $dd = $.Deferred();\n      this.createRequest(this.getUrl('works', putCode)).done(function (work) {\n        $dd.resolve(new Work(work));\n      }).fail(_.bind($dd.reject, $dd));\n      return $dd.promise();\n    },\n\n    /**\n     * Retrieve the full works as an array,\n     * this can take any number of putcodes, it will chunk the requests and\n     * return a deferred that will resolve with an array of works\n     *\n     * @param {Array} putCodes - putcodes to be retrieved\n     * @returns {jQuery.Promise<Work[]>}\n     */\n    getWorks: function getWorks(putCodes) {\n      if (!_.isArray(putCodes)) {\n        throw new TypeError('putcodes must be an Array');\n      }\n\n      var $dd = $.Deferred();\n      var chunkSize = 50;\n      var proms = [];\n\n      for (var i = 0, j = putCodes.length; i < j; i += chunkSize) {\n        var chunk = putCodes.slice(i, i + chunkSize);\n        var url = this.getUrl('works') + '/' + chunk.join(',');\n        proms.push(_.partial(this.createRequest, url));\n      }\n\n      var reqs = $.when.apply($, proms);\n      reqs.done(_.bind($dd.resolve, $dd));\n      reqs.fail(function () {\n        // we are passed an array for EACH argument, so passing the whole thing\n        $dd.reject(arguments);\n      });\n      return $dd.promise();\n    },\n\n    /**\n     * Update an existing ORCiD work.  This method requires that the putcode\n     * for the work be present in the update object.\n     *\n     * @param {Object} work - object containing updated orcid information\n     * @param {Number} work[\"put-code\"] - putcode to update\n     * @returns {jQuery.Promise} - promise for the request\n     */\n    updateWork: function updateWork(work) {\n      if (!_.isPlainObject(work)) {\n        throw new TypeError('Work should be a simple object');\n      }\n\n      var putcode = work['put-code'];\n\n      if (!putcode) {\n        return $.Deferred().reject().promise();\n      }\n\n      var url = this.getUrl('works', putcode);\n      return this.createRequest(url, {\n        method: 'PUT'\n      }, work);\n    },\n\n    /**\n     * Delete a single work from ORCiD\n     *\n     * @param {String | Number} putCode - putcode of work to be deleted\n     * @returns {jQuery.Promise} - promise for the request\n     */\n    deleteWork: function deleteWork(putCode) {\n      if (!putCode) {\n        return $.Deferred().reject('No Putcode found').promise();\n      }\n\n      var $dd = $.Deferred();\n      this.deleteCache.push({\n        // create unique request id to ride along with request\n        id: _.uniqueId(),\n        putCode: putCode,\n        promise: $dd\n      });\n\n      this._deleteWork.call(this);\n\n      return $dd.promise();\n    },\n\n    /**\n     * Debounced method that takes chunks of deletes and fires them off\n     * in batches, this way we don't send 100 at once.\n     */\n    _deleteWork: function _deleteWork() {\n      var self = this;\n      var cachedDeletes = this.deleteCache.slice(0);\n      var chunk;\n      var promises = [];\n      var chunks = []; // chunk up the deletes\n\n      for (var i = 0; i < cachedDeletes.length; i += this.maxDeleteChunkSize) {\n        chunk = cachedDeletes.slice(i, i + this.maxDeleteChunkSize);\n        chunks.push(chunk);\n      } // take each chunk, loop through them creating a request for each\n\n\n      _.forEach(chunks, function (c, i) {\n        _.forEach(c, function (del) {\n          // add the promise object to array for checking later\n          promises.push(del.promise.promise()); // staggered delays, for example:\n          // 1st request -> wait 3 seconds\n          // 2nd request -> wait 6 seconds\n          // 3rd request -> wait 9 seconds\n          // ...\n\n          _.delay(function () {\n            // create the request for each delete\n            var request = self.createRequest(self.getUrl('works', del.putCode), {\n              beforeSend: function beforeSend(xhr) {\n                xhr._id = del.id;\n              },\n              method: 'DELETE'\n            }); // apply the promise handlers\n\n            request.done(_.bind(del.promise.resolve, del.promise)).fail(_.bind(del.promise.reject, del.promise)).always(_.bind(del.promise.always, del.promise)); // remove the entry from the cache\n\n            var idx = self.deleteCache.indexOf(del);\n            self.deleteCache.splice(idx, idx + 1);\n          }, self.deleteWait * i);\n        });\n      }); // resolve remaining promises\n\n\n      var finalizeCacheEntries = function finalizeCacheEntries() {\n        self.deleteCache = _.reduce(self.deleteCache, function (res, entry) {\n          entry.promise.state() === 'pending' ? entry.promise.reject() : res.push(entry);\n          return res;\n        }, []);\n      };\n\n      $.when.apply($, promises).always(finalizeCacheEntries);\n    },\n\n    /**\n     * Add new ORCiD work\n     * This will add an entry to an internal cache which will be used when\n     * the requests finally run.  Here we provide the old work, id and promise\n     * to the cache.\n     *\n     * @param {Object} orcidWork\n     */\n    addWork: function addWork(orcidWork) {\n      if (!_.isPlainObject(orcidWork)) {\n        throw new TypeError('Should be plain object');\n      }\n\n      var $dd = $.Deferred();\n      this.addCache.push({\n        // create unique request id to ride along with request\n        id: _.uniqueId(),\n        work: orcidWork,\n        promise: $dd\n      });\n\n      this._addWork.call(this);\n\n      return $dd.promise();\n    },\n\n    /**\n     * Debounced method for adding works\n     * This method will run iif it has been called once and then an\n     * idle period has passed without another call.  At that point it will\n     * get the current cache and make a request.\n     *\n     * Cached entries are checked against ids that ride along the request on\n     * the xhr object.\n     *\n     * @private\n     * @returns {*}\n     */\n    _addWork: function _addWork() {\n      var self = this;\n\n      var cachedWorks = _.map(self.addCache, 'work');\n\n      var cachedIds = _.map(self.addCache, 'id');\n\n      var prom = self._addWorks(cachedWorks, cachedIds); // On success, create a new work and remove the entry from the cache\n\n\n      prom.done(function (workResponse) {\n        // workResponse will be in ID:WORK format\n        _.forEach(workResponse, function (work, id) {\n          var cacheEntry = _.find(self.addCache, function (e) {\n            return e.id === id;\n          });\n\n          if (!cacheEntry) {\n            console.error('No Cache entry found');\n            return true;\n          }\n\n          var promise = cacheEntry.promise;\n          var oldWork = cacheEntry.work; // check to see if the work is an error message, { error: {...} }\n\n          if (!work) {\n            // something weird going on with work, just reject\n            promise.reject();\n          } else if (work.error) {\n            // check to see if it's just a conflict\n            if (work.error['response-code'] === 409) {\n              promise.resolve(oldWork);\n            } else {\n              promise.reject();\n            }\n          } else {\n            // no errors, resolve with the new work, { work: {...} }\n            promise.resolve(new Work(work.work));\n          } // remove from the cache\n\n\n          var idx = self.addCache.indexOf(cacheEntry);\n          self.addCache.splice(idx, idx + 1);\n        });\n      }); // on fail, reject the promises\n      // this should receive a list of ids which we can finish up with\n\n      prom.fail(function (ids) {\n        var args = arguments;\n\n        _.forEach(ids, function (id) {\n          // find the cache entry\n          var idx = _.findIndex(self.addCache, {\n            id: id\n          });\n\n          if (idx >= 0) {\n            // grab reference to promise\n            var promise = self.addCache[idx].promise; // remove entry from cache\n\n            self.addCache.splice(idx, idx + 1); // if it is still pending, reject it now\n\n            if (promise.state() === 'pending') {\n              promise.reject.apply(promise, args);\n            }\n          }\n        });\n      });\n    },\n\n    /**\n     * Add multiple works to ORCiD\n     * This method will chunk the incoming works by a maximum chunk size\n     * and send a separate request for each.  When all requests complete, it\n     * will aggregate and index them using unique request ids\n     *\n     * @private\n     * @param {Object[]} orcidWorks\n     * @param {Number[]} ids\n     */\n    _addWorks: function _addWorks(orcidWorks, ids) {\n      var self = this;\n\n      if (!_.isArray(orcidWorks) || !_.isArray(ids)) {\n        throw new TypeError('works and ids must be arrays');\n      }\n\n      var $dd = $.Deferred();\n      var promises = [];\n      var chunk;\n      var chunkIds;\n\n      for (var i = 0; i < orcidWorks.length; i += this.maxAddChunkSize) {\n        chunk = orcidWorks.slice(i, i + this.maxAddChunkSize);\n        chunkIds = ids.slice(i, i + this.maxAddChunkSize); // create bulk object\n\n        var bulkWorks = {\n          bulk: []\n        };\n\n        _.each(chunk, function (w) {\n          bulkWorks.bulk.push({\n            work: w\n          });\n        });\n\n        var url = this.getUrl('works');\n        promises.push(this.createRequest(url, {\n          beforeSend: function beforeSend(xhr) {\n            xhr.cacheIds = chunkIds;\n          },\n          method: 'POST'\n        }, bulkWorks));\n      } // when all the promises finish, aggregate the result and index by id\n\n\n      $.when.apply($, promises).then(function () {\n        // make sure arguments is an 2d array\n        var doneArgs = _.isArray(arguments[0]) ? arguments : [arguments];\n\n        var obj = _.reduce(doneArgs, function (res, args) {\n          var works = args && args[0] && args[0].bulk;\n          var ids = args && args[2] && args[2].cacheIds; // build response object, indexed by ids\n\n          _.forEach(ids, function (id, idx) {\n            res[id] = works[idx];\n          });\n\n          return res;\n        }, {});\n\n        $dd.resolve(obj);\n      }, function (xhr) {\n        self.setDirty();\n        $dd.reject.apply($dd, [xhr.cacheIds].concat(arguments));\n      });\n      return $dd.promise();\n    },\n    // #############################################################################\n\n    /**\n     * Use Api service to make a request to the ORCID api\n     *\n     * @param {string} url - request url\n     * @param {Object} [data={}] data - request payload\n     * @param {Object} [opts={}] opts - request options\n     * @returns {*}\n     */\n    sendData: function sendData(url, data, opts) {\n      var result = $.Deferred();\n      opts = opts || {};\n      var options = {\n        type: 'GET',\n        url: url,\n        contentType: 'application/json',\n        cache: !!this.dbUpdatePromise,\n        // true = do not generate _ parameters (let browser cache responses)\n        timeout: this.orcidApiTimeout,\n        done: _.bind(result.resolve, result),\n        fail: _.bind(result.reject, result),\n        always: _.bind(result.always, result)\n      };\n\n      if (data) {\n        options.dataType = 'json';\n        options.data = JSON.stringify(data); // because ORCID sends empty response for POST requests\n        // we must be able to handle it properly (but it is not\n        // nice of them)\n\n        options.converters = {\n          '* text': window.String,\n          'text html': true,\n          'text json': function textJson(input) {\n            input = input || '{}';\n            return $.parseJSON(input);\n          },\n          'text xml': $.parseXML\n        };\n      } else {\n        options.data = null; // to prevent api.request() from adding {} to the url params\n      }\n\n      _.extend(options, opts);\n\n      var api = this.getBeeHive().getService('Api');\n\n      if (!options.headers) {\n        options.headers = {};\n      }\n\n      options.headers.Authorization = api.access_token;\n\n      if (!options.headers['Orcid-Authorization'] && this.authData) {\n        options.headers['Orcid-Authorization'] = 'Bearer ' + this.authData.access_token;\n      }\n\n      if (!options.headers['Content-Type']) {\n        options.headers['Content-Type'] = 'application/json';\n      }\n\n      if (!options.headers.Accept) {\n        options.headers.Accept = 'application/json';\n      }\n\n      api.request(new ApiRequest({\n        target: url,\n        query: new ApiQuery(),\n        options: options\n      }));\n      return result.promise();\n    },\n\n    /**\n     * Takes in a query containing all identifiers to check against what is in\n     * ADS.  Query will return all known (to ADS) records, but in the following\n     * format:\n     *\n     * \"IDENTIFIER_TYPE:IDENTIFIER_VALUE\": \"BIBCODE\"\n     *\n     * @example\n     * q = ['bibcode:2018CNSNS..56..270Q OR alternate_bibcode:2018CNSNS..56..270Q']\n     * // returns:\n     * {\n     *  \"bibcode:2018CNSNS..56..270Q\": \"2018CNSNS..56..270Q\"\n     *  \"doi:10.1016/j.cnsns.2017.08.014\": \"2018CNSNS..56..270Q\"\n     * }\n     *\n     * @param {ApiQuery} apiQuery - query to check\n     * @returns {jQuery.Promise<Object>} - request promise\n     * @private\n     */\n    _checkIdsInADS: function _checkIdsInADS(apiQuery) {\n      var api = this.getBeeHive().getService('Api');\n      var dd = $.Deferred();\n      apiQuery.set('fl', 'bibcode, doi, alternate_bibcode');\n      apiQuery.set('rows', '5000');\n\n      var onDone = function onDone(data) {\n        if (!data || !data.response || !data.response.docs) {\n          return dd.resolve({});\n        } // we have to create an identifier string for each\n\n\n        var ret = _.reduce(data.response.docs, function (res, doc) {\n          var bibcode = doc.bibcode.toLowerCase();\n          var key = 'identifier:' + bibcode;\n          res[key] = bibcode;\n\n          _.each(doc.doi, function (doi) {\n            var key = 'identifier:' + doi.toLowerCase().replace('doi:', '');\n            res[key] = bibcode;\n          });\n\n          _.each(doc.alternate_bibcode, function (ab) {\n            var key = 'identifier:' + ab.toLowerCase();\n            res[key] = bibcode;\n          });\n\n          return res;\n        }, {});\n\n        dd.resolve(ret);\n      };\n\n      var onFail = function onFail() {\n        dd.resolve({});\n      };\n\n      api.request(new ApiRequest({\n        target: ApiTargets.SEARCH,\n        query: apiQuery,\n        options: {\n          done: onDone,\n          fail: onFail\n        }\n      })).fail(onFail); // reject after timeout, if necessary\n\n      (function check(count) {\n        if (dd.state() === 'pending' && count <= 0) {\n          return dd.reject('Request Timeout');\n        }\n\n        if (dd.state() === 'resolved') {\n          return;\n        }\n\n        _.delay(check, 1000, --count);\n      })(this.adsQueryTimeout);\n\n      return dd.promise();\n    },\n\n    /**\n     * Check if the work was sourced by ADS\n     * @param {Work} work\n     */\n    isSourcedByADS: function isSourcedByADS(work) {\n      return work.getSourceName().indexOf('NASA Astrophysics Data System') > -1;\n    },\n\n    /**\n     * Generate a query string by doing custom joins on the array.  Each entry\n     * in the passed in query gets checked and added to the generated string\n     * by \"OR\"-ing them together.\n     *\n     * @example\n     * _buildQuery({\n     *  identifier: ['2018CNSNS..56..270Q', '2017CNSNS..56..270Q']\n     * });\n     * // returns:\n     * { \"q\": [\n     *  \"identifier:2018CNSNS..56..270Q OR identifier:2017CNSNS..56..270Q\"\n     * ]}\n     *\n     * @param {Object} query - query object used to build new ApiQuery\n     * @param {string[]} [query.identifier] query.identifier\n     * @returns {ApiQuery} - a new api query to use in a request\n     * @private\n     */\n    _buildQuery: function _buildQuery(query) {\n      if (_.isEmpty(query) || !query.identifier) {\n        return null;\n      } // reformat array as 'identifier:xxx OR identifier:xxx'\n\n\n      var q = _.filter(query.identifier, function (i) {\n        // grab only non-empty entries\n        return !_.isEmpty(i.trim()) || i === 'NONE';\n      }).join(' OR '); // don't let an empty query string through\n\n\n      if (_.isEmpty(q)) {\n        return null;\n      }\n\n      return new ApiQuery({\n        q: 'identifier:(' + q + ')'\n      });\n    },\n\n    /**\n     * Updates our current knowledge of ORCID Data\n     * This will typically be only summaries of works\n     *\n     * @param {Profile} [profile] profile\n     */\n    updateDatabase: function updateDatabase(profile) {\n      var self = this;\n\n      if (this.dbUpdatePromise && this.dbUpdatePromise.state() === 'pending') {\n        return this.dbUpdatePromise.promise();\n      }\n\n      this.dbUpdatePromise = $.Deferred(); // set the database object and resolve the promise\n\n      var finishUpdate = function finishUpdate(db) {\n        var dbPromise = self.dbUpdatePromise;\n        self.setClean();\n        self.db = db;\n\n        if (dbPromise) {\n          dbPromise.resolve();\n        }\n\n        setTimeout(function () {\n          if (dbPromise && dbPromise.state() !== 'pending') {\n            dbPromise = null;\n            self.setDirty();\n          }\n        }, self.clearDBWait);\n      }; // apply the update to the database\n\n\n      var update = function update(profile) {\n        // get the works and all external IDs for them\n        var works = profile.getWorks();\n        var query = [];\n        var db = {};\n\n        _.forEach(works, function addIdsToDatabase(w, i) {\n          var key = 'identifier:';\n          var ids = w.getIdentifier();\n          key += ids;\n\n          if (key) {\n            query.push(key);\n            db[key.toLowerCase()] = {\n              sourcedByADS: self.isSourcedByADS(w),\n              putcode: w.getPutCode(),\n              idx: i\n            };\n          }\n        });\n\n        if (query.length && self.maxQuerySize > 0) {\n          var whereClauses = [];\n          query = query.sort();\n\n          var steps = _.range(0, query.length, self.maxQuerySize);\n\n          for (var i = 0; i < steps.length; i++) {\n            var q = {};\n\n            for (var j = steps[i]; j < steps[i] + self.maxQuerySize; j++) {\n              if (j >= query.length) break;\n              var ps = query[j].split(':');\n              if (!q[ps[0]]) q[ps[0]] = [];\n              q[ps[0]].push(self.queryUpdater.quoteIfNecessary(ps[1]));\n            }\n\n            var newQuery = self._buildQuery(q);\n\n            if (newQuery) {\n              whereClauses.push(self._checkIdsInADS(newQuery));\n            }\n          }\n        } else {\n          finishUpdate(db);\n        }\n        /**\n         * This will receive a set of of identifier strings that are in the\n         * following format:\n         *\n         * @example\n         * [\n         *  identifier:2017geoji.tmp...42f:\"2017geoji.209..597f\",\n         *  identifier:2017gml...tmp...20d:\"2017gml...tmp...20d\"\n         * ]\n         *\n         * It will then update the database, by setting a bibcode property on\n         * each record.  Also, if the record is not found here, it will be\n         * unset (-1) so that it won't be counted as an orcid record.\n         *\n         */\n\n\n        var querySuccess = function querySuccess(ids) {\n          // Update each orcid record with identifier info gained from ADS\n          _.each(db, function (v, key) {\n            var bibcode = ids[key]; // ADS did not find a record for this identifier\n\n            if (!bibcode) {\n              db[key].idx = -1;\n            } else {\n              db[key].bibcode = bibcode;\n            }\n          });\n\n          finishUpdate(db);\n        }; // on fail, alert the console and finish the update\n\n\n        var queryFailure = function queryFailure() {\n          console.error.apply(console, ['Error processing response from ADS'].concat(arguments));\n          finishUpdate(db);\n        };\n\n        $.when.apply($, whereClauses).then(querySuccess, queryFailure);\n      };\n\n      if (profile) {\n        update(profile);\n      } else {\n        // if we aren't passed a profile, get the current one\n        this.getUserProfile().done(update).fail(function () {\n          self.dbUpdatePromise.reject.apply(self.dbUpdatePromise, arguments);\n        });\n      }\n\n      return self.dbUpdatePromise.promise();\n    },\n\n    /**\n     * Creates a metadata object based on the work that is passed in that\n     * helps with understanding the record's relationship with ADS.  Figures\n     * out if the record is sourced by ADS, whether it is known, and whether\n     * ADS has the rights to update/delete it.\n     *\n     * @param {object} adsWork\n     */\n    getRecordInfo: function getRecordInfo(adsWork) {\n      var self = this;\n      var dd = $.Deferred();\n      /**\n       * Creates a metadata object based on the record data passed in.\n       *\n       * @returns {{\n       *  isCreatedByADS: boolean,\n       *  isCreatedByOthers: boolean,\n       *  isKnownToADS: boolean,\n       *  provenance: null\n       * }}\n       *\n       * @param {object} adsWork\n       */\n\n      var getRecordMetaData = function getInfo(adsWork) {\n        var out = {\n          isCreatedByADS: false,\n          isCreatedByOthers: false,\n          isKnownToADS: false,\n          provenance: null\n        };\n        /*\n        Looking to match the work record passed in to the entry in the db\n        Then we can add some metadata like whether it was an ADS sourced\n        record or not\n          */\n\n        var updateRecord = function updateRecord(v, k) {\n          // db is always 'identifier:xxx'\n          var key = ('identifier:' + v).toLowerCase();\n          var rec = self.db[key];\n\n          if (rec) {\n            if (rec.sourcedByADS) {\n              out.isCreatedByADS = true;\n            } else {\n              out.isCreatedByOthers = true;\n            }\n\n            if (rec.idx > -1) {\n              out.isKnownToADS = true;\n            }\n\n            out = _.extend({}, out, rec);\n          }\n        };\n\n        var ids = _.pick(adsWork, 'identifier', 'bibcode', 'doi', 'alternate_bibcode');\n\n        _.each(ids, function (value, key) {\n          if (_.isArray(value)) {\n            _.each(value, updateRecord);\n          } else {\n            updateRecord(value, key, out);\n          }\n        });\n\n        return out;\n      };\n\n      if (this.needsUpdate()) {\n        this.updateDatabase().done(function () {\n          dd.resolve(getRecordMetaData(adsWork));\n        }).fail(_.bind(dd.reject, dd));\n      } else {\n        dd.resolve(getRecordMetaData(adsWork));\n      }\n\n      return dd.promise();\n    },\n\n    /**\n     * Determines if the database needs to be updated.  It may, if there have\n     * been updates/deletes or if the internal timeout fired.\n     *\n     * @returns {boolean}\n     */\n    needsUpdate: function needsUpdate() {\n      return this.dirty;\n    },\n    setDirty: function setDirty() {\n      this.dirty = true;\n    },\n    setClean: function setClean() {\n      this.dirty = false;\n    },\n    hardenedInterface: {\n      hasAccess: 'boolean indicating access to ORCID Api',\n      getUserProfile: 'get user profile',\n      getUserBio: 'get user bio',\n      signIn: 'login',\n      signOut: 'logout',\n      getADSUserData: '',\n      setADSUserData: '',\n      getRecordInfo: 'provides info about a document',\n      addWork: 'add a new orcid work',\n      deleteWork: 'remove an entry from orcid',\n      updateWork: 'update an orcid work',\n      getWork: 'get an orcid work',\n      getWorks: 'get an array of orcid works'\n    }\n  });\n\n  _.extend(OrcidApi.prototype, Mixins.BeeHive);\n\n  _.extend(OrcidApi.prototype, HardenedMixin);\n\n  return OrcidApi;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/modules/orcid/orcid_api.js?");

/***/ }),

/***/ "./src/js/modules/orcid/profile.js":
/*!*****************************************!*\
  !*** ./src/js/modules/orcid/profile.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! jsonpath */ \"./src/libs/jsonpath.js\"), __webpack_require__(/*! js/modules/orcid/work */ \"./src/js/modules/orcid/work.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, jp, Work) {\n  var PATHS = {\n    workSummaries: '$'\n  };\n  /**\n   *\n   * @module Profile\n   * @param profile\n   * @constructor\n   */\n\n  var Profile = function Profile(profile) {\n    this._root = profile || {};\n    this.works = [];\n    /**\n     * search profile for value at specified path\n     *\n     * @param {String} path - path to search\n     * @returns {*} value found at path\n     */\n\n    this.get = function (path) {\n      var val = jp.query(this._root, path);\n\n      if (_.isEmpty(val)) {\n        return null;\n      }\n\n      if (_.isArray(val) && val.length <= 1) {\n        return val[0];\n      }\n\n      return val;\n    };\n    /**\n     * Gets all the work summaries from the profile\n     * Shallow (only grabs the first entry)\n     *\n     * @returns {Work[]} - the array of Work summaries\n     */\n\n\n    this.getWorks = function () {\n      return this.works;\n    };\n    /**\n     * Set the profile works\n     *\n     * @param {*} works\n     */\n\n\n    this.setWorks = function (works) {\n      this.works = works;\n      return this;\n    };\n    /**\n     * Convenience method for generating an ADS response object\n     * this can then be used to update the pagination of lists of orcid works\n     *\n     * @returns {{\n     *  responseHeader: {\n     *    params: {\n     *      orcid: String,\n     *      firstName: String,\n     *      lastName: String\n     *    }\n     *  },\n     *  response: {\n     *    numFound: Number,\n     *    start: Number,\n     *    docs: (Object[])\n     *  }\n     * }}\n     */\n\n\n    this.toADSFormat = function () {\n      var docs = _.sortBy(this.getWorks(), function (w) {\n        return w.getTitle();\n      });\n\n      docs = _.map(docs, function (d) {\n        return d.toADSFormat();\n      });\n      return {\n        responseHeader: {\n          params: {}\n        },\n        response: {\n          numFound: docs.length,\n          start: 0,\n          docs: docs\n        }\n      };\n    }; // generate getters for each path on PATHS\n\n\n    _.reduce(PATHS, function (obj, p, k) {\n      if (_.isString(k) && k.slice) {\n        var prop = k[0].toUpperCase() + k.slice(1);\n        obj['get' + prop] = _.partial(obj.get, p);\n      }\n\n      return obj;\n    }, this); // to maintain old behavior, make sure works is filled when the profile is created\n\n\n    this.works = _.map(this.getWorkSummaries(), function (w) {\n      return new Work(w);\n    });\n  };\n\n  return Profile;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/modules/orcid/profile.js?");

/***/ }),

/***/ "./src/js/modules/orcid/work.js":
/*!**************************************!*\
  !*** ./src/js/modules/orcid/work.js ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! jsonpath */ \"./src/libs/jsonpath.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, jp) {\n  var ADSPATHS = {\n    status: '$.status',\n    title: '$.title',\n    publicationDateMonth: '$.pubmonth',\n    publicationDateYear: '$.pubyear',\n    lastModifiedDate: '$.updated',\n    sourceName: '$.source',\n    putCode: '$.putcode',\n    identifier: '$.identifier'\n  };\n  var ORCIDPATHS = {\n    createdDate: '$[\"created-date\"].value',\n    lastModifiedDate: '$[\"last-modified-date\"].value',\n    sourceOrcidIdUri: '$.source[\"source-orcid\"].uri',\n    sourceOrcidIdPath: '$.source[\"source-orcid\"].path',\n    sourceOrcidIdHost: '$.source[\"source-orcid\"].host',\n    sourceClientIdUri: '$.source[\"source-client-id\"].uri',\n    sourceClientIdPath: '$.source[\"source-client-id\"].path',\n    sourceClientIdHost: '$.source[\"source-client-id\"].host',\n    sourceName: '$.source[\"source-name\"].value',\n    putCode: '$[\"put-code\"]',\n    path: '$.path',\n    title: '$[\"title\"].title.value',\n    subtitle: '$[\"title\"].subtitle.value',\n    translatedTitle: '$[\"title\"][\"translated-title\"].value',\n    translatedTitleLang: '$[\"title\"][\"translated-title\"][\"language-code\"]',\n    journalTitle: '$[\"journal-title\"].value',\n    shortDescription: '$[\"short-description\"]',\n    citationType: '$.citation[\"citation-type\"]',\n    citationValue: '$.citation[\"citation-value\"]',\n    type: '$.type',\n    publicationDateYear: '$[\"publication-date\"].year.value',\n    publicationDateMonth: '$[\"publication-date\"].month.value',\n    publicationDateDay: '$[\"publication-date\"].day.value',\n    publicationDateMedia: '$[\"publication-date\"][\"media-type\"]',\n    url: '$.url.value',\n    contributorOrcidUri: '$[\"contributors\"].contributor..[\"contributor-orcid\"].uri',\n    contributorOrcidPath: '$[\"contributors\"].contributor..[\"contributor-orcid\"].path',\n    contributorOrcidHost: '$[\"contributors\"].contributor..[\"contributor-orcid\"].host',\n    contributorName: '$[\"contributors\"].contributor..[\"credit-name\"].value',\n    contributorEmail: '$[\"contributors\"].contributor..[\"contributor-email\"].value',\n    contributorAttributes: '$[\"contributors\"].contributor..[\"contributor-attributes\"]',\n    contributorSequence: '$[\"contributors\"].contributor..[\"contributor-attributes\"][\"contributor-sequence\"]',\n    contributorRole: '$[\"contributors\"].contributor..[\"contributor-attributes\"][\"contributor-role\"]',\n    externalIdValue: '$[\"external-ids\"][\"external-id\"]..[\"external-id-value\"]',\n    externalIdType: '$[\"external-ids\"][\"external-id\"]..[\"external-id-type\"]',\n    externalIdUrl: '$[\"external-ids\"][\"external-id\"]..[\"external-id-url\"]',\n    externalIdRelationship: '$[\"external-ids\"][\"external-id\"]..[\"external-id-relationship\"]',\n    country: '$.country.value',\n    visibility: '$.visibility.value',\n    identifier: '$.identifier'\n  };\n  /**\n   * Convenience class that allows easy conversion between ADS and ORCiD works.\n   * @module Work\n   * @param work\n   * @param useOrcidPaths\n   * @constructor\n   */\n\n  var Work = function Work(work, useOrcidPaths) {\n    work = work || {};\n    this.useOrcidPaths = useOrcidPaths; // find the inner summary as the root\n\n    this._root = work;\n    this.sources = [];\n    /**\n     * get the sources array\n     * if the array is empty, it returns an array containing the single source name\n     *\n     * @returns {Array} - the sources\n     */\n\n    this.getSources = function () {\n      if (_.isEmpty(this.sources)) {\n        return [this.getSourceName()];\n      }\n\n      return this.sources;\n    };\n    /**\n     * Set the sources array\n     *\n     * @param {Array} sources\n     * @returns {Array} - the sources\n     */\n\n\n    this.setSources = function (sources) {\n      if (_.isArray(sources)) {\n        this.sources = sources;\n      }\n\n      return this.sources;\n    };\n    /**\n     * Get the value at path\n     *\n     * @param {string} path - path on _root element to find\n     * @returns {*} - value found at path\n     */\n\n\n    this.get = function (path) {\n      var val = jp.query(this._root, path);\n\n      if (_.isEmpty(val)) {\n        return null;\n      }\n\n      if (_.isArray(val) && val.length <= 1) {\n        return val[0];\n      }\n\n      return val;\n    };\n    /**\n     * Returns the generated ORCiD work from the current _root object.\n     * The object will be based on the paths in ADSPATHS\n     *\n     * @returns {*} - ORCiD formatted object\n     */\n\n\n    this.getAsOrcid = function () {\n      return _.reduce(ORCIDPATHS, _.bind(function (res, p) {\n        var val = this.get(p);\n\n        if (val) {\n          if (_.isArray(val)) {\n            _.forEach(val, function (v, i) {\n              jp.value(res, p.replace('..', '[' + i + ']'), v);\n            });\n          } else {\n            jp.value(res, p, val);\n          }\n        }\n\n        return res;\n      }, this), {});\n    };\n    /**\n     * Creates an ADS formatted object\n     *\n     * @returns {*} - ADS formatted object\n     */\n\n\n    this.toADSFormat = function () {\n      var ids;\n\n      if (this.useOrcidPaths) {\n        ids = this.getExternalIds();\n\n        if (ids.doi) {\n          ids.doi = [ids.doi];\n        }\n\n        ids.identifier = _.values(ids)[0];\n      }\n\n      return _.extend({}, {\n        title: [this.getTitle()],\n        formattedDate: this.getFormattedPubDate(),\n        source_name: this.getSources().join('; '),\n        identifier: this.getIdentifier(),\n        _work: this\n      }, ids);\n    };\n    /**\n     * Creates an object containing all external ids\n     * @example\n     * { bibcode: [\"2018CNSNS..56..270Q\"], doi: [...] }\n     *\n     * @returns {Object} - object containing external ids\n     */\n\n\n    this.getExternalIds = function () {\n      var types = this.getExternalIdType();\n      var values = this.getExternalIdValue();\n      types = _.isArray(types) ? types : [types];\n      values = _.isArray(values) ? values : [values];\n\n      if (types.length !== values.length) {\n        return {};\n      }\n\n      return _.reduce(types, function (res, t, i) {\n        res[t] = values[i];\n        return res;\n      }, {});\n    };\n    /**\n     * Format publication date\n     *\n     * @returns {string} - formatted pub date\n     */\n\n\n    this.getFormattedPubDate = function () {\n      var year = this.getPublicationDateYear() || '????';\n      var month = this.getPublicationDateMonth() || '??';\n      return year + '/' + month;\n    }; // get correct set of paths based on options\n\n\n    var paths = this.useOrcidPaths ? ORCIDPATHS : ADSPATHS; // create getters for each of the PATHS\n\n    _.reduce(paths, function (obj, p, k) {\n      if (_.isString(k) && k.slice) {\n        var prop = k[0].toUpperCase() + k.slice(1);\n        obj['get' + prop] = _.partial(obj.get, p);\n      }\n\n      return obj;\n    }, this);\n  };\n  /**\n   * Creates an ORCiD Work from an ADS record.\n   *\n   * @static\n   * @param {Object} adsWork - the ads record\n   * @param {Number} [putCode] putCode - putcode to apply to work\n   * @returns {Object} - the ORCiD work\n   */\n\n\n  Work.adsToOrcid = function (adsWork, putCode) {\n    var ads = {\n      pubdate: '$.pubdate',\n      abstract: '$.abstract',\n      bibcode: '$.bibcode',\n      pub: '$.pub',\n      doi: '$.doi[0]',\n      author: '$.author[*]',\n      title: '$.title[0]',\n      type: '$.doctype',\n      all_ids: '$.all_ids'\n    };\n\n    var put = function put(obj, p, val) {\n      if (val) {\n        if (_.isArray(val)) {\n          _.forEach(val, function (v, i) {\n            jp.value(obj, p.replace('..', '[' + i + ']'), v);\n          });\n        } else {\n          jp.value(obj, p, val);\n        }\n      }\n\n      return obj;\n    };\n\n    var get = function get(path) {\n      var val = jp.query(adsWork, path);\n\n      if (_.isEmpty(val)) {\n        return null;\n      }\n\n      if (_.isArray(val) && val.length <= 1) {\n        return val[0] || '';\n      }\n\n      return val || '';\n    };\n\n    var work = {};\n\n    var worktype = function worktype(adsType) {\n      var oType = {\n        article: 'JOURNAL_ARTICLE',\n        inproceedings: 'CONFERENCE_PAPER',\n        abstract: 'CONFERENCE_ABSTRACT',\n        eprint: 'WORKING_PAPER',\n        phdthesis: 'DISSERTATION',\n        techreport: 'RESEARCH_TECHNIQUE',\n        inbook: 'BOOK_CHAPTER',\n        circular: 'RESEARCH_TOOL',\n        misc: 'OTHER',\n        book: 'BOOK',\n        proceedings: 'BOOK',\n        bookreview: 'BOOK_REVIEW',\n        erratum: 'JOURNAL_ARTICLE',\n        proposal: 'OTHER',\n        newsletter: 'NEWSLETTER_ARTICLE',\n        catalog: 'DATA_SET',\n        intechreport: 'RESEARCH_TECHNIQUE',\n        mastersthesis: 'DISSERTATION',\n        obituary: 'OTHER',\n        pressrelease: 'OTHER',\n        software: 'RESEARCH_TECHNIQUE',\n        talk: 'LECTURE_SPEECH'\n      };\n      return oType[adsType] || 'JOURNAL_ARTICLE';\n    };\n\n    try {\n      var exIds = {\n        types: [],\n        values: [],\n        relationships: []\n      }; // handle doi or bibcode not existing\n\n      var bib = get(ads.bibcode);\n      var doi = get(ads.doi);\n\n      if (bib) {\n        exIds.types.push('bibcode');\n        exIds.values.push(bib);\n        exIds.relationships.push('SELF');\n      }\n\n      if (doi) {\n        exIds.types.push('doi');\n        exIds.values.push(doi);\n        exIds.relationships.push('SELF');\n      }\n\n      var all_ids = get(ads.all_ids);\n      var arxiv = false;\n\n      if (_.isArray(all_ids)) {\n        arxiv = all_ids.find(function (element) {\n          return element.toLowerCase().startsWith('arxiv');\n        });\n      }\n\n      if (arxiv) {\n        arxiv = arxiv.substr(6);\n        exIds.types.push('arxiv');\n        exIds.values.push(arxiv);\n        exIds.relationships.push('SELF');\n      }\n\n      put(work, ORCIDPATHS.publicationDateYear, get(ads.pubdate).split('-')[0]);\n\n      if (get(ads.pubdate).split('-')[1] === '00') {\n        put(work, ORCIDPATHS.publicationDateMonth, null);\n      } else {\n        put(work, ORCIDPATHS.publicationDateMonth, get(ads.pubdate).split('-')[1]);\n      }\n\n      put(work, ORCIDPATHS.shortDescription, get(ads.abstract).slice(0, 4997) + '...');\n      put(work, ORCIDPATHS.externalIdType, exIds.types);\n      put(work, ORCIDPATHS.externalIdValue, exIds.values);\n      put(work, ORCIDPATHS.externalIdRelationship, exIds.relationships);\n      put(work, ORCIDPATHS.journalTitle, get(ads.pub));\n      put(work, ORCIDPATHS.type, worktype(get(ads.type)));\n      var author = get(ads.author);\n      author = _.isArray(author) ? author : [author];\n      put(work, ORCIDPATHS.contributorName, author);\n\n      var roles = _.map(author, function () {\n        return 'AUTHOR';\n      });\n\n      put(work, ORCIDPATHS.contributorRole, roles);\n      put(work, ORCIDPATHS.title, get(ads.title));\n\n      if (putCode) {\n        put(work, ORCIDPATHS.putCode, putCode);\n      }\n    } catch (e) {\n      return null;\n    }\n\n    return work;\n  };\n\n  return Work;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/modules/orcid/work.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd define */
/******/ 	!function() {
/******/ 		__webpack_require__.amdD = function () {
/******/ 			throw new Error('define cannot be used indirect');
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/amd options */
/******/ 	!function() {
/******/ 		__webpack_require__.amdO = {};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	!function() {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = function(result, chunkIds, fn, priority) {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var chunkIds = deferred[i][0];
/******/ 				var fn = deferred[i][1];
/******/ 				var priority = deferred[i][2];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	!function() {
/******/ 		__webpack_require__.nmd = function(module) {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	!function() {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"Orcid": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = function(chunkId) { return installedChunks[chunkId] === 0; };
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = function(parentChunkLoadingFunction, data) {
/******/ 			var chunkIds = data[0];
/******/ 			var moreModules = data[1];
/******/ 			var runtime = data[2];
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some(function(id) { return installedChunks[id] !== 0; })) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkbumblebee"] = self["webpackChunkbumblebee"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	!function() {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["vendor"], function() { return __webpack_require__("./src/js/modules/orcid/module.js"); })
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;