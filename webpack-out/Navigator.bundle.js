/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/404.html":
/*!**********************!*\
  !*** ./src/404.html ***!
  \**********************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var Handlebars = __webpack_require__(/*! ../node_modules/handlebars/runtime.js */ \"./node_modules/handlebars/runtime.js\");\nfunction __default(obj) { return obj && (obj.__esModule ? obj[\"default\"] : obj); }\nmodule.exports = (Handlebars[\"default\"] || Handlebars).template({\"compiler\":[8,\">= 4.3.0\"],\"main\":function(container,depth0,helpers,partials,data) {\n    return \"<!DOCTYPE html>\\n<html>\\n<head>\\n  <link rel=\\\"preload\\\" href=\\\"./styles/css/styles.css\\\" as=\\\"style\\\"/>\\n  <link rel=\\\"stylesheet\\\" href=\\\"./styles/css/styles.css\\\"/>\\n  <link rel=\\\"preload\\\" href=\\\"./libs/require.js\\\" as=\\\"script\\\"/>\\n  <!-- favicon -->\\n  <link rel=\\\"apple-touch-icon\\\" sizes=\\\"180x180\\\" href=\\\"./styles/favicon/apple-touch-icon.png\\\"/>\\n  <link rel=\\\"icon\\\" type=\\\"image/png\\\" sizes=\\\"32x32\\\" href=\\\"./styles/favicon/favicon-32x32.png\\\"/>\\n  <link rel=\\\"icon\\\" type=\\\"image/png\\\" sizes=\\\"16x16\\\" href=\\\"./styles/favicon/favicon-16x16.png\\\"/>\\n  <link rel=\\\"manifest\\\" href=\\\"./styles/favicon/site.webmanifest\\\"/>\\n  <link rel=\\\"mask-icon\\\" href=\\\"./styles/favicon/safari-pinned-tab.svg\\\" color=\\\"#5bbad5\\\"/>\\n  <meta name=\\\"apple-mobile-web-app-title\\\" content=\\\"Astrophysics Data System\\\"/>\\n  <meta name=\\\"application-name\\\" content=\\\"Astrophysics Data System\\\"/>\\n  <meta name=\\\"msapplication-TileColor\\\" content=\\\"#ffc40d\\\"/>\\n  <meta name=\\\"theme-color\\\" content=\\\"#ffffff\\\"/>\\n  <!-- /favicon -->\\n  <script src=\\\"./libs/require.js\\\"></script>\\n  <!-- Google Tag Manager -->\\n  <script>(function (w, d, s, l, i) {\\n    w[l] = w[l] || [];\\n    w[l].push({\\n      'gtm.start':\\n        new Date().getTime(), event: 'gtm.js',\\n    });\\n    var f = d.getElementsByTagName(s)[0],\\n      j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : '';\\n    j.async = true;\\n    j.src =\\n      'https://www.googletagmanager.com/gtm.js?id=' + i + dl;\\n    f.parentNode.insertBefore(j, f);\\n  })(window, document, 'script', 'dataLayer', 'GTM-NT2453N');</script>\\n  <!-- End Google Tag Manager -->\\n  <script>\\n    require.config({\\n      paths: {\\n        underscore: [\\n          'https://unpkg.com/lodash@2.4.2/dist/lodash.compat.min',\\n          'libs/lodash',\\n        ],\\n        analytics: 'js/components/analytics',\\n        jquery: [\\n          'https://unpkg.com/jquery@2.2.4/dist/jquery.min',\\n          'libs/jquery',\\n        ],\\n      },\\n    });\\n    require(['analytics'], function (analytics) {\\n      analytics('send', 'virtual_page_view', '/404');\\n      analytics(\\n        'send',\\n        'event',\\n        'error',\\n        'automatic_redirection',\\n        '404.html',\\n      );\\n    });\\n  </script>\\n</head>\\n<body>\\n<div\\n  style=\\\"display: flex; flex-direction: column; min-height: screen; min-width: screen; justify-content: center; align-items: center;\\\"\\n>\\n  <h1>Bumblebee failed to load. Please try again.</h1>\\n\\n  <h2>\\n    <a href=\\\"javascript:history.back()\\\">Go Back</a>\\n  </h2>\\n</div>\\n</body>\\n</html>\\n\";\n},\"useData\":true});\n\n//# sourceURL=webpack://bumblebee/./src/404.html?");

/***/ }),

/***/ "./src/js/apps/discovery/navigator.js":
/*!********************************************!*\
  !*** ./src/js/apps/discovery/navigator.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n/**\n * The main 'navigation' endpoints (the part executed inside\n * the application) - this is a companion to the 'router'\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./src/libs/jquery.js\"), __webpack_require__(/*! backbone */ \"./src/libs/backbone.js\"), __webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! js/components/navigator */ \"./src/js/components/navigator.js\"), __webpack_require__(/*! js/components/api_feedback */ \"./src/js/components/api_feedback.js\"), __webpack_require__(/*! js/components/api_query_updater */ \"./src/js/components/api_query_updater.js\"), __webpack_require__(/*! js/components/json_response */ \"./src/js/components/json_response.js\"), __webpack_require__(/*! js/components/api_query */ \"./src/js/components/api_query.js\"), __webpack_require__(/*! js/components/api_request */ \"./src/js/components/api_request.js\"), __webpack_require__(/*! js/components/api_targets */ \"./src/js/components/api_targets.js\"), __webpack_require__(/*! hbs!404 */ \"./src/404.html\"), __webpack_require__(/*! hbs!js/apps/discovery/templates/orcid-modal-template */ \"./src/js/apps/discovery/templates/orcid-modal-template.html\"), __webpack_require__(/*! js/mixins/api_access */ \"./src/js/mixins/api_access.js\"), __webpack_require__(/*! react-redux */ \"./src/libs/react-redux.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($, Backbone, _, Navigator, ApiFeedback, ApiQueryUpdater, JsonResponse, ApiQuery, ApiRequest, ApiTargets, ErrorTemplate, OrcidModalTemplate, ApiAccessMixin, ReactRedux) {\n  var NavigatorService = Navigator.extend({\n    start: function start(app) {\n      /**\n       * These 'transitions' are what happens inside 'discovery' application\n       *\n       * As a convention, navigation events are all lowercase, and widgets/page managers\n       * are CamelCase (for example the table of contents menu on the left side of the\n       * abstract/detail page is triggering navigation events using just the name of\n       * the widget, e.g. ShowReferences - when References tab was selected)\n       *\n       */\n      var self = this;\n      var queryUpdater = new ApiQueryUpdater('navigator');\n\n      var publishFeedback = function publishFeedback(data) {\n        self.getPubSub().publish(self.getPubSub().FEEDBACK, new ApiFeedback(data));\n      }; // right now, user navbar widget depends on this to show the correct highlighted pill\n\n\n      var publishPageChange = function publishPageChange(pageName) {\n        self.getPubSub().publish(self.getPubSub().PAGE_CHANGE, pageName);\n      };\n\n      var searchPageAlwaysVisible = ['Results', 'MyAdsFreeform', 'QueryInfo', 'AffiliationFacet', 'AuthorFacet', 'DatabaseFacet', 'RefereedFacet', 'KeywordFacet', 'BibstemFacet', 'BibgroupFacet', 'DataFacet', 'ObjectFacet', 'NedObjectFacet', 'VizierFacet', 'GraphTabs', 'QueryDebugInfo', 'ExportDropdown', 'VisualizationDropdown', 'SearchWidget', 'Sort', 'BreadcrumbsWidget', 'PubtypeFacet', 'OrcidSelector'];\n      var detailsPageAlwaysVisible = ['TOCWidget', 'SearchWidget', 'ShowResources', 'ShowAssociated', 'ShowGraphicsSidebar', 'ShowLibraryAdd', 'MetaTagsWidget'];\n\n      function redirectIfNotSignedIn(next) {\n        var loggedIn = app.getBeeHive().getObject('User').isLoggedIn();\n\n        if (!loggedIn) {\n          // redirect to authentication page\n          app.getService('Navigator').navigate('authentication-page', {\n            subView: 'login',\n            redirect: true,\n            next: next\n          });\n          return true;\n        }\n\n        return false;\n      }\n\n      function makeProxyHandler(id) {\n        return function () {\n          var proxy = self.get(id);\n          var args = Array.prototype.slice.call(arguments, 1);\n          return proxy.execute.apply(proxy, [id].concat(args));\n        };\n      }\n\n      this.set('index-page', function (data) {\n        var that = this;\n        var defer = $.Deferred();\n        app.getObject('MasterPageManager').show('LandingPage', ['SearchWidget', 'RecommenderWidget']).then(function () {\n          return app.getWidget('LandingPage').then(function (widget) {\n            if (data && data.origin === 'SearchWidget') {\n              // we know it came from the searchWidget handler, so call it without extra params\n              widget.setActive('SearchWidget');\n            } else {\n              // only set the origin flag if we know it wasn't a redirect from the other handler (SearchWidget)\n              widget.setActive('SearchWidget', null, {\n                origin: 'index-page'\n              });\n            }\n\n            that.route = '';\n            that.title = '';\n            defer.resolve();\n          });\n        });\n        return defer.promise();\n      });\n      this.set('SearchWidget', function () {\n        // you must set a route within the function, even if you are calling\n        // another function that sets a route\n        var that = this;\n        var defer = $.Deferred();\n\n        var exec = _.bind(self.get('index-page').execute, this, {\n          origin: 'SearchWidget'\n        });\n\n        exec().then(function () {\n          that.route = '';\n          that.title = '';\n          defer.resolve();\n        });\n        return defer.promise();\n      });\n      this.set('404', /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_widget) {\n          var errorProps,\n              _args = arguments;\n          return regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  errorProps = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n                  _context.next = 3;\n                  return app.getObject('MasterPageManager');\n\n                case 3:\n                  void _context.sent.show('ErrorPage');\n                  _context.next = 6;\n                  return app.getWidget('ErrorPage');\n\n                case 6:\n                  _context.t0 = errorProps;\n                  void _context.sent.setMessage(_context.t0);\n\n                  /**\n                   * only replace if this 404 page was truly an internal re-route,\n                   * and not due to a broken link or some other routing issue\n                   */\n                  if (Object.keys(errorProps).length > 0) {\n                    this.replace = true;\n                  } // set url route\n\n\n                  this.route = '404';\n\n                case 10:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n      this.set('ClassicSearchForm', function (widgetName, _ref2) {\n        var query = _ref2.query;\n        var defer = $.Deferred();\n        var that = this;\n        app.getObject('MasterPageManager').show('LandingPage', [widgetName]).then(function () {\n          app.getWidget('LandingPage').done(function (widget) {\n            widget.setActive(widgetName);\n            widget.widgets[widgetName].applyQueryParams(query);\n          });\n          that.route = '#classic-form';\n          that.title = 'Classic Form';\n          defer.resolve();\n        });\n        return defer.promise();\n      });\n      this.set('PaperSearchForm', function () {\n        var defer = $.Deferred();\n        var that = this;\n        app.getObject('MasterPageManager').show('LandingPage', ['PaperSearchForm']).then(function () {\n          app.getWidget('LandingPage').done(function (widget) {\n            widget.setActive('PaperSearchForm');\n          });\n          that.route = '#paper-form';\n          that.title = 'Paper Form';\n          defer.resolve();\n        });\n        return defer.promise();\n      });\n      this.set('LibraryImport', function (page, data) {\n        var defer = $.Deferred();\n        var that = this;\n\n        if (redirectIfNotSignedIn(that.endpoint)) {\n          defer.resolve();\n          return defer.promise();\n        }\n\n        app.getObject('MasterPageManager').show('SettingsPage', ['LibraryImport', 'UserNavbarWidget']).then(function () {\n          app.getWidget('SettingsPage').done(function (widget) {\n            widget.setActive('LibraryImport');\n            that.route = '#user/settings/libraryimport';\n            that.title = 'Library Import';\n            publishPageChange('settings-page');\n            defer.resolve();\n          });\n        });\n        return defer.promise();\n      });\n\n      function settingsPreferencesView(widgetName, defaultView, title) {\n        return function (page, data) {\n          var defer = $.Deferred();\n          var that = this;\n\n          if (redirectIfNotSignedIn(that.endpoint)) {\n            defer.resolve();\n            return defer.promise();\n          }\n\n          var subView = data.subView || defaultView;\n\n          if (!subView) {\n            console.error('no subview or default view provided /' + 'to the navigator function!');\n          }\n\n          app.getObject('MasterPageManager').show('SettingsPage', [widgetName, 'UserNavbarWidget']).then(function () {\n            app.getWidget('SettingsPage').done(function (widget) {\n              widget.setActive(widgetName, subView);\n            });\n            that.route = '#user/settings/' + subView;\n            that.title = 'Settings' + (title ? ' | ' + title : '');\n            publishPageChange('settings-page');\n            defer.resolve();\n          });\n          return defer.promise();\n        };\n      } // request for the widget\n\n\n      this.set('UserSettings', settingsPreferencesView('UserSettings', undefined)); // request for the widget\n\n      this.set('UserPreferences', settingsPreferencesView('UserPreferences', 'application', 'Search Settings'));\n      this.set('MyAdsDashboard', function () {\n        var defer = $.Deferred();\n        var that = this;\n\n        if (redirectIfNotSignedIn(that.endpoint)) {\n          defer.resolve();\n          return defer.promise();\n        }\n\n        app.getObject('MasterPageManager').show('SettingsPage', ['MyAdsDashboard', 'UserNavbarWidget']).then(function () {\n          app.getWidget('SettingsPage').done(function (widget) {\n            widget.setActive('MyAdsDashboard');\n            that.route = '#user/settings/myads';\n            that.title = 'myADS Notifications';\n            publishPageChange('settings-page');\n            defer.resolve();\n          });\n        });\n        return defer.promise();\n      });\n      this.set('LibraryActionsWidget', function () {\n        var $dd = $.Deferred();\n        var that = this;\n\n        if (redirectIfNotSignedIn(that.endpoint)) {\n          return $dd.resolve().promise();\n        }\n\n        app.getObject('MasterPageManager').show('LibrariesPage', ['LibraryActionsWidget', 'UserNavbarWidget']).then(function () {\n          app.getWidget('LibraryActionsWidget').done(function (widget) {\n            widget.reset();\n            that.route = '#user/libraries/actions';\n            publishPageChange('libraries-page');\n            $dd.resolve();\n          });\n        });\n        return $dd.promise();\n      });\n      this.set('AllLibrariesWidget', function (widget, subView) {\n        var defer = $.Deferred();\n        var that = this;\n\n        if (redirectIfNotSignedIn(that.endpoint)) {\n          defer.resolve();\n          return defer.promise();\n        }\n\n        var subView = subView || 'libraries';\n        app.getObject('MasterPageManager').show('LibrariesPage', ['AllLibrariesWidget', 'UserNavbarWidget']).then(function () {\n          app.getWidget('AllLibrariesWidget').done(function (widget) {\n            widget.setSubView({\n              view: subView\n            });\n            widget.reset();\n            that.route = '#user/libraries/';\n            that.title = 'My Libraries';\n            publishPageChange('libraries-page');\n          });\n          defer.resolve();\n        });\n        return defer.promise();\n      });\n      this.set('LibraryAdminView', function (widget) {\n        var defer = $.Deferred();\n        var that = this; // this is NOT navigable from outside, so library already has data\n        // only setting a nav event to hide previous widgets\n\n        app.getObject('MasterPageManager').show('LibrariesPage', ['IndividualLibraryWidget', 'UserNavbarWidget']).then(function () {\n          app.getWidget('IndividualLibraryWidget').done(function (widget) {\n            widget.setSubView({\n              subView: 'admin'\n            });\n          });\n          publishPageChange('libraries-page');\n          defer.resolve();\n        });\n        return defer.promise();\n      });\n      this.set('IndividualLibraryWidget', function (widget, data) {\n        var defer = $.Deferred();\n        var that = this; // data in form of { subView: subView, id: id, publicView: false }\n\n        data.publicView = data.publicView ? data.publicView : false; // only check for logged in user if not public library\n\n        if (!data.publicView && redirectIfNotSignedIn(that.endpoint)) {\n          return defer.resolve().promise();\n        }\n\n        this.route = data.publicView ? '#public-libraries/' + data.id : '#user/libraries/' + data.id;\n        var pub = data.publicView;\n        app.getObject('MasterPageManager').show(pub ? 'PublicLibrariesPage' : 'LibrariesPage', pub ? ['IndividualLibraryWidget', 'LibraryListWidget'] : ['IndividualLibraryWidget', 'LibraryListWidget', 'UserNavbarWidget']).then(function () {\n          app.getObject('LibraryController').getLibraryMetadata(data.id, !data.publicView).done(function (metadata) {\n            data.editRecords = _.contains(['write', 'admin', 'owner'], metadata.permission) && !data.publicView;\n            that.title = data.publicView ? 'Public' : 'Private' + ' Library | ' + metadata.name;\n            app.getWidget('LibraryListWidget', 'IndividualLibraryWidget').then(function (w) {\n              w['LibraryListWidget'].setData(data);\n              w['IndividualLibraryWidget'].setSubView(data);\n\n              if (pub) {\n                publishPageChange('libraries-page');\n              }\n\n              defer.resolve();\n            });\n          });\n        });\n        return defer.promise();\n      }); // for external widgets shown by library\n\n      function navToLibrarySubView(widget, data) {\n        var defer = $.Deferred();\n        var that = this; // actual name of widget to be shown in main area\n\n        var widgetName = data.widgetName; // additional info that the renderWidgetForListOfBibcodes function might need (only used by export right now)\n\n        var additional = data.additional;\n        var format = additional.format || 'bibtex'; // tab description for library widget\n\n        var subView = data.subView; // id of library being shown\n\n        var id = data.id;\n        var publicView = data.publicView; // Author-affiliation has a specific widget\n\n        if (widgetName === 'ExportWidget' && format === 'authoraff') {\n          widgetName = 'AuthorAffiliationTool';\n        }\n\n        function renderLibrarySub(id) {\n          var defer = $.Deferred();\n          app.getObject('LibraryController').getLibraryBibcodes(id).done(function (bibcodes) {\n            // XXX - this was async in the original version; likely wrong\n            // one block should be main...\n            app.getWidget('LibraryListWidget').then(function (listWidget) {\n              var sort = listWidget.model.get('sort');\n              app.getWidget(widgetName).then(function (subWidget) {\n                additional = _.extend({}, additional, {\n                  sort: sort\n                });\n                subWidget.renderWidgetForListOfBibcodes(bibcodes, additional);\n                app.getWidget('IndividualLibraryWidget').then(function (indWidget) {\n                  indWidget.setSubView({\n                    subView: subView,\n                    publicView: publicView,\n                    id: id\n                  });\n                  defer.resolve();\n                });\n              });\n            });\n          });\n          return defer.promise();\n        } // clear current data\n\n\n        app.getWidget(widgetName).done(function (widget) {\n          if (widget.reset) widget.reset();else if (widget.resetWidget) widget.resetWidget();\n        }).done(function () {\n          // just stick the empty views in there, otherwise the interface lags as the lib controller\n          // paginates through the library bibcodes\n          if (!(widgetName === 'ExportWidget' && format === 'classic')) {\n            // export to classic opens a new tab, nothing to update here\n            if (publicView) {\n              app.getObject('MasterPageManager').show('PublicLibrariesPage', ['IndividualLibraryWidget', widgetName]).then(function () {\n                renderLibrarySub(id).done(function () {\n                  that.route = '#public-libraries/' + data.id; // XXX:rca - i think this should be that.route\n\n                  defer.resolve();\n                });\n              });\n            } else {\n              app.getObject('MasterPageManager').show('LibrariesPage', ['IndividualLibraryWidget', 'UserNavbarWidget', widgetName]).then(function () {\n                renderLibrarySub(id).done(function () {\n                  that.route = '#user/libraries/' + data.id;\n                  publishPageChange('libraries-page');\n                  defer.resolve();\n                });\n              });\n            }\n          } else {\n            defer.resolve();\n          }\n        });\n        return defer.promise();\n      } // end navToLibrarySubview\n\n\n      this.set('library-export', navToLibrarySubView);\n      this.set('library-visualization', navToLibrarySubView);\n      this.set('library-metrics', navToLibrarySubView);\n      this.set('library-citation_helper', navToLibrarySubView);\n      this.set('home-page', function () {\n        var defer = $.Deferred();\n        var that = this;\n\n        if (redirectIfNotSignedIn(that.endpoint)) {\n          return defer.resolve().promise();\n        }\n\n        app.getObject('MasterPageManager').show('HomePage', []).then(function () {\n          publishPageChange('home-page');\n          that.title = 'Home';\n          that.route = '#user/home';\n          defer.resolve();\n        });\n        return defer.promise();\n      });\n      this.set('authentication-page', function (page, data) {\n        var defer = $.Deferred();\n        var data = data || {},\n            subView = data.subView || 'login',\n            loggedIn = app.getBeeHive().getObject('User').isLoggedIn(),\n            that = this;\n\n        if (loggedIn) {\n          // redirect to index\n          self.get('index-page').execute().then(function () {\n            defer.resolve();\n          });\n        } else {\n          // redirect will be set if we are redirecting from an internal page\n          if (data.redirect) {\n            that.replace = true;\n          }\n\n          app.getObject('MasterPageManager').show('AuthenticationPage', ['Authentication']).then(function () {\n            app.getWidget('Authentication').done(function (w) {\n              if (data.next) {\n                w.setNextNavigation(data.next);\n              }\n\n              w.setSubView(subView);\n              that.route = '#user/account/' + subView;\n              that.title = subView === 'login' ? 'Sign In' : subView === 'reset-password-1' || subView === 'reset-password-2' ? 'Reset Password' : subView === 'resend-verification-email' ? 'Resend Verification Eamil' : 'Register';\n              defer.resolve();\n            });\n          });\n        }\n\n        return defer.promise();\n      });\n      this.set('results-page', function (widget, args) {\n        var that = this;\n        var defer = $.Deferred();\n        app.getObject('MasterPageManager').show('SearchPage', searchPageAlwaysVisible).done(function () {\n          // allowing widgets to override appstorage query (so far only used for orcid redirect)\n          // XXX:rca - not sure I understand why\n          var q = app.getObject('AppStorage').getCurrentQuery();\n\n          if (q && q.get('__original_url')) {\n            var route = '#search/' + q.get('__original_url');\n            q.unset('__original_url');\n          } else {\n            var route = '#search/' + queryUpdater.clean(q).url();\n          } // XXX:rca why here and not inside mediator???\n          // update the pagination of the results widget\n\n\n          if (q instanceof ApiQuery) {\n            var update = {};\n\n            var par = function par(str) {\n              if (_.isString(str)) {\n                try {\n                  return parseInt(str);\n                } catch (e) {// do nothing\n                }\n              }\n\n              return false;\n            };\n\n            if (q.has('p_')) {\n              var page = par(q.get('p_')[0]);\n              update.page = page;\n            } else {\n              route += '&p_=0';\n            }\n\n            if (!_.isEmpty(update)) {\n              app.getWidget('Results').then(function (w) {\n                if (_.isFunction(w.updatePagination)) {\n                  w.updatePagination(update);\n                }\n              });\n            }\n          } // taking care of inserting bigquery key here, not sure if right place\n          // clean(q) above got rid of qid key, reinsert it\n\n\n          if (q && q.get('__qid')) {\n            route += '&__qid=' + q.get('__qid')[0];\n          }\n\n          that.title = q && q.get('q').length && q.get('q')[0];\n          that.route = route;\n          publishFeedback({\n            code: ApiFeedback.CODES.UNMAKE_SPACE\n          });\n          defer.resolve();\n        });\n        return defer.promise();\n      });\n      this.set('export', function (nav, options) {\n        var defer = $.Deferred();\n        var format = options.format || 'bibtex';\n        var storage = app.getObject('AppStorage');\n        var that = this;\n        app.getObject('MasterPageManager').show('SearchPage', ['ExportWidget'].concat(searchPageAlwaysVisible.slice(1))).then(function () {\n          app.getWidget('ExportWidget').done(function (widget) {\n            that.route = \"#search/\".concat(storage.getCurrentQuery().url(), \"/export-\").concat(format);\n\n            if (format === 'authoraff') {\n              if (options.onlySelected && storage.hasSelectedPapers()) {\n                widget.getAuthorAffForm({\n                  bibcodes: storage.getSelectedPapers()\n                });\n              } else {\n                widget.getAuthorAffForm({\n                  currentQuery: storage.getCurrentQuery()\n                });\n              }\n\n              return;\n            } // first, open central panel\n\n\n            publishFeedback({\n              code: ApiFeedback.CODES.MAKE_SPACE\n            }); // is a special case, it opens in a new tab\n\n            if (options.onlySelected && storage.hasSelectedPapers()) {\n              widget.renderWidgetForListOfBibcodes(storage.getSelectedPapers(), {\n                format: format,\n                sort: storage.hasCurrentQuery() && storage.getCurrentQuery().get('sort')[0]\n              });\n            } // all records specifically requested\n            else if (options.onlySelected === false && storage.hasCurrentQuery()) {\n              widget.renderWidgetForCurrentQuery({\n                format: format,\n                currentQuery: storage.getCurrentQuery(),\n                numFound: storage.get('numFound')\n              });\n            } // no request for selected or not selected, show selected\n            else if (options.onlySelected === undefined && storage.hasSelectedPapers()) {\n              widget.renderWidgetForListOfBibcodes(storage.getSelectedPapers(), {\n                format: format\n              });\n            } // no selected, show all papers\n            else if (storage.hasCurrentQuery()) {\n              widget.exportQuery({\n                format: format,\n                currentQuery: storage.getCurrentQuery(),\n                numFound: storage.get('numFound')\n              });\n            } else {\n              var alerts = app.getController('AlertsController');\n              alerts.alert({\n                msg: 'There are no records to export yet (please search or select some)'\n              });\n              self.get('results-page')(); // XXX:rca - .execute?, also\n            }\n          }).done(function () {\n            defer.resolve(); // XXX:rca - may cause problem when 'results-page' gets called\n          });\n        });\n        return defer.promise();\n      });\n      this.set('export-query', function () {\n        var defer = $.Deferred();\n        var api = app.getService('Api');\n        var q = app.getObject('AppStorage').getCurrentQuery();\n        var alerter = app.getController('AlertsController'); // TODO: modify filters (move them to the main q)\n\n        q = new ApiQuery({\n          query: q.url()\n        }); // save the query / obtain query id\n\n        api.request(new ApiRequest({\n          query: q,\n          target: ApiTargets.MYADS_STORAGE + '/query',\n          options: {\n            done: function done() {},\n            type: 'POST',\n            xhrFields: {\n              withCredentials: false\n            }\n          }\n        })).done(function (data) {\n          alerter.alert(new ApiFeedback({\n            code: ApiFeedback.CODES.ALERT,\n            msg: 'The query has been saved. You can insert the following snippet in a webpage: <br/>' + '<img src=\"' + ApiTargets.MYADS_STORAGE + '/query2svg/' + data.qid + '\"></img><br/>' + '<br/><textarea rows=\"10\" cols=\"50\">' + '<a href=\"' + location.protocol + '//' + location.host + location.pathname + '#execute-query/' + data.qid + '\"><img src=\"' + ApiTargets.MYADS_STORAGE + '/query2svg/' + data.qid + '\"></img>' + '</a>' + '</textarea>',\n            modal: true\n          }));\n          defer.resolve();\n        });\n        return defer.promise();\n      });\n      this.set('search-page', function (endPoint, data) {\n        var isTugboat = false;\n\n        try {\n          isTugboat = document.referrer.indexOf('tugboat/adsabs') > -1;\n        } catch (e) {}\n\n        var defer = $.Deferred();\n        var possibleSearchSubPages = ['Metrics', 'AuthorNetwork', 'PaperNetwork', 'ConceptCloud', 'BubbleChart'];\n        var widgetName, pages; // convention is that a navigate command for search page widget starts with \"show-\"\n        // waits for the navigate to results page emitted by the discovery_mediator\n        // once the solr search has been received\n\n        if (data.page) {\n          widgetName = _.map(data.page.split('-').slice(1), function (w) {\n            return w[0].toUpperCase() + w.slice(1);\n          }).join('');\n        }\n\n        if (widgetName && possibleSearchSubPages.indexOf(widgetName) > -1) {\n          pages = [widgetName].concat(searchPageAlwaysVisible.slice(1));\n        } else {\n          pages = searchPageAlwaysVisible;\n        }\n\n        var that = this;\n        var ctx = data && data.context || {};\n        showResultsPage(pages, ctx).then(function () {\n          var handler = function handler() {\n            // the current query should have been updated, use that instead\n            var query = self.getBeeHive().getObject('AppStorage').getCurrentQuery();\n\n            if (!query) {\n              query = data.q;\n            }\n\n            var cleaned = queryUpdater.clean(query); // re-apply the qid if was lost\n\n            if (query.has('__qid')) {\n              cleaned.set('__qid', query.get('__qid'));\n            }\n\n            that.route = '#search/' + cleaned.url();\n\n            if (query.has('__bigquerySource')) {\n              that.title = query.get('__bigquerySource')[0];\n            } else {\n              that.title = query.get('q').length && query.get('q')[0];\n            }\n\n            if (isTugboat) {\n              that.route += '&__tb=1';\n            }\n\n            var q = query;\n\n            if (q instanceof ApiQuery) {\n              var update = {};\n\n              var par = function par(str) {\n                if (_.isString(str)) {\n                  try {\n                    return parseInt(str);\n                  } catch (e) {// do nothing\n                  }\n                }\n\n                return false;\n              };\n\n              if (q.has('p_')) {\n                var page = par(q.get('p_')[0]);\n                update.page = page;\n              } else {\n                that.route += '&p_=0';\n              }\n\n              if (!_.isEmpty(update)) {\n                app.getWidget('Results').then(function (w) {\n                  if (_.isFunction(w.updatePagination)) {\n                    w.updatePagination(update);\n                  }\n                });\n              }\n            } // check if there is a subpage, if so execute that handler w/ our current context\n\n\n            if (data.page && self.get(data.page)) {\n              var exec = _.bind(self.get(data.page).execute, that, data.page, {\n                q: query\n              });\n\n              exec(data.page).then(function () {\n                defer.resolve();\n              });\n            } else {\n              defer.resolve();\n            }\n          }; // subscribe to the search cycle finished event\n          // so that we know that the current query has been set\n\n\n          var onFeedback = function onFeedback(feedback) {\n            if (feedback && feedback.code === ApiFeedback.CODES.SEARCH_CYCLE_FINISHED) {\n              handler();\n              ps.unsubscribe(ps.FEEDBACK, onFeedback);\n            }\n          }; // make sure that we unfold sidebars\n\n\n          publishFeedback({\n            code: ApiFeedback.CODES.UNMAKE_SPACE\n          });\n          var ps = self.getPubSub();\n          ps.subscribe(ps.FEEDBACK, onFeedback);\n          ps.publish(ps.START_SEARCH, data.q);\n        });\n        return defer.promise();\n      });\n      this.set('execute-query', function (endPoint, queryId) {\n        var defer = $.Deferred();\n        var api = app.getService('Api');\n        api.request(new ApiRequest({\n          target: ApiTargets.MYADS_STORAGE + '/query/' + queryId,\n          options: {\n            done: function done(data) {\n              var q = new ApiQuery().load(JSON.parse(data.query).query);\n              self.getPubSub().publish(self.getPubSub().START_SEARCH, q);\n              defer.resolve();\n            },\n            fail: function fail() {\n              var alerter = app.getController('AlertsController');\n              alerter.alert(new ApiFeedback({\n                code: ApiFeedback.CODES.ERROR,\n                msg: 'The query with the given UUID cannot be found'\n              }));\n              self.get('index-page').execute().then(function () {\n                defer.resolve();\n              });\n            },\n            type: 'GET',\n            xhrFields: {\n              withCredentials: false\n            }\n          }\n        }));\n        return defer.promise();\n      });\n      this.set('user-action', function (endPoint, data) {\n        var failMessage = '',\n            failTitle = '',\n            route,\n            done,\n            defer = $.Deferred();\n        var token = data.token,\n            subView = data.subView;\n\n        function fail(jqXHR, status, errorThrown) {\n          self.get('index-page').execute().then(function () {\n            var error = jqXHR.responseJSON && jqXHR.responseJSON.error ? jqXHR.responseJSON.error : 'error unknown'; // call alerts widget\n\n            self.getPubSub().publish(self.getPubSub().ALERT, new ApiFeedback({\n              code: 0,\n              title: failTitle,\n              msg: ' <b>' + error + '</b> <br/>' + failMessage,\n              modal: true,\n              type: 'danger'\n            }));\n            defer.reject();\n          });\n        }\n\n        if (subView === 'register') {\n          failTitle = 'Registration failed.';\n          failMessage = '<p>Please try again, or contact <b> adshelp@cfa.harvard.edu for support </b></p>';\n          route = ApiTargets.VERIFY + '/' + token;\n\n          done = function done(reply) {\n            // user has been logged in already by server\n            // request bootstrap\n            self.getApiAccess({\n              reconnect: true\n            }).done(function () {\n              self.get('index-page').execute().then(function () {\n                var msg = '<p>You have been successfully registered with the email</p> <p><b>' + reply.email + '</b></p>';\n                self.getPubSub().publish(self.getPubSub().ALERT, new ApiFeedback({\n                  code: 0,\n                  title: 'Welcome to ADS',\n                  msg: msg,\n                  modal: true,\n                  type: 'success'\n                }));\n                defer.resolve();\n              });\n            }).fail(function () {\n              this.apply(fail, arguments); // XXX:rca - infinite loop?\n            });\n          };\n        } else if (subView === 'change-email') {\n          failTitle = 'Attempt to change email failed';\n          failMessage = 'Please try again, or contact adshelp@cfa.harvard.edu for support';\n          route = ApiTargets.VERIFY + '/' + token;\n\n          done = function done(reply) {\n            // user has been logged in already\n            // request bootstrap\n            self.getApiAccess({\n              reconnect: true\n            }).done(function () {\n              self.get('index-page').execute().then(function () {\n                var msg = 'Your new ADS email is <b>' + reply.email + '</b>';\n                self.getPubSub().publish(self.getPubSub().ALERT, new ApiFeedback({\n                  code: 0,\n                  title: 'Email has been changed.',\n                  msg: msg,\n                  modal: true,\n                  type: 'success'\n                }));\n                defer.resolve();\n              });\n            }).fail(function () {\n              this.apply(fail, arguments);\n            });\n          };\n        } else if (subView === 'reset-password') {\n          done = function done() {\n            // route to reset-password-2 form\n            // set the token so that session can use it in the put request with the new password\n            self.getBeeHive().getObject('Session').setChangeToken(token);\n            self.getPubSub().publish(self.getPubSub().NAVIGATE, 'authentication-page', {\n              subView: 'reset-password-2'\n            });\n            defer.resolve();\n          };\n\n          failTitle = 'Password reset failed';\n          failMessage = 'Reset password token was invalid.';\n          route = ApiTargets.RESET_PASSWORD + '/' + token;\n        } else {\n          defer.reject('Unknown subView: ' + subView);\n          return defer.promise();\n        }\n\n        var request = new ApiRequest({\n          target: route,\n          options: {\n            type: 'GET',\n            context: self,\n            done: done,\n            fail: fail\n          }\n        });\n        self.getBeeHive().getService('Api').request(request);\n        return defer.promise();\n      });\n      this.set('orcid-instructions', function () {\n        var that = this;\n        var defer = $.Deferred();\n        app.getObject('MasterPageManager').show('OrcidInstructionsPage').then(function () {\n          that.route = '#orcid-instructions';\n          that.title = 'Orcid Instructions';\n        });\n        return defer.promise();\n      });\n      this.set('orcid-page', function (view, targetRoute) {\n        var defer = $.Deferred();\n        var orcidApi = app.getService('OrcidApi');\n        var persistentStorage = app.getService('PersistentStorage');\n        var appStorage = app.getObject('AppStorage');\n        var user = app.getObject('User');\n        var that = this; // traffic from Orcid - user has authorized our access\n\n        if (!orcidApi.hasAccess() && orcidApi.hasExchangeCode()) {\n          // since app will exit, store the information that we're authenticating\n          if (persistentStorage) {\n            persistentStorage.set('orcidAuthenticating', true);\n          } else {\n            console.warn('no persistent storage service available');\n          }\n\n          orcidApi.getAccessData(orcidApi.getExchangeCode()).done(function (data) {\n            orcidApi.saveAccessData(data);\n            user.setOrcidMode(true);\n            self.getPubSub().publish(self.getPubSub().APP_EXIT, {\n              url: window.location.pathname + (targetRoute && _.isString(targetRoute) ? targetRoute : window.location.hash)\n            });\n          }).fail(function () {\n            user.setOrcidMode(false);\n            console.warn('Unsuccessful login to ORCID');\n            var alerter = app.getController('AlertsController');\n            alerter.alert(new ApiFeedback({\n              code: ApiFeedback.CODES.ALERT,\n              msg: 'Error getting OAuth code to access ORCID',\n              modal: true,\n              events: {\n                click: 'button[data-dismiss=modal]'\n              }\n            })).done(function () {\n              self.get('index-page').execute(); // after modal is closed\n            });\n          });\n          return;\n        } else if (orcidApi.hasAccess()) {\n          // XXX:rca = this block is async; showing modals even if the page under may be\n          // changing; likely not intended to be doing that but not sure...\n          if (persistentStorage.get('orcidAuthenticating')) {\n            persistentStorage.remove('orcidAuthenticating'); // check if we need to trigger modal alert to ask user to fill in necessary data\n            // we only want to show this immediately after user has authenticated with orcid\n\n            orcidApi.getADSUserData().done(function (data) {\n              // don't show modal if we're just going to redirect to the ads-orcid form anyway\n              if (!data.hasOwnProperty('authorizedUser') && JSON.stringify(appStorage.get('stashedNav')) !== '[\"UserPreferences\",{\"subView\":\"orcid\"}]') {\n                // the form has yet to be filled out by the user\n                // now tailor the message depending on whether they are signed in to ADS or not\n                var alerter = app.getController('AlertsController');\n                alerter.alert(new ApiFeedback({\n                  code: ApiFeedback.CODES.ALERT,\n                  msg: OrcidModalTemplate({\n                    adsLoggedIn: app.getObject('User').isLoggedIn()\n                  }),\n                  type: 'success',\n                  title: 'You are now logged in to ORCID',\n                  modal: true\n                }));\n              } // end check if user has already provided data\n\n            }).fail(function (error) {\n              console.warn(error);\n            });\n          }\n\n          app.getObject('MasterPageManager').show('OrcidPage', ['OrcidBigWidget', 'SearchWidget']).then(function () {\n            // go to the orcidbigwidget\n            that.route = '/user/orcid';\n            that.title = 'My Orcid';\n            defer.resolve();\n          });\n        } else {\n          // just redirect to index page, no orcid access\n          self.get('index-page').execute().then(function () {\n            that.route = '';\n            defer.resolve();\n          });\n        }\n\n        return defer.promise();\n      });\n      /*\n       * functions for showing \"explore\" widgets on results page\n       * */\n\n      function showResultsPageWidgetWithUniqueUrl(command, options) {\n        var defer = $.Deferred(),\n            that = this;\n        options = options || {};\n        var q = app.getObject('AppStorage').getCurrentQuery();\n\n        if (!q && options.q) {\n          q = options.q;\n        } else if (!q && !options.q) {\n          return defer.resolve().promise();\n        }\n\n        publishFeedback({\n          code: ApiFeedback.CODES.MAKE_SPACE\n        });\n\n        var widgetName = _.map(command.split('-').slice(1), function (w) {\n          return w[0].toUpperCase() + w.slice(1);\n        }).join('');\n\n        app.getObject('MasterPageManager').show('SearchPage', [widgetName].concat(searchPageAlwaysVisible.slice(1))).done(function () {\n          var route = '#search/' + queryUpdater.clean(q.clone()).url() + '/' + command.split('-').slice(1).join('-'); // show selected, need to explicitly tell widget to show bibcodes\n\n          if (options && options.onlySelected) {\n            app.getWidget(widgetName).done(function (w) {\n              var selected = app.getObject('AppStorage').getSelectedPapers();\n              w.renderWidgetForListOfBibcodes(selected);\n              that.route = route;\n              defer.resolve();\n            });\n          } else {\n            app.getWidget(widgetName).done(function (w) {\n              w.renderWidgetForCurrentQuery({\n                currentQuery: q\n              });\n              that.route = route;\n              defer.resolve();\n            });\n          }\n        });\n        return defer.promise();\n      }\n\n      this.set('show-author-network', function (command, options) {\n        return showResultsPageWidgetWithUniqueUrl.apply(this, arguments);\n      });\n      this.set('show-concept-cloud', function (command, options) {\n        return showResultsPageWidgetWithUniqueUrl.apply(this, arguments);\n      });\n      this.set('show-paper-network', function (command, options) {\n        return showResultsPageWidgetWithUniqueUrl.apply(this, arguments);\n      });\n      this.set('show-bubble-chart', function (command, options) {\n        return showResultsPageWidgetWithUniqueUrl.apply(this, arguments);\n      });\n      this.set('show-metrics', function (command, options) {\n        return showResultsPageWidgetWithUniqueUrl.apply(this, arguments);\n      });\n      this.set('visualization-closed', this.get('results-page'));\n\n      var showResultsPage = function showResultsPage(pages, ctx) {\n        return app.getObject('MasterPageManager').show('SearchPage', pages, ctx);\n      };\n      /*\n       * Below are functions for abstract pages\n       */\n\n\n      var showDetail = function showDetail(pages, toActivate) {\n        var defer = $.Deferred();\n        app.getObject('MasterPageManager').show('DetailsPage', pages).then(function () {\n          return app.getWidget('DetailsPage').then(function (w) {\n            defer.resolve(w);\n          });\n        });\n        return defer.promise();\n      };\n\n      this.set('verify-abstract', function () {\n        // XXX:rca - moved from router; not in a working state\n        // check we are using the canonical bibcode and redirect to it if necessary\n        var q,\n            req,\n            defer = $.Deferred,\n            that = this;\n        q = new ApiQuery({\n          q: 'identifier:' + this.queryUpdater.quoteIfNecessary(bibcode),\n          fl: 'bibcode'\n        });\n        req = new ApiRequest({\n          query: q,\n          target: ApiTargets.SEARCH,\n          options: {\n            done: function done(resp) {\n              var navigateString, href;\n\n              if (!subPage) {\n                navigateString = 'ShowAbstract';\n              } else {\n                navigateString = 'Show' + subPage[0].toUpperCase() + subPage.slice(1);\n                href = '#abs/' + bibcode + '/' + subPage;\n              } //self.routerNavigate(navigateString, { href: href });\n\n\n              if (resp.response && resp.response.docs && resp.response.docs[0]) {\n                bibcode = resp.response.docs[0].bibcode;\n                self.getPubSub().publish(self.getPubSub().DISPLAY_DOCUMENTS, new ApiQuery({\n                  q: 'bibcode:' + bibcode\n                }));\n              } else if (resp.response && resp.response.docs && !resp.response.docs.length) {\n                console.error('the query  ' + q.get('q')[0] + '  did not return any bibcodes');\n              }\n            },\n            fail: function fail() {\n              console.log('Cannot identify page to load, bibcode: ' + bibcode);\n              self.getPubSub().publish(this.getPubSub().NAVIGATE, 'index-page');\n            }\n          }\n        });\n        this.getPubSub().publish(this.getPubSub().EXECUTE_REQUEST, req);\n      }); // translate identifier to bibcode, this only sends a request if the identifier is NOT bibcode-like\n\n      var translateIdentifier = function translateIdentifier(id) {\n        var $dd = $.Deferred();\n        var ps = self.getPubSub(); // super naive bibcode confirmation\n\n        if (id.length === 19 && /^\\d{4}[A-z].*\\d[A-z]$/.test(id)) {\n          return $dd.resolve(id).promise();\n        }\n\n        var request = new ApiRequest({\n          target: ApiTargets.SEARCH,\n          query: new ApiQuery({\n            q: 'identifier:' + id,\n            fl: 'bibcode',\n            rows: 1\n          }),\n          options: {\n            done: function done(res) {\n              if (res && res.response && res.response.numFound > 0) {\n                $dd.resolve(res.response.docs[0].bibcode);\n              }\n\n              $dd.resolve('null');\n            },\n            fail: function fail() {\n              $dd.resolve('null');\n            }\n          }\n        });\n        ps.publish(ps.EXECUTE_REQUEST, request);\n        return $dd.promise();\n      };\n\n      var showDetailsSubPage = function showDetailsSubPage(_ref3) {\n        var id = _ref3.id,\n            bibcode = _ref3.bibcode,\n            page = _ref3.page,\n            prefix = _ref3.prefix,\n            subView = _ref3.subView;\n        var ps = self.getPubSub();\n        ps.publish(ps.DISPLAY_DOCUMENTS, new ApiQuery({\n          q: \"identifier:\".concat(bibcode)\n        }));\n        page.setActive(id, subView);\n\n        if (prefix) {\n          // we can grab the current title from storage and just add our prefix from there\n          var title = app.getObject('AppStorage').getDocumentTitle();\n\n          if (title && title.indexOf(prefix) === -1) {\n            this.title = prefix + ' | ' + title;\n          }\n        } else {\n          // get the title from the list of stashed docs, if available\n          var doc = _.find(self.getBeeHive().getObject('DocStashController').getDocs() || [], {\n            bibcode: bibcode\n          });\n\n          if (doc) {\n            this.title = doc.title && doc.title[0];\n          }\n        }\n      };\n\n      this.set('ShowAbstract', function (id, data) {\n        var _this = this;\n\n        var defer = $.Deferred();\n        showDetail([id].concat(detailsPageAlwaysVisible), id).then(function (page) {\n          if (!data.bibcode) {\n            return;\n          }\n\n          translateIdentifier(data.bibcode).then(function (bibcode) {\n            showDetailsSubPage.call(_this, {\n              id: id,\n              bibcode: bibcode,\n              page: page\n            });\n            _this.route = data.href;\n            _this.replace = true;\n            defer.resolve();\n          });\n        });\n        return defer.promise();\n      });\n      this.set('ShowCitations', function (id, data) {\n        var _this2 = this;\n\n        var defer = $.Deferred();\n        showDetail([id].concat(detailsPageAlwaysVisible), id).then(function (page) {\n          if (!data.bibcode) {\n            return;\n          }\n\n          translateIdentifier(data.bibcode).then(function (bibcode) {\n            showDetailsSubPage.call(_this2, {\n              id: id,\n              bibcode: bibcode,\n              page: page,\n              prefix: 'Citations'\n            });\n            _this2.route = data.href;\n            _this2.replace = true;\n            defer.resolve();\n          });\n        });\n        return defer.promise();\n      });\n      this.set('ShowReferences', function (id, data) {\n        var _this3 = this;\n\n        var defer = $.Deferred();\n        showDetail([id].concat(detailsPageAlwaysVisible), id).then(function (page) {\n          if (!data.bibcode) {\n            return;\n          }\n\n          translateIdentifier(data.bibcode).then(function (bibcode) {\n            showDetailsSubPage.call(_this3, {\n              id: id,\n              bibcode: bibcode,\n              page: page,\n              prefix: 'References'\n            });\n            _this3.route = data.href;\n            _this3.replace = true;\n            defer.resolve();\n          });\n        });\n        return defer.promise();\n      });\n      this.set('ShowCoreads', function (id, data) {\n        var _this4 = this;\n\n        var defer = $.Deferred();\n        showDetail([id].concat(detailsPageAlwaysVisible), id).then(function (page) {\n          if (!data.bibcode) {\n            return;\n          }\n\n          translateIdentifier(data.bibcode).then(function (bibcode) {\n            showDetailsSubPage.call(_this4, {\n              id: id,\n              bibcode: bibcode,\n              page: page,\n              prefix: 'Co-Reads'\n            });\n            _this4.route = data.href;\n            _this4.replace = true;\n            defer.resolve();\n          });\n        });\n        return defer.promise();\n      });\n      this.set('ShowSimilar', function (id, data) {\n        var _this5 = this;\n\n        var defer = $.Deferred();\n        showDetail([id].concat(detailsPageAlwaysVisible), id).then(function (page) {\n          if (!data.bibcode) {\n            return;\n          }\n\n          translateIdentifier(data.bibcode).then(function (bibcode) {\n            showDetailsSubPage.call(_this5, {\n              id: id,\n              bibcode: bibcode,\n              page: page,\n              prefix: 'Similar Papers'\n            });\n            _this5.route = data.href;\n            _this5.replace = true;\n            defer.resolve();\n          });\n        });\n        return defer.promise();\n      });\n      this.set('ShowToc', function (id, data) {\n        var _this6 = this;\n\n        var defer = $.Deferred();\n        showDetail([id].concat(detailsPageAlwaysVisible), id).then(function (page) {\n          if (!data.bibcode) {\n            return;\n          }\n\n          translateIdentifier(data.bibcode).then(function (bibcode) {\n            showDetailsSubPage.call(_this6, {\n              id: id,\n              bibcode: bibcode,\n              page: page,\n              prefix: 'Volume Content'\n            });\n            _this6.route = data.href;\n            _this6.replace = true;\n            defer.resolve();\n          });\n        });\n        return defer.promise();\n      });\n      this.set('ShowMetrics', function (id, data) {\n        var _this7 = this;\n\n        var defer = $.Deferred();\n        showDetail([id].concat(detailsPageAlwaysVisible), id).then(function (page) {\n          if (!data.bibcode) {\n            return;\n          }\n\n          translateIdentifier(data.bibcode).then(function (bibcode) {\n            showDetailsSubPage.call(_this7, {\n              id: id,\n              bibcode: bibcode,\n              page: page,\n              prefix: 'Metrics'\n            });\n            _this7.route = data.href;\n            _this7.replace = true;\n            defer.resolve();\n          });\n        });\n        return defer.promise();\n      });\n      this.set('ShowExportcitation', function (id, data) {\n        var _this8 = this;\n\n        var defer = $.Deferred(); // the default subView should be `default`\n\n        var format = data.subView || 'default';\n        app.getObject('MasterPageManager').show('DetailsPage', [id].concat(detailsPageAlwaysVisible)).done(function () {\n          app.getWidget('DetailsPage').done(function (page) {\n            if (!data.bibcode) {\n              return;\n            }\n\n            translateIdentifier(data.bibcode).then(function (bibcode) {\n              self.getPubSub().publish(self.getPubSub().DISPLAY_DOCUMENTS, new ApiQuery({\n                q: 'identifier:' + bibcode\n              }));\n\n              if (bibcode === 'null') {\n                return page.setActive(null);\n              } // guarantees the bibcode is set on the widget\n\n\n              page.widgets[id].ingestBroadcastedPayload(bibcode);\n              page.setActive(id, format);\n              _this8.route = data.href;\n              _this8.replace = true;\n              defer.resolve();\n            });\n          });\n        });\n        return defer.promise();\n      });\n      this.set('ShowGraphics', function (id, data) {\n        var _this9 = this;\n\n        var defer = $.Deferred();\n        showDetail([id].concat(detailsPageAlwaysVisible), id).then(function (page) {\n          if (!data.bibcode) {\n            return;\n          }\n\n          translateIdentifier(data.bibcode).then(function (bibcode) {\n            showDetailsSubPage.call(_this9, {\n              bibcode: bibcode,\n              page: page,\n              id: id,\n              prefix: 'Graphics'\n            });\n            _this9.route = data.href;\n            _this9.replace = true;\n            defer.resolve();\n          });\n        });\n        return defer.promise();\n      });\n      this.set('show-author-affiliation-tool', function (id, options) {\n        var defer = $.Deferred(),\n            that = this;\n        var q = app.getObject('AppStorage').getCurrentQuery();\n        app.getObject('MasterPageManager').show('SearchPage', ['AuthorAffiliationTool'].concat(searchPageAlwaysVisible.slice(1))).done(function () {\n          publishFeedback({\n            code: ApiFeedback.CODES.MAKE_SPACE\n          });\n          app.getWidget('AuthorAffiliationTool').done(function (w) {\n            if (options && options.onlySelected) {\n              var selected = app.getObject('AppStorage').getSelectedPapers();\n              w.renderWidgetForListOfBibcodes(selected);\n            } else {\n              w.renderWidgetForCurrentQuery({\n                currentQuery: q\n              });\n            }\n\n            that.route = '#search/' + queryUpdater.clean(q).url();\n            defer.resolve();\n          });\n        });\n        return defer.promise();\n      }); // ---- react components ----\n\n      var createReactPage = /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(id) {\n          var pm, widget;\n          return regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  _context2.next = 2;\n                  return app._getWidget('ReactPageManager');\n\n                case 2:\n                  pm = _context2.sent;\n                  _context2.next = 5;\n                  return app._getWidget(id);\n\n                case 5:\n                  widget = _context2.sent;\n                  pm.widgets[id] = widget.render();\n                  pm.view = pm.createView({\n                    widgets: _defineProperty({}, id, pm.widgets[id])\n                  });\n                  _context2.next = 10;\n                  return app.getObject('MasterPageManager').show('ReactPageManager', [id]);\n\n                case 10:\n                  return _context2.abrupt(\"return\", widget);\n\n                case 11:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        }));\n\n        return function createReactPage(_x2) {\n          return _ref4.apply(this, arguments);\n        };\n      }();\n\n      this.set('ShowFeedback', /*#__PURE__*/function () {\n        var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(id, _ref5) {\n          var subview, bibcode, widget, form;\n          return regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  subview = _ref5.subview, bibcode = _ref5.bibcode;\n                  _context3.next = 3;\n                  return createReactPage('ShowFeedback');\n\n                case 3:\n                  widget = _context3.sent;\n                  ReactRedux.batch(function () {\n                    widget.dispatch({\n                      type: 'SET_FORM',\n                      payload: subview\n                    });\n                    widget.dispatch({\n                      type: 'SET_BIBCODE',\n                      payload: bibcode\n                    });\n                  });\n                  form = widget.getState().main.form;\n                  publishPageChange(\"feedback-\".concat(form));\n                  this.title = 'Feedback';\n\n                case 8:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3, this);\n        }));\n\n        return function (_x3, _x4) {\n          return _ref6.apply(this, arguments);\n        };\n      }());\n    }\n  });\n\n  _.extend(NavigatorService.prototype, ApiAccessMixin);\n\n  return NavigatorService;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/apps/discovery/navigator.js?");

/***/ }),

/***/ "./src/js/apps/discovery/templates/orcid-modal-template.html":
/*!*******************************************************************!*\
  !*** ./src/js/apps/discovery/templates/orcid-modal-template.html ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var Handlebars = __webpack_require__(/*! ../../../../../node_modules/handlebars/runtime.js */ \"./node_modules/handlebars/runtime.js\");\nfunction __default(obj) { return obj && (obj.__esModule ? obj[\"default\"] : obj); }\nmodule.exports = (Handlebars[\"default\"] || Handlebars).template({\"1\":function(container,depth0,helpers,partials,data) {\n    return \"\\n    <p>\\n        If you <strong>wish for your ORCID claims to be accessible in the ADS,</strong> please first\\n        <a href=\\\"#user/settings/orcid\\\">fill out this brief form. </a>\\n    </p>\\n\\n    <p>\\n        After you have completed the form, you can immediately begin claiming papers.\\n    </p>\\n\\n\\n\";\n},\"3\":function(container,depth0,helpers,partials,data) {\n    return \"\\n    <p>\\n        If you <strong>want your ORCID claims to be accessible in the ADS,</strong>\\n        please sign in to ADS or create an account and provide us with your permission to\\n        make your claims public, along with a few other key pieces of information.\\n\\n    </p>\\n    <p>\\n        <a href=\\\"#user/account/login\\\" class=\\\"btn btn-primary\\\">log in to ADS </a>\\n        or\\n        <a href=\\\"#user/account/register\\\" class=\\\"btn btn-primary\\\">create a new account</a>\\n\\n    </p>\\n    <p>\\n        After you are signed in to your account, go to the \\\"User Preferences\\\" page,\\n        click on the \\\"ORCID Settings\\\" tab, and fill in the brief form.\\n    </p>\\n\\n\\n\";\n},\"compiler\":[8,\">= 4.3.0\"],\"main\":function(container,depth0,helpers,partials,data) {\n    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n          return parent[propertyName];\n        }\n        return undefined\n    };\n\n  return \"\\n\\n\"\n    + ((stack1 = lookupProperty(helpers,\"if\").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,\"adsLoggedIn\") : depth0),{\"name\":\"if\",\"hash\":{},\"fn\":container.program(1, data, 0),\"inverse\":container.program(3, data, 0),\"data\":data,\"loc\":{\"start\":{\"line\":3,\"column\":0},\"end\":{\"line\":35,\"column\":7}}})) != null ? stack1 : \"\")\n    + \"\\n<p>\\n    <b>If you don't care about your information being searchable in the ADS, just close this message and continue.</b>\\n</p>\";\n},\"useData\":true});\n\n//# sourceURL=webpack://bumblebee/./src/js/apps/discovery/templates/orcid-modal-template.html?");

/***/ }),

/***/ "./src/js/components/analytics.js":
/*!****************************************!*\
  !*** ./src/js/components/analytics.js ***!
  \****************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n  /*\n   * Set of targets\n   * each has a set of hooks which coorespond to the event label passed\n   * types represents the possible event targets which can be used\n   * url is a template which will be passed the incoming data\n   */\n  var TARGETS = {\n    resolver: {\n      hooks: ['toc-link-followed', 'abstract-link-followed', 'citations-link-followed', 'associated-link-followed'],\n      types: ['abstract', 'citations', 'references', 'metrics', 'coreads', 'similar', 'graphics', 'associated', 'toc'],\n      url: function url(_ref) {\n        var bibcode = _ref.bibcode,\n            target = _ref.target;\n        return \"link_gateway/\".concat(bibcode, \"/\").concat(target);\n      }\n    }\n  };\n  /**\n   * fire off the xhr request to the url\n   *\n   * @param {string} url\n   * @param {object} data\n   */\n\n  var sendEvent = function sendEvent(url) {\n    window.fetch(url, {\n      method: 'GET'\n    }).catch(function (error) {\n      window.getSentry().captureMessage('Failed to send analytics event', {\n        extra: {\n          url: url,\n          error: error.message\n        }\n      });\n    });\n  };\n\n  var isValidEvent = function isValidEvent(_ref2) {\n    var label = _ref2.label,\n        target = _ref2.target;\n\n    if (typeof label !== 'string' || typeof target !== 'string') {\n      return false;\n    }\n\n    return TARGETS.resolver.hooks.includes(label) && TARGETS.resolver.types.includes(target);\n  };\n  /**\n   * Go through the targets and fire the event if the label passed\n   * matches one of the hooks specified.  Also the data.target must match one\n   * of the types listed on the target config\n   *\n   * @param {string} label - the event label\n   * @param {object} data - the event data\n   */\n\n\n  var adsLogger = function adsLogger(label, data) {\n    var target = data ? data.target : null;\n    var bibcode = data ? data.bibcode : null;\n\n    if (bibcode !== null && isValidEvent({\n      label: label,\n      target: target\n    })) {\n      sendEvent(data.url ? data.url : TARGETS.resolver.url({\n        bibcode: bibcode,\n        target: target\n      }));\n    }\n  };\n\n  var buffer = [];\n  var gaName = window.GoogleAnalyticsObject || 'ga';\n\n  var cleanBuffer = function cleanBuffer() {\n    if (window[gaName]) {\n      for (var i = 0; i < buffer.length; i++) {\n        window[gaName].apply(this, buffer[i]);\n      }\n\n      buffer = [];\n    }\n  };\n\n  var CACHE_TIMEOUT = 300;\n  /**\n   * Simple debouncing mechanism with caching\n   * this will store stringified version of the incoming events and provide a way to\n   * check if the event has recently been cached.  With a short rolling timer to keep the timeout short to hopefully\n   * only target duplicate calls.\n   */\n\n  var AnalyticsCacher = /*#__PURE__*/function () {\n    function AnalyticsCacher() {\n      _classCallCheck(this, AnalyticsCacher);\n\n      this.timer = null;\n      this.cache = new Set();\n    }\n\n    _createClass(AnalyticsCacher, [{\n      key: \"stringify\",\n      value: function stringify(args) {\n        return JSON.stringify(args, function (key, value) {\n          // filter out this cache-buster id added by GTM\n          if (key === 'gtm.uniqueEventId') {\n            return undefined;\n          }\n\n          return value;\n        });\n      }\n    }, {\n      key: \"add\",\n      value: function add() {\n        this._resetTimeout();\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        return this.cache.add(this.stringify(args));\n      }\n    }, {\n      key: \"has\",\n      value: function has() {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        return this.cache.has(this.stringify(args));\n      }\n    }, {\n      key: \"_resetTimeout\",\n      value: function _resetTimeout() {\n        clearTimeout(this.timer);\n        this.timer = setTimeout(this._clear.bind(this), CACHE_TIMEOUT);\n      }\n    }, {\n      key: \"_clear\",\n      value: function _clear() {\n        this.cache.clear();\n      }\n    }]);\n\n    return AnalyticsCacher;\n  }();\n\n  var cacher = new AnalyticsCacher();\n\n  var Analytics = function Analytics(action, event, type, description) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 4 ? _len3 - 4 : 0), _key3 = 4; _key3 < _len3; _key3++) {\n      args[_key3 - 4] = arguments[_key3];\n    }\n\n    if (cacher.has(arguments)) {\n      return;\n    }\n\n    cacher.add(arguments);\n    adsLogger.apply(null, Array.prototype.slice.call(arguments, 3)); // if the action is send and the event is event, then we want to send the event to the dataLayer\n\n    if (Array.isArray(window.dataLayer) && action === 'send' && event === 'event') {\n      // some events are 'interaction' or 'error', so add that to the event name\n      window.dataLayer.push({\n        event: \"\".concat(type, \"_\").concat(description),\n        // if the next argument is an object, we'll use that as the data, ignore an extra arguments\n        value1: args[0],\n        value2: args[1],\n        value3: args[2]\n      });\n    } else if (Array.isArray(window.dataLayer) && action === 'send') {\n      window.dataLayer.push({\n        event: event,\n        value1: type,\n        value2: description,\n        value3: args[0]\n      });\n    } else if (Array.isArray(window.dataLayer) && action === 'set') {\n      window.dataLayer.push({\n        event: 'config',\n        value1: event,\n        value2: type,\n        value3: description\n      });\n    }\n  };\n  /**\n   * Get the datalayer for sending events to\n   * @returns {*|*[]}\n   */\n\n\n  Analytics.getDL = function () {\n    if (window.dataLayer && Array.isArray(window.dataLayer)) {\n      return window.dataLayer;\n    }\n\n    return [];\n  };\n  /**\n   * Push a new object to the datalayer\n   * @param {Object} data\n   */\n\n\n  Analytics.push = function (data) {\n    if (cacher.has(data)) {\n      return;\n    }\n\n    cacher.add(data);\n    Analytics.getDL().push(data);\n  };\n  /**\n   * Reset the datalayer\n   */\n\n\n  Analytics.reset = function () {\n    Analytics.getDL().push(function () {\n      this.reset();\n    });\n  };\n  /**\n   * set a value on the datalayer\n   * @param {string} property\n   * @param {unknown} value\n   */\n\n\n  Analytics.set = function (property, value) {\n    Analytics.getDL().push(function () {\n      this.set(property, value);\n    });\n  };\n  /**\n   * get a value on the datalayer\n   * @param {string} property\n   */\n\n\n  Analytics.get = function (property) {\n    var value;\n    Analytics.getDL().push(function () {\n      value = this.get(property);\n    });\n    return value;\n  };\n\n  return Analytics;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/analytics.js?");

/***/ }),

/***/ "./src/js/components/api_feedback.js":
/*!*******************************************!*\
  !*** ./src/js/components/api_feedback.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! backbone */ \"./src/libs/backbone.js\"), __webpack_require__(/*! js/mixins/hardened */ \"./src/js/mixins/hardened.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, Backbone, Hardened) {\n  var ApiFeedback = function ApiFeedback(options) {\n    _.extend(this, _.defaults(options || {}, {\n      code: 200,\n      msg: undefined\n    }));\n\n    this.setCode(this.code);\n  };\n\n  ApiFeedback.CODES = {\n    INVALID_PASSWORD: 498,\n    ACCOUNT_NOT_FOUND: 495,\n    // Account not found during signin\n    ALREADY_LOGGED_IN: 493,\n    // Already signed during signup\n    REQUIRES_LOGIN: 491,\n    TOO_MANY_CHARACTERS: 486,\n    BAD_REQUEST: 400,\n    UNAUTHORIZED: 401,\n    NOT_FOUND: 404,\n    INTERNAL_SERVER_ERROR: 500,\n    BAD_GATEWAY: 502,\n    SERVER_ERROR: 503,\n    TOO_MANY_FAILURES: 580,\n    ALL_FINE: 200,\n    KEEP_WAITING: 190,\n    TESTING: 0,\n    // Internal events\n    MAKE_SPACE: -1,\n    UNMAKE_SPACE: -1.1,\n    SEARCH_CYCLE_STARTED: -2,\n    SEARCH_CYCLE_FAILED_TO_START: -3,\n    SEARCH_CYCLE_PROGRESS: -4,\n    SEARCH_CYCLE_STOP_MONITORING: -5,\n    SEARCH_CYCLE_FINISHED: -6,\n    QUERY_ASSISTANT: -7,\n    ALERT: -8,\n    CANNOT_ROUTE: -9,\n    API_REQUEST_ERROR: -10,\n    BIBCODE_DATA_REQUESTED: -11\n  };\n  var _codes = {};\n\n  _.each(_.pairs(ApiFeedback.CODES), function (p) {\n    _codes[p[1]] = p[0];\n  });\n\n  _.extend(ApiFeedback.prototype, {\n    hardenedInterface: {\n      code: 'integer value of the code',\n      msg: 'string message',\n      toJSON: 'for cloning',\n      getApiRequest: 'to get the original request',\n      getSenderKey: 'retrieve the senders key'\n    },\n    initialize: function initialize() {},\n    toJSON: function toJSON() {\n      return {\n        code: this.code,\n        msg: this.msg\n      };\n    },\n    setCode: function setCode(c) {\n      if (!_codes[c]) {\n        throw new Error('This code is not in the list ApiCodes - please extend js/components/api_feedback first:', this.code);\n      }\n\n      this.code = c;\n    },\n    setApiRequest: function setApiRequest(apiRequest) {\n      this.req = apiRequest;\n    },\n    getApiRequest: function getApiRequest() {\n      return this.req;\n    },\n    setMsg: function setMsg(msg) {\n      this.msg = msg;\n    },\n    getSenderKey: function getSenderKey() {\n      return this.senderKey;\n    },\n    setSenderKey: function setSenderKey(key) {\n      this.senderKey = key;\n    }\n  }, Hardened);\n\n  ApiFeedback.extend = Backbone.Model.extend;\n  return ApiFeedback;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/api_feedback.js?");

/***/ }),

/***/ "./src/js/components/api_query.js":
/*!****************************************!*\
  !*** ./src/js/components/api_query.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n A facade: api query exposing only the set of functions that we allow. This is\n the module that you want to load in the application (do not load the concrete\n implementaions, such as solr_params !)\n\n Put in your config:\n map: {\n 'your/module': {\n 'api_query_impl': 'js/components/specific_impl_of_the_api_query'\n }\n },\n\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! backbone */ \"./src/libs/backbone.js\"), __webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! js/components/solr_params */ \"./src/js/components/solr_params.js\"), __webpack_require__(/*! js/components/facade */ \"./src/js/components/facade.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Backbone, _, ApiQueryImplementation, Facade) {\n  var hardenedInterface = {\n    add: 'add values',\n    set: 'set (replace existing)',\n    get: 'get values',\n    has: 'has a key',\n    hasVal: 'more specific `has` using _.isEmpty',\n    url: 'url string of the params',\n    load: 'loads query as a string',\n    clear: 'clears all values',\n    unset: 'removes a key',\n    toJSON: 'values back as JSON object',\n    clone: 'make a copy',\n    isLocked: true,\n    lock: true,\n    unlock: true,\n    pairs: 'get all values as pairs',\n    keys: 'as keys',\n    values: 'only values',\n    hasChanged: 'whether this object has modification (since its creation)',\n    previousAttributes: 'get all changed attributes',\n    previous: 'previous values for a given attribute'\n  };\n\n  var ApiQuery = function ApiQuery(data, options) {\n    // Facade pattern, we want to expose only limited API\n    // despite the fact that the underlying instance has\n    // all power of the Backbone.Model\n    if (data instanceof ApiQueryImplementation) {\n      this.innerQuery = new Facade(hardenedInterface, data);\n    } else {\n      this.innerQuery = new Facade(hardenedInterface, new ApiQueryImplementation(data, options));\n    }\n  };\n\n  var toInsert = {};\n\n  _.each(_.keys(hardenedInterface), function (element, index, list) {\n    toInsert[element] = function () {\n      return this.innerQuery[element].apply(this.innerQuery, arguments);\n    };\n  });\n\n  _.extend(ApiQuery.prototype, toInsert, {\n    clone: function clone() {\n      var clone = this.innerQuery.clone.apply(this.innerQuery, arguments);\n      return new ApiQuery(clone);\n    },\n    load: function load() {\n      var clone = this.innerQuery.load.apply(this.innerQuery, arguments);\n      return new ApiQuery(clone);\n    }\n  });\n\n  return ApiQuery;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/api_query.js?");

/***/ }),

/***/ "./src/js/components/api_query_updater.js":
/*!************************************************!*\
  !*** ./src/js/components/api_query_updater.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Created by rchyla on 5/24/14.\n *\n * Set of utilities for manipulating ApiQuery object. These are mainly\n * useful for widgets that often do the same operations with the\n * query.\n *\n * The object must be initialized with an 'identifier' -- this identifier\n * will represent a context; so we'll be touching all elements that\n * belong to the context\n *\n * TODO: need to distinguish globalOperator from 'operator' inside clauses\n * TODO: the 'globalOperator' joins clauses; 'operator' joins elements of the\n * TODO: clauses\n *\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! js/components/api_query */ \"./src/js/components/api_query.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, ApiQuery) {\n  var ApiQueryUpdater = function ApiQueryUpdater(contextIdentifier, options) {\n    if (!contextIdentifier || !_.isString(contextIdentifier)) {\n      throw new Error('You must initialize the ApiQueryUpdater with a context (which is a string)');\n    }\n\n    this.context = contextIdentifier;\n    this.defaultOperator = ' ';\n    this.operators = [' ', 'AND', 'OR', 'NOT', 'NEAR'];\n    this.defaultMode = 'limit';\n    this.operationModes = ['limit', 'exclude', 'expand', 'replace', 'remove'];\n    this.impossibleString = \"\\uFFFC\\uFFFC\\uFFFC\";\n\n    _.extend(this, options);\n  };\n\n  _.extend(ApiQueryUpdater.prototype, {\n    /**\n     * Modifies the query - it will search for a string inside the query (using previously\n     * saved state) and update the query 'parameter'\n     *\n     * @param field\n     *      this is the name of the parameter we are changing inside apiQeury\n     * @param apiQuery\n     *      the apiQuery object we are updating\n     * @param queryCondition\n     *      String|[String] - new conditions to set\n     * @param operator\n     *      String: this will serve as concatenator for the conditions\n     */\n    updateQuery: function updateQuery(apiQuery, field, mode, queryCondition, options) {\n      options = _.defaults({}, options, {\n        prefix: '__'\n      });\n\n      if (!field || !_.isString(field)) {\n        throw new Error('You must tell us what parameter to update in the ApiQuery');\n      } // globalOperator = this._sanitizeOperator(globalOperator);\n      // local name\n\n\n      var n = this._n(field, options.prefix); // create copy of the field\n\n\n      var q = _.clone(apiQuery.get(field));\n\n      var oldConditionAsString;\n      var newConditionAsString;\n      var newConditions;\n      var existingConditions; // first check if we have any existing conditions\n\n      existingConditions = this._getExistingVals(apiQuery, n);\n      queryCondition = this._sanitizeConditionAsArray(queryCondition);\n      mode = this._sanitizeMode(mode);\n      var operator;\n\n      if (mode == 'limit') {\n        operator = 'AND';\n      } else if (mode == 'exclude') {\n        operator = 'NOT';\n      } else if (mode == 'expand') {\n        operator = 'OR';\n      } else if (mode == 'replace') {\n        this._closeExistingVals(apiQuery, this._n(field, options.prefix));\n\n        apiQuery.set(this._n(field, options.prefix), ['AND', queryCondition[0]]);\n        return apiQuery.set(field, queryCondition[0]);\n      } else if (mode == 'remove') {\n        operator = existingConditions[0];\n      } else {\n        throw new Error('Unsupported mode/operator:', mode);\n      }\n\n      if (!apiQuery.has(field)) {\n        var conditions = [operator].concat(queryCondition);\n        apiQuery.set(field, this._buildQueryFromConditions(conditions));\n        apiQuery.set(this._n(field, options.prefix), conditions);\n        return;\n      }\n\n      if (existingConditions) {\n        // if the operators differ, it means we cannot safely update the query\n        // we must treat it as a new query\n        if (existingConditions[0] !== operator) {\n          this._closeExistingVals(apiQuery, n);\n\n          return this.updateQuery(apiQuery, field, mode, queryCondition);\n        }\n\n        oldConditionAsString = this._buildQueryFromConditions(existingConditions);\n      } else {\n        existingConditions = [operator]; // first value is always operator\n\n        if (q.length == 1) {\n          // we got a string, but that string could be a whole phrase\n          if (q[0].indexOf(' ') == -1) {\n            // simple string\n            oldConditionAsString = q[0];\n            existingConditions.push(q[0]);\n          } else {\n            oldConditionAsString = q[0];\n            var sillyTest = q[0].toLowerCase();\n\n            if (sillyTest.indexOf(' and ') > -1 || sillyTest.indexOf(' or ') > -1 || sillyTest.indexOf(' not ') > -1 || sillyTest.indexOf(' near') > -1 || sillyTest.indexOf('(') > 2) {\n              existingConditions.push('(' + q[0] + ')'); // enclose the expression in brackets, just to be safe\n            } else {\n              existingConditions.push(q[0]);\n            }\n          }\n        } else {\n          oldConditionAsString = this.impossibleString;\n        }\n      } // 'limit' means that the broader query will become 'narrower'\n      // by gaining more AND'ed 'conditions'\n      // 'expand' means that the query is becoming broader by gaining\n      // more conditions (these are OR'ed)\n\n\n      if (mode == 'limit' || mode == 'expand') {\n        // join the old and the new conditoins (remove the duplicates)\n        // we are basically trying to update the existing query\n        // by adding more conditions into the same clause\n        newConditions = _.union(existingConditions, queryCondition);\n        newConditionAsString = this._buildQueryFromConditions(newConditions);\n\n        var testq = _.clone(q); // try to find the pre-condition and replace it with a new value\n\n\n        if (this._modifyArrayReplaceString(testq, oldConditionAsString, newConditionAsString)) {\n          apiQuery.set(field, testq); // success\n          // save the values inside the query (so that we can use them if we are called next time)\n\n          apiQuery.set(n, newConditions);\n          return;\n        }\n      } // 'exclude' means that we are ADDING more conditions to the query; the query\n      // was broader; not it will explicitly 'exclude' some documents; again - there\n      // can also be 'exclude' conditions; so if possible, we'll enlarge their number\n\n\n      if (mode == 'exclude') {\n        var modifiedExisting = _.clone(existingConditions);\n\n        modifiedExisting[0] = 'OR';\n        oldConditionAsString = ' NOT ' + this._buildQueryFromConditions(modifiedExisting);\n        newConditions = _.union(existingConditions, queryCondition);\n\n        var modifiedConditions = _.clone(newConditions);\n\n        modifiedConditions[0] = 'OR';\n        newConditionAsString = ' NOT ' + this._buildQueryFromConditions(modifiedConditions);\n\n        var testq = _.clone(q); // try to find the pre-condition and replace it with a new value\n\n\n        if (this._modifyArrayReplaceString(testq, oldConditionAsString, newConditionAsString)) {\n          apiQuery.set(field, testq); // success\n          // save the values inside the query (so that we can use them if we are called next time)\n\n          apiQuery.set(n, newConditions);\n          return;\n        }\n      } else if (mode == 'remove') {\n        newConditions = _.difference(existingConditions, queryCondition);\n        newConditionAsString = this._buildQueryFromConditions(newConditions); // we'll be deleting\n\n        var testq = _.clone(q); // try to find the pre-condition and replace it with a new value\n\n\n        if (this._modifyArrayReplaceString(testq, oldConditionAsString, newConditionAsString)) {\n          apiQuery.set(field, testq); // success\n          // save the values inside the query (so that we can use them if we are called next time)\n\n          apiQuery.set(n, newConditions);\n          return;\n        }\n      } // we didn't find an old query that could be updated, so this means that we have\n      // to add a new logical condition to the existing query string.\n\n\n      if (mode == 'limit') {\n        newConditions = this._modifyArrayAddString(q, queryCondition, 'AND');\n      } else if (mode == 'exclude') {\n        newConditions = this._modifyArrayAddString(q, queryCondition, 'NOT');\n      } else if (mode == 'expand') {\n        newConditions = this._modifyArrayAddString(q, queryCondition, 'OR');\n      }\n\n      apiQuery.set(n, newConditions);\n      apiQuery.set(field, q);\n    },\n\n    /**\n     * Tells whether the string needs escaping (it ignores empty space)\n     *\n     * @param value\n     */\n    needsEscape: function needsEscape(s) {\n      var sb = [];\n      var c;\n\n      for (var i = 0; i < s.length; i++) {\n        c = s[i]; // These characters are part of the query syntax and must be escaped\n\n        if (c == '\\\\' || c == '+' || c == '-' || c == '!' || c == '(' || c == ')' || c == ':' || c == '^' || c == '[' || c == ']' || c == '\"' || c == '{' || c == '}' || c == '~' || c == '*' || c == '?' || c == '|' || c == '&' || c == '/') {\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n    /**\n     * Escapes special characters (but not whitespace)\n     *\n     * @param value\n     */\n    escape: function escape(s) {\n      var sb = [];\n      var c;\n\n      for (var i = 0; i < s.length; i++) {\n        c = s[i]; // These characters are part of the query syntax and must be escaped\n\n        if (c == '\\\\' || c == '+' || c == '-' || c == '!' || c == '(' || c == ')' || c == ':' || c == '^' || c == '[' || c == ']' || c == '\"' || c == '{' || c == '}' || c == '~' || c == '*' || c == '?' || c == '|' || c == '&' || c == '/') {\n          sb.push('\\\\');\n        }\n\n        sb.push(c);\n      }\n\n      return sb.join('');\n    },\n    escapeInclWhitespace: function escapeInclWhitespace(s) {\n      var sb = [];\n      var c;\n\n      for (var i = 0; i < s.length; i++) {\n        c = s[i]; // These characters are part of the query syntax and must be escaped\n\n        if (c == '\\\\' || c == '+' || c == '-' || c == '!' || c == '(' || c == ')' || c == ':' || c == '^' || c == '[' || c == ']' || c == '\"' || c == '{' || c == '}' || c == '~' || c == '*' || c == '?' || c == '|' || c == '&' || c == '/' || c == ' ' || c == '\\t') {\n          sb.push('\\\\');\n        }\n\n        sb.push(c);\n      }\n\n      return sb.join('');\n    },\n\n    /**\n     * Wraps string between quotes - and escapes any quotes if present\n     * @param s\n     * @returns {string}\n     */\n    quoteIfNecessary: function quoteIfNecessary(s, quoteChar, quoteCharEnd) {\n      return this.quote(s, quoteChar, quoteCharEnd, true);\n    },\n\n    /**\n     * Wraps string between quotes - and escapes any quotes if present\n     * @param s\n     * @returns {string}\n     */\n    quote: function quote(s, quoteChar, quoteCharEnd, onlyIfNecessary) {\n      if (!quoteChar) quoteChar = '\"';\n      if (!quoteCharEnd) quoteCharEnd = quoteChar;\n      if (_.isUndefined(onlyIfNecessary)) onlyIfNecessary = false;\n      var sb = [];\n      var c;\n      var needsQuotes = false;\n\n      for (var i = 0; i < s.length; i++) {\n        c = s[i];\n\n        if (c == '\\\\' || c == '+' || c == '-' || c == '!' || c == '(' || c == ')' || c == ':' || c == '^' || c == '[' || c == ']' || c == '\"' || c == '{' || c == '}' || c == '~' || // || c == '*' || c == '?'\n        c == '|' || c == '&' || c == '/' || c == ' ' || c == '\\t') {\n          needsQuotes = true;\n        }\n\n        if ((c == quoteChar || c == quoteCharEnd) && (i == 0 || i > 0 && s[i - 1] !== '\\\\')) {\n          sb.push('\\\\');\n        }\n\n        sb.push(c);\n      } // detect presence of quotes in the original string\n\n\n      if (onlyIfNecessary == true && sb[0] == '\\\\' && sb[1] == '\"' && sb[sb.length - 2] == '\\\\' && sb[sb.length - 1] == '\"') {\n        sb[0] = '';\n        sb[sb.length - 2] = '';\n        return sb.join('');\n      }\n\n      if (needsQuotes || onlyIfNecessary == false) {\n        return quoteChar + sb.join('') + quoteCharEnd;\n      }\n\n      return sb.join('');\n    },\n\n    /**\n     * Attaches to the ApiQuery object a storage of tmp values; these are\n     * not affecting anything inside the query; but the query is carrying them\n     * around as long as it was not cloned() etc\n     *\n     * @param key\n     * @param value\n     */\n    saveTmpEntry: function saveTmpEntry(apiQuery, key, value) {\n      var storage = this._getTmpStorage(apiQuery, true);\n\n      var oldVal;\n\n      if (key in storage) {\n        oldVal = storage[key];\n      }\n\n      storage[key] = value;\n      return oldVal;\n    },\n    removeTmpEntry: function removeTmpEntry(apiQuery, key) {\n      var storage = this._getTmpStorage(apiQuery, true);\n\n      var val = storage[key];\n      delete storage[key];\n      return val;\n    },\n    getTmpEntry: function getTmpEntry(apiQuery, key, defaultValue) {\n      var storage;\n\n      if (defaultValue) {\n        storage = this._getTmpStorage(apiQuery, true);\n      } else {\n        storage = this._getTmpStorage(apiQuery, false);\n      }\n\n      if (key in storage) {\n        return storage[key];\n      }\n\n      storage[key] = defaultValue;\n      return defaultValue;\n    },\n    hasTmpEntry: function hasTmpEntry(apiQuery, key) {\n      var storage = this._getTmpStorage(apiQuery);\n\n      return key in storage;\n    },\n    _getTmpStorage: function _getTmpStorage(apiQuery, createIfNotExists) {\n      var n = this._n('__tmpStorage');\n\n      if (!apiQuery.hasOwnProperty(n)) {\n        if (!createIfNotExists) return {};\n        apiQuery[n] = {};\n      }\n\n      return apiQuery[n];\n    },\n    _n: function _n(name, prefix) {\n      return (_.isString(prefix) ? prefix : '__') + this.context + '_' + name;\n    },\n    _buildQueryFromConditions: function _buildQueryFromConditions(conditions) {\n      if (conditions.length <= 1) {\n        throw new Error('Violation of contract: first condition is always an operator');\n      }\n\n      var op = conditions[0];\n\n      if (op != ' ') {\n        op = ' ' + op + ' ';\n      }\n\n      return '(' + conditions.slice(1).join(op) + ')';\n    },\n\n    /**\n     * Searches for values inside the array and replaces sections\n     * Returns number of modifications made\n     *\n     * @param arr\n     * @param search\n     * @param replace\n     * @param maxNumMod\n     *    maximum number of modifications to make; you can choose to\n     *    replace only the first value found\n     * @returns {integer}\n     * @private\n     */\n    _modifyArrayReplaceString: function _modifyArrayReplaceString(arr, search, replace, maxNumMod) {\n      var numMod = 0;\n      if (!maxNumMod) maxNumMod = -1;\n\n      if (!search) {\n        throw new Error('Your search is empty, you fool');\n      }\n\n      var modified = false;\n\n      _.each(arr, function (text, i) {\n        if (maxNumMod > 0 && numMod > maxNumMod) {\n          return;\n        }\n\n        if (text.indexOf(search) > -1) {\n          arr[i] = text.replace(search, replace);\n          numMod += 1;\n        }\n      });\n\n      return numMod;\n    },\n\n    /**\n     * Adds the new value into the array\n     * @param arr\n     * @param conditions\n     * @private\n     */\n    _modifyArrayAddString: function _modifyArrayAddString(arr, conditions, operator) {\n      // will always add to the latest string\n      if ((arr.length == 0 || arr[arr.length - 1].trim() == '') && (operator == 'NOT' || operator == 'NEAR')) {\n        throw new Error('Invalid operation; cannot apply NOT/NEAR on single clause');\n      }\n\n      var newQ = arr[arr.length - 1];\n      var newConditions = [operator, newQ].concat(conditions);\n      arr[arr.length - 1] = this._buildQueryFromConditions(newConditions);\n      return newConditions;\n    },\n\n    /**\n     * Gets the valus of the condition\n     * @param apiQuery\n     * @param key\n     *    the conditon 'name', typically st like __condition_author_q; it differs based on the\n     *    operation (type of update/widget/filter etc)\n     * @param defaults\n     *    what to return if 'key' is not present\n     * @returns {*}\n     * @private\n     */\n    _getExistingVals: function _getExistingVals(apiQuery, key, defaults) {\n      if (apiQuery.has(key)) {\n        return apiQuery.get(key);\n      }\n\n      return defaults;\n    },\n\n    /**\n     * When we have conditions for the previous context; but their operator is\n     * different, it means that the new conditions represent a new clause. So\n     * we need to do something with the old conditions (we could stack them\n     * but for now, the simple/robust solution is to simply remove them ->\n     * this means they will not be available for updates/manipulation -->\n     * theh query will be extended)\n     *\n     * @param condName\n     * @private\n     */\n    _closeExistingVals: function _closeExistingVals(apiQuery, condName) {\n      apiQuery.unset(condName);\n    },\n    _sanitizeMode: function _sanitizeMode(mode) {\n      if (!mode) {\n        return this.defaultMode;\n      }\n\n      var i = _.indexOf(this.operationModes, mode);\n\n      if (i == -1) {\n        throw new Error('Unkwnown mode: ' + mode);\n      }\n\n      return this.operationModes[i];\n    },\n    _sanitizeOperator: function _sanitizeOperator(operator) {\n      if (!operator) {\n        return this.defaultOperator;\n      }\n\n      if (_.isString(operator)) {\n        if (operator.trim() == '') {\n          return this.defaultOperator;\n        }\n      } else {\n        throw new Error('Operator must be a string');\n      }\n\n      operator = operator.toUpperCase();\n\n      var i = _.indexOf(this.operators, operator);\n\n      if (i == -1) {\n        throw new Error('Unknown operator: ', operator);\n      }\n\n      return this.operators[i];\n    },\n    _sanitizeConditionAsArray: function _sanitizeConditionAsArray(condition) {\n      if (!condition) {\n        throw new Error('The condition must be set (string/array of strings)');\n      }\n\n      if (_.isString(condition)) {\n        return [condition];\n      }\n\n      condition = _.without(_.flatten(condition), '', false, null, undefined, NaN);\n\n      if (condition.length == 0) {\n        throw new Error('After removing empty values, no condition was left');\n      }\n\n      return condition;\n    },\n\n    /**\n     * Cleans up the *clone* of the apiQuery by removing all the entries\n     * that are inserted into ApiQuery by the query updater.\n     *\n     * @param apiQuery\n     */\n    clean: function clean(apiQuery) {\n      var q = {};\n\n      if (apiQuery && apiQuery.keys) {\n        _.each(apiQuery.keys(), function (key) {\n          if (!(key.substring(0, 2) == '__')) {\n            q[key] = apiQuery.get(key);\n          }\n        });\n      }\n\n      return new ApiQuery(q);\n    }\n  });\n\n  return ApiQueryUpdater;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/api_query_updater.js?");

/***/ }),

/***/ "./src/js/components/api_request.js":
/*!******************************************!*\
  !*** ./src/js/components/api_request.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Created by rchyla on 3/28/14.\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! backbone */ \"./src/libs/backbone.js\"), __webpack_require__(/*! js/components/facade */ \"./src/js/components/facade.js\"), __webpack_require__(/*! js/components/default_request */ \"./src/js/components/default_request.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, Backbone, Facade, ApiRequestImpl) {\n  var hardenedInterface = {\n    // add makes no sense with request\n    get: 'get a key',\n    set: 'set (replace existing)',\n    url: 'url string defining this request',\n    has: 'has a key',\n    load: 'loads request as a string',\n    clear: 'clears all values',\n    unset: 'removes a key',\n    toJSON: 'values back as JSON object',\n    clone: 'make a copy',\n    isLocked: true,\n    lock: true,\n    unlock: true,\n    pairs: 'get all values as pairs',\n    keys: 'as keys',\n    values: 'only values',\n    hasChanged: 'whether this object has modification (since its creation)',\n    previousAttributes: 'get all changed attributes',\n    previous: 'previous values for a given attribute'\n  };\n\n  var ApiRequest = function ApiRequest(data, options) {\n    // Facade pattern, we want to expose only limited API\n    // despite the fact that the underlying instance has\n    // all power of the Backbone.Model\n    if (data instanceof ApiRequestImpl) {\n      this.innerRequest = new Facade(hardenedInterface, data);\n    } else {\n      this.innerRequest = new Facade(hardenedInterface, new ApiRequestImpl(data, options));\n    }\n  };\n\n  var toInsert = {};\n\n  _.each(_.keys(hardenedInterface), function (element, index, list) {\n    toInsert[element] = function () {\n      return this.innerRequest[element].apply(this.innerRequest, arguments);\n    };\n  });\n\n  _.extend(ApiRequest.prototype, toInsert, {\n    clone: function clone() {\n      var clone = this.innerRequest.clone.apply(this.innerRequest, arguments);\n      return new ApiRequest(clone);\n    },\n    load: function load() {\n      var clone = this.innerRequest.load.apply(this.innerRequest, arguments);\n      return new ApiRequest(clone);\n    }\n  });\n\n  return ApiRequest;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/api_request.js?");

/***/ }),

/***/ "./src/js/components/api_targets.js":
/*!******************************************!*\
  !*** ./src/js/components/api_targets.js ***!
  \******************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Created by rchyla on 1/20/15\n *\n * contains api targets\n * and any related limits\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n  var config = {\n    BOOTSTRAP: '/accounts/bootstrap',\n    SEARCH: 'search/query',\n    QTREE: 'search/qtree',\n    BIGQUERY: 'search/bigquery',\n    EXPORT: 'export/',\n    SERVICE_AUTHOR_NETWORK: 'vis/author-network',\n    SERVICE_PAPER_NETWORK: 'vis/paper-network',\n    SERVICE_WORDCLOUD: 'vis/word-cloud',\n    SERVICE_METRICS: 'metrics',\n    SERVICE_OBJECTS: 'objects',\n    SERVICE_OBJECTS_QUERY: 'objects/query',\n    SERVICE_CITATION_HELPER: 'citation_helper',\n    SERVICE_AUTHOR_AFFILIATION_EXPORT: 'authoraff',\n    MYADS_STORAGE: 'vault',\n    MYADS_NOTIFICATIONS: 'vault/_notifications',\n    AUTHOR_AFFILIATION_SEARCH: 'author-affiliation/search',\n    AUTHOR_AFFILIATION_EXPORT: 'author-affiliation/export',\n    RESOLVER: 'resolver',\n    CSRF: 'accounts/csrf',\n    USER: 'accounts/user',\n    USER_DATA: 'vault/user-data',\n    SITE_CONFIGURATION: 'vault/configuration',\n    TOKEN: 'accounts/user/token',\n    LOGIN: 'accounts/user/login',\n    LOGOUT: 'accounts/user/logout',\n    VERIFY: 'accounts/verify',\n    RESEND_VERIFY: \"accounts/user/{email}/verify\",\n    RESET_PASSWORD: 'accounts/user/reset-password',\n    CHANGE_PASSWORD: 'accounts/user/change-password',\n    CHANGE_EMAIL: 'accounts/user/change-email',\n    INFO: 'accounts/info',\n    PROTECTED: 'accounts/protected',\n    STATUS: 'accounts/status',\n    RECOMMENDER: 'recommender',\n    GRAPHICS: 'graphics',\n    FEEDBACK: 'feedback',\n    // library import from classic\n    LIBRARY_IMPORT_CLASSIC_AUTH: 'harbour/auth/classic',\n    LIBRARY_IMPORT_CLASSIC_MIRRORS: 'harbour/mirrors',\n    LIBRARY_IMPORT_CLASSIC_TO_BBB: 'biblib/classic',\n    // library import from 2.0\n    LIBRARY_IMPORT_ADS2_AUTH: 'harbour/auth/twopointoh',\n    LIBRARY_IMPORT_ADS2_TO_BBB: 'biblib/twopointoh',\n    LIBRARY_IMPORT_ZOTERO: 'harbour/export/twopointoh/zotero',\n    LIBRARY_IMPORT_MENDELEY: 'harbour/export/twopointoh/mendeley',\n    // returns credentials from both classic and 2.0 if they exist\n    LIBRARY_IMPORT_CREDENTIALS: 'harbour/user',\n    // store ADS information connected with ORCID here\n    ORCID_PREFERENCES: 'orcid/preferences',\n    ORCID_NAME: 'orcid/orcid-name',\n    // library endpoints\n    // can get info about all libraries, or list of bibcodes associated w/specific lib (libraries/id)\n    // post to /libraries/ to create a library\n    LIBRARIES: 'biblib/libraries',\n    LIBRARY_TRANSFER: 'biblib/transfer',\n    // can post, put, and delete changes to individual libs using this endpoint\n    DOCUMENTS: 'biblib/documents',\n    PERMISSIONS: 'biblib/permissions',\n    REFERENCE: 'reference/text',\n\n    /*\n     * this is used by the mixin 'user_change_rows' to set max allowed/default requested\n     */\n    _limits: {\n      // use the same name from discovery.config.js\n      ExportWidget: {\n        default: 500,\n        limit: 3000\n      },\n      Metrics: {\n        default: 7000,\n        limit: 7000\n      },\n      AuthorNetwork: {\n        default: 400,\n        limit: 1000\n      },\n      PaperNetwork: {\n        default: 400,\n        limit: 1000\n      },\n      ConceptCloud: {\n        default: 150,\n        limit: 150\n      },\n      BubbleChart: {\n        // default == limit\n        default: 1500\n      }\n    }\n  }; // add credential info\n  // doesn't require cross domain cookies\n\n  config._doesntNeedCredentials = [config.SEARCH, config.QTREE, config.BIGQUERY, config.EXPORT, config.SERVICE_AUTHOR_NETWORK, config.SERVICE_PAPER_NETWORK, config.SERVICE_WORDCLOUD, config.SERVICE_METRICS, config.RECOMMENDER, config.GRAPHICS, config.FEEDBACK];\n  return config;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/api_targets.js?");

/***/ }),

/***/ "./src/js/components/default_request.js":
/*!**********************************************!*\
  !*** ./src/js/components/default_request.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Created by rchyla on 3/28/14.\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! backbone */ \"./src/libs/backbone.js\"), __webpack_require__(/*! js/components/api_query */ \"./src/js/components/api_query.js\"), __webpack_require__(/*! js/components/multi_params */ \"./src/js/components/multi_params.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, Backbone, ApiQuery, MultiParams) {\n  var basicCheck = function basicCheck(s) {\n    if (_.isString(s)) {\n      return true;\n    }\n\n    if (_.isArray(s)) {\n      var l = s.length;\n\n      for (var i = 0; i < l; i++) {\n        var x = s[i];\n\n        if (!(_.isString(x) || _.isNumber(x))) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n\n  var allowedAttrs = {\n    query: function query(v) {\n      if (_.isUndefined(v)) {\n        return true;\n      }\n\n      return v instanceof ApiQuery;\n    },\n    target: basicCheck,\n    sender: basicCheck,\n    options: basicCheck\n  };\n  var checker = {\n    target: function target(s) {\n      if (s && s.substring(0, 1) !== '/') {\n        return '/' + s;\n      }\n    }\n  };\n  var Request = MultiParams.extend({\n    /**\n     * Internal method: we allow only certain keys\n     *\n     * @param attributes\n     * @param options\n     * @returns {boolean}\n     * @private\n     */\n    _validate: function _validate(attributes, options) {\n      _.forOwn(attributes, function (val, attr) {\n        var tempVal = attributes[attr];\n\n        if (!(attr in allowedAttrs)) {\n          throw new Error('Invalid attr: ' + attr);\n        }\n\n        if (!allowedAttrs[attr].call(allowedAttrs, tempVal)) {\n          throw new Error('Invalid value:key ' + attr + tempVal);\n        }\n      });\n\n      return true;\n    },\n\n    /**\n     * Modified version of the multi-valued set(); we do not insist\n     * on having the values in array\n     *\n     * @param key\n     * @param val\n     * @param options\n     * @returns {Request}\n     */\n    set: function set(key, val, options) {\n      this._checkLock();\n\n      var attrs;\n      if (key == null) return this; // Handle both `\"key\", value` and `{key: value}` -style arguments.\n\n      if (_typeof(key) === 'object') {\n        attrs = key;\n        options = val;\n      } else {\n        (attrs = {})[key] = val;\n      }\n\n      Backbone.Model.prototype.set.call(this, attrs, options);\n    },\n    // for requests, we use all components: path, query, hash\n    _checkParsed: function _checkParsed(attrs) {\n      if (_.isObject(attrs)) {\n        var ret = {};\n\n        if ('#query' in attrs && !_.isEmpty(attrs['#query'])) {\n          ret.query = new ApiQuery(attrs['#query']);\n        }\n\n        if ('#path' in attrs) {\n          ret.target = attrs['#path'][0];\n        }\n\n        if ('#hash' in attrs) {\n          _.extend(ret, _.each(attrs['#hash'], function (val, key, obj) {\n            if (val.length == 1) {\n              obj[key] = val[0];\n            }\n          }));\n        }\n\n        return ret;\n      }\n\n      return attrs;\n    },\n\n    /*\n     * Return the url string encoding all parameters that made\n     * this request. The parameters will be sorted alphabetically\n     * by their keys and URL encoded so that they can be used\n     * in requests.\n     */\n    url: function url(whatToSort) {\n      if (!whatToSort) {\n        whatToSort = this.attributes;\n      }\n\n      var target = whatToSort.target;\n      var url = target ? _.isArray(target) ? target.join('/') : target : '';\n\n      if ('query' in whatToSort) {\n        url += '?' + whatToSort.query.url();\n      }\n\n      if ('sender' in whatToSort) {\n        url += '#' + MultiParams.prototype.url.call(this, {\n          sender: whatToSort.sender\n        });\n      }\n\n      return url;\n    },\n\n    /**\n     * Re-constructs the query from the url string, returns the json attributes;\n     * cannot be used it the instance is locked\n     *\n     * @param query (String)\n     * @returns {Model}\n     */\n    load: function load(query) {\n      return MultiParams.prototype.load.call(this, query.indexOf('?') > -1 ? query : query + '?');\n    }\n  });\n  return Request;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/default_request.js?");

/***/ }),

/***/ "./src/js/components/facade.js":
/*!*************************************!*\
  !*** ./src/js/components/facade.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Created by rchyla on 3/16/14. inspiration: http://jsfiddle.net/pajtai/GD5qR/35/\n */\n\n/*\n * // Interface\n *  var remoteInterface = {\n *    on: 'turn on'\n *  };\n *  // Implementation\n *  var htmlRemote = {\n *    on: function() { console.log(\"remote on\"); return this; }\n *  };\n *  // Protecting the implementation\n *  var htmlInterface = new Facade(remoteInterface, htmlRemote);\n *\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! js/components/facade */ \"./src/js/components/facade.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, Facade) {\n  // The Facade encapsulates objectIn according to the description\n  // The exposed facade is guaranteed to have exactly the functions described in description.\n  var Facade = function Facade(description, objectIn) {\n    var facade; // TODO: add enforce of \"new\"\n\n    facade = {};\n    this.mixIn(description, objectIn, facade); // TODO: check that \"mixIn\" is not taken\n\n    facade.mixIn = this.mixIn;\n    return facade;\n  };\n\n  Facade.prototype.mixIn = function (description, objectIn, facade) {\n    var property;\n    var propertyValue;\n    facade = facade || this;\n\n    for (property in description) {\n      propertyValue = description[property];\n\n      if (property in objectIn) {\n        var p = objectIn[property];\n\n        if (typeof propertyValue === 'function') {\n          // redefining the method\n          facade[property] = _.bind(propertyValue, objectIn);\n        } else if (typeof p === 'function') {\n          // exposing the method\n          facade[property] = _.bind(p, objectIn);\n        } else if (_.isUndefined(p)) {// pass\n        } else if (_.isString(p) || _.isNumber(p) || _.isBoolean(p) || _.isDate(p) || _.isNull(p) || _.isRegExp(p)) {\n          // build getter method\n          facade['get' + property.substring(0, 1).toUpperCase() + property.substring(1)] = _.bind(function () {\n            return this.ctx[this.name];\n          }, {\n            ctx: objectIn,\n            name: property\n          });\n          facade[property] = p; // copy the value (it is immutable anyways)\n        } else if (p.hasOwnProperty('__facade__') && p.__facade__) {\n          // exposing internal facade\n          facade[property] = p;\n        } else if (_.isObject(p) && 'getHardenedInstance' in p) {\n          // builds a facade\n          facade[property] = p.getHardenedInstance();\n        } else {\n          throw new Error(\"Sorry, you can't wrap '\" + property + \"': \" + p);\n        }\n      } else if (typeof propertyValue === 'function') {\n        facade[property] = _.bind(propertyValue, objectIn);\n      } else {\n        throw new Error('Unknown key: ' + property + '(' + propertyValue + ')');\n      }\n    }\n\n    if (objectIn) {\n      // .name is not supported in IE\n      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n      facade.__facade__ = Boolean(objectIn.constructor ? objectIn.constructor.name ? objectIn.constructor.name : true : true);\n    } else {\n      facade.__facade__ = true;\n    } // TODO:rca - shall we use?\n    // if (Object.freeze)\n    //  facade = Object.freeze(facade);\n\n\n    return facade;\n  };\n\n  return Facade;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/facade.js?");

/***/ }),

/***/ "./src/js/components/generic_module.js":
/*!*********************************************!*\
  !*** ./src/js/components/generic_module.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * A generic class to be used for building modules (the Marionette.Module)\n * just complicates things. For simple things, just use this class.\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! backbone */ \"./src/libs/backbone.js\"), __webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Backbone, _) {\n  // A list of options to be attached directly to the module, if provided.\n  var moduleOptions = ['className', 'activate'];\n\n  var Module = function Module(options) {\n    var defaults;\n    options = options || {};\n    this.mid = _.uniqueId('module');\n\n    _.extend(this, _.pick(options, moduleOptions));\n\n    this.initialize.call(this, options);\n  }; // every module has the Events mixin\n\n\n  _.extend(Module.prototype, Backbone.Events, {\n    className: 'GenericModule',\n    initialize: function initialize() {},\n    destroy: function destroy() {},\n    activate: function activate(options) {\n      _.extend(this, _.pick(options, moduleOptions));\n    }\n  }); // give the module subclassing functionality\n\n\n  Module.extend = Backbone.Model.extend;\n  return Module;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/generic_module.js?");

/***/ }),

/***/ "./src/js/components/json_response.js":
/*!********************************************!*\
  !*** ./src/js/components/json_response.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * A simple wrapper around the API response for ADS\n * This class is extended/enhanced by other implementations\n * (e.g. solr_response)\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! backbone */ \"./src/libs/backbone.js\"), __webpack_require__(/*! js/components/api_query */ \"./src/js/components/api_query.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, Backbone, ApiQuery) {\n  var JSONResponse = function JSONResponse(attributes, options) {\n    var defaults;\n    var attrs = attributes || {};\n    options || (options = {});\n    this.rid = _.uniqueId('r');\n    this.readOnly = options.hasOwnProperty('readOnly') ? options.readOnly : true;\n    this._url = options.hasOwnProperty('url') ? options.url : null;\n    if (options.parse) attrs = this.parse(attrs, options) || {};\n\n    if (defaults = _.result(this, 'defaults')) {\n      attrs = _.defaults({}, attrs, defaults);\n    }\n\n    this.attributes = attrs;\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(JSONResponse.prototype, {\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function initialize() {},\n    getApiQuery: function getApiQuery() {\n      return this.apiQuery;\n    },\n    setApiQuery: function setApiQuery(q) {\n      if (!q) {\n        return;\n      }\n\n      if (!(q instanceof ApiQuery)) {\n        throw new Error('Only ApiQuery instances accepted');\n      }\n\n      this.apiQuery = q;\n    },\n    // Return a copy of the model's `attributes` object.\n    toJSON: function toJSON(options) {\n      return this._clone(this.attributes);\n    },\n    // url string that identifies this object\n    url: function url() {\n      if (this._url) {\n        return this._url;\n      }\n\n      return this.rid; // default is just to return response id\n    },\n    set: function set(key, val, options) {\n      if (this.readOnly) {\n        throw Error(\"You can't change read-only response object\");\n      }\n\n      var parts = this._split(key);\n\n      if (parts.length == 1) {\n        this.attributes[parts[0]] = val;\n      } else {\n        var pointer = this.get(key);\n        pointer = val;\n      }\n    },\n    _split: function _split(key) {\n      var parts = [];\n      var i = 0;\n      var l = key.length;\n      var start = 0;\n      var quotes = [];\n\n      while (i < l) {\n        if (key[i] == quotes[quotes.length - 1]) {\n          quotes.pop();\n        } else if (key[i] == '\"' || key[i] == \"'\") {\n          quotes.push(key[i]);\n        } else if (key[i] == '.' && quotes.length == 0) {\n          parts.push(key.substring(start, i));\n          start = i + 1;\n        } else if (key[i] == '[' && quotes.length == 0) {\n          parts.push(key.substring(start, i));\n          parts.push(key.substring(i, key.indexOf(']', i + 1) + 1));\n          start = i = key.indexOf(']', i + 1) + 1;\n        }\n\n        i += 1;\n      }\n\n      if (start < l) {\n        parts.push(key.substring(start));\n      } // console.log(key, parts);\n\n\n      return parts;\n    },\n    has: function has(key) {\n      return this.get(key, true);\n    },\n    get: function get(key, justCheck, defaultValue) {\n      // if key empty, return everything\n      if (!key) {\n        return this._clone(this.attributes);\n      }\n\n      var parts = this._split(key);\n\n      var found = [];\n      var pointer = this.attributes;\n\n      while (parts.length > 0) {\n        var k = parts.shift();\n\n        if (pointer.hasOwnProperty(k)) {\n          pointer = pointer[k];\n          found.push(k);\n        } else if (k.indexOf('[') > -1) {\n          // foo['something'] or foo[0]\n          var m = k.trim().substring(1, k.length - 1);\n\n          if ((m.indexOf('\"') > -1 || m.indexOf(\"'\") > -1) && pointer.hasOwnProperty(m.substring(1, m.length - 1))) {\n            // object property access\n            pointer = pointer[m.substring(1, m.length - 1)];\n            found.push(m);\n          } else if (_.isArray(pointer)) {\n            var ix = null;\n\n            try {\n              ix = parseInt(m);\n\n              if (_.isNaN(ix) || pointer.length <= ix || ix < 0) {\n                if (justCheck) {\n                  return false;\n                }\n\n                if (typeof defaultValue !== 'undefined') {\n                  return defaultValue;\n                }\n\n                throw new Error();\n              }\n\n              pointer = pointer[ix];\n              found.push(m);\n            } catch (e) {\n              if (justCheck) {\n                return false;\n              }\n\n              if (typeof defaultValue !== 'undefined') {\n                return defaultValue;\n              }\n\n              throw new Error(\"Can't find: \" + key + (found.length > 0 ? ' (worked up to: ' + found.join('.') + ')' : ''));\n            }\n          } else {\n            if (justCheck) {\n              return false;\n            }\n\n            if (typeof defaultValue !== 'undefined') {\n              return defaultValue;\n            }\n\n            throw new Error(\"Can't find: \" + key + (found.length > 0 ? ' (worked up to: ' + found.join('.') + ')' : ''));\n          }\n        } else {\n          if (justCheck) {\n            return false;\n          }\n\n          if (typeof defaultValue !== 'undefined') {\n            return defaultValue;\n          }\n\n          throw new Error(\"Can't find: \" + key + (found.length > 0 ? ' (worked up to: ' + found.join('.') + ')' : ''));\n        }\n      }\n\n      if (justCheck) {\n        return true;\n      }\n\n      return this._clone(pointer);\n    },\n    clone: function clone() {\n      return new this.constructor(this.attributes);\n    },\n    // creates a copy of the requested elements\n    _clone: function _clone(elem) {\n      if (!this.readOnly || !_.isObject(elem)) {\n        return elem;\n      }\n\n      if (_.cloneDeep) {\n        // lodash\n        return _.cloneDeep(elem);\n      }\n\n      return JSON.parse(JSON.stringify(elem));\n    },\n    isLocked: function isLocked() {\n      return this.readOnly;\n    },\n    lock: function lock() {\n      return this.readOnly = true;\n    },\n    unlock: function unlock() {\n      return this.readOnly = false;\n    }\n  }); // use the bb extend function for classes hierarchy\n\n\n  JSONResponse.extend = Backbone.Model.extend;\n  return JSONResponse;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n/**\n * Created by rchyla on 3/3/14.\n */\n\n//# sourceURL=webpack://bumblebee/./src/js/components/json_response.js?");

/***/ }),

/***/ "./src/js/components/multi_params.js":
/*!*******************************************!*\
  !*** ./src/js/components/multi_params.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*\n multi_params is a generic class to store any parameters;\n it is backed by BB.Model and has all the functionality\n the values are always stored as an array of values; so\n even if you try to set strings, you will always have\n list of strings\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! backbone */ \"./src/libs/backbone.js\"), __webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! jquery */ \"./src/libs/jquery.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Backbone, _, $) {\n  var Model = Backbone.Model.extend({\n    locked: false,\n    _checkLock: function _checkLock() {\n      if (this.locked === true) {\n        throw Error('Object locked for modifications');\n      }\n    },\n    isLocked: function isLocked() {\n      return this.locked;\n    },\n    lock: function lock() {\n      this.locked = true;\n    },\n    unlock: function unlock() {\n      this.locked = false;\n    },\n    clone: function clone() {\n      if (this.isLocked()) {\n        var c = new this.constructor(this.attributes);\n        c.lock();\n        return c;\n      }\n\n      return new this.constructor(this.attributes);\n    },\n    hasVal: function hasVal(key) {\n      return !_.isEmpty(this.get(key));\n    },\n    // we allow only strings and numbers; instead of sending\n    // signal we throw a direct error\n    _validate: function _validate(attributes, options) {\n      // check we have only numbers and/or finite numbers\n      for (var attr in attributes) {\n        if (!_.isString(attr)) {\n          throw new Error('Keys must be strings, not: ' + attr);\n        } // remove empty strings\n\n\n        var tempVal = attributes[attr];\n        tempVal = _.without(_.flatten(tempVal), '', false, null, undefined, NaN);\n\n        if (!_.isArray(tempVal)) {\n          throw new Error('Values were not converted to an Array');\n        }\n\n        if (_.isEmpty(tempVal) && options.unset !== true) {\n          throw new Error('Empty values not allowed');\n        }\n\n        if (!_.every(tempVal, function (v) {\n          return _.isString(v) || _.isNumber(v) && !_.isNaN(v);\n        })) {\n          throw new Error('Invalid value (not a string or number): ' + tempVal);\n        }\n\n        attributes[attr] = tempVal;\n      }\n\n      return true;\n    },\n    // Every value is going to be multi-valued by default\n    // in this way we can treat all objects in the same way\n    set: function set(key, val, options) {\n      this._checkLock();\n\n      var attrs;\n      if (key == null) return this; // Handle both `\"key\", value` and `{key: value}` -style arguments.\n\n      if (_typeof(key) === 'object') {\n        attrs = key;\n        options = val;\n      } else {\n        (attrs = {})[key] = val;\n      }\n\n      for (var attr in attrs) {\n        var tempVal = attrs[attr]; // convert to array if necessary\n\n        if (!_.isArray(tempVal)) {\n          attrs[attr] = _.flatten([tempVal]);\n        }\n      }\n\n      Backbone.Model.prototype.set.call(this, attrs, options);\n    },\n    unset: function unset() {\n      this._checkLock();\n\n      Backbone.Model.prototype.unset.apply(this, arguments);\n    },\n    // adds values to existing (like set, but keeps the old vals)\n    add: function add(key, val, options) {\n      this._checkLock();\n\n      var attrs;\n      if (key == null) return this; // Handle both `\"key\", value` and `{key: value}` -style arguments.\n\n      if (_typeof(key) === 'object') {\n        attrs = key;\n        options = val;\n      } else {\n        (attrs = {})[key] = val;\n      }\n\n      for (var attr in attrs) {\n        var tempVal = attrs[attr]; // convert to array if necessary\n\n        if (!_.isArray(tempVal)) {\n          tempVal = _.flatten([tempVal]);\n        }\n\n        if (this.has(attr)) {\n          tempVal = _.clone(this.get(attr)).concat(tempVal);\n        }\n\n        attrs[attr] = tempVal;\n      }\n\n      Backbone.Model.prototype.set.call(this, attrs, options);\n    },\n    // synchronization is disabled\n    sync: function sync() {\n      throw Error('MultiParams cannot be saved to server');\n    },\n\n    /*\n     * Return the url string encoding all parameters that made\n     * this query. The parameters will be sorted alphabetically\n     * by their keys and URL encoded so that they can be used\n     * in requests.\n     */\n    url: function url(whatToSort) {\n      if (!whatToSort) {\n        whatToSort = this.attributes;\n      } // sort keys alphabetically\n\n\n      var sorted = _.pairs(whatToSort).sort(function (a, b) {\n        return a[0] > b[0] ? 1 : a[0] < b[0] ? -1 : 0;\n      }); // June1:rca - I need to preserve order of values (becuaes of the query modifications/updates) the logic\n      // just requires us to be careful and we need order to be preserved when the query is cloned\n      // also sort values\n      // var s = {};\n      // sorted.map(function(item) { s[item[0]] = (_.isArray(item[1]) ? item[1].sort() : item[1]) });\n      // we have to double encode certain elements\n      // sorted = _.map(sorted, function(pair) { return [pair[0], _.map(pair[1], function(v) {return (v.indexOf && v.indexOf('=') > -1) ? encodeURIComponent(v) : v })]});\n      // use traditional encoding\n      // use %20 instead of + (url encoding instead of form encoding)\n\n\n      var encoded = $.param(_.object(sorted), true);\n      encoded = encoded.replace(/\\+/g, '%20'); // Replace funky unicode quotes with normal ones\n\n      encoded = encoded.replace(/%E2%80%9[ECD]/g, '%22');\n      return encoded;\n    },\n\n    /**\n     * Parses string (urlparams) and returns it as an object\n     * @param resp\n     * @param options\n     * @returns {*}\n     */\n    parse: function parse(resp, options) {\n      if (_.isString(resp)) {\n        var attrs = {};\n        resp = decodeURI(resp);\n\n        if (resp.indexOf('?') > -1) {\n          attrs['#path'] = [resp.slice(0, resp.indexOf('?'))];\n          resp = resp.slice(resp.indexOf('?') + 1);\n        }\n\n        if (resp.indexOf('#') > -1) {\n          attrs['#hash'] = this._parse(resp.slice(resp.indexOf('#') + 1));\n          resp = resp.slice(0, resp.indexOf('#'));\n        }\n\n        attrs['#query'] = this._parse(resp);\n        return this._checkParsed(attrs);\n      }\n\n      return this._checkParsed(resp); // else return resp object\n    },\n    _parse: function _parse(resp) {\n      var attrs = {};\n      var hash;\n\n      if (!resp.trim()) {\n        return attrs;\n      }\n\n      var hashes = resp.slice(resp.indexOf('?') + 1).split('&'); // resp = decodeURIComponent(resp);\n\n      var key;\n      var value;\n\n      for (var i = 0; i < hashes.length; i++) {\n        hash = hashes[i].split('=');\n        key = decodeURIComponent(hash[0].split('+').join(' ')); // optimized: .replace(/\\+/g, \" \")\n\n        var vall = hash[1];\n\n        if (hash.length > 2) {\n          hash.shift();\n          vall = hash.join('=');\n        } // replace literal '%' with code and '+' become literal spaces\n\n\n        value = decodeURIComponent(vall.replace(/%(?!\\d|[ABCDEF]+)/gi, '%25').split('+').join(' '));\n\n        if (attrs[key] !== undefined) {\n          attrs[key].push(value);\n        } else {\n          attrs[key] = [value];\n        }\n      }\n\n      return attrs;\n    },\n    // default behaviour is just to keep the query parameters\n    // after the string was parsed, you can override it to suit other needs\n    _checkParsed: function _checkParsed(attrs) {\n      if (_.isObject(attrs)) {\n        if ('#query' in attrs) {\n          return attrs['#query'];\n        }\n      }\n\n      return attrs;\n    },\n\n    /**\n     * Re-constructs the query from the url string, returns the json attributes;\n     * cannot be used it the instance is locked\n     *\n     * @param query (String)\n     * @returns {Model}\n     */\n    load: function load(query) {\n      this._checkLock();\n\n      var vals = this.parse(query);\n      this.clear();\n      this.set(vals);\n      return this;\n    }\n  });\n  return Model;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/multi_params.js?");

/***/ }),

/***/ "./src/js/components/navigator.js":
/*!****************************************!*\
  !*** ./src/js/components/navigator.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? Object(arguments[i]) : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n /**\n * Created by rchyla on 3/10/14.\n */\n\n/**\n * Mediator (event aggregator) to coordinate transitions/navigations\n * inside application. Each applications should have one 'navigator'\n * and one 'router' - the router is responsible for 'going into the\n * state directly' (ie. from a bookmarked ursl) and for updating the\n * history object. The rest is handled by the navigator. There is a\n * one-to-one relation between router<->navigator\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! jquery */ \"./src/libs/jquery.js\"), __webpack_require__(/*! cache */ \"./src/libs/cache.js\"), __webpack_require__(/*! js/components/generic_module */ \"./src/js/components/generic_module.js\"), __webpack_require__(/*! js/mixins/dependon */ \"./src/js/mixins/dependon.js\"), __webpack_require__(/*! js/components/transition */ \"./src/js/components/transition.js\"), __webpack_require__(/*! js/components/transition_catalog */ \"./src/js/components/transition_catalog.js\"), __webpack_require__(/*! analytics */ \"./src/js/components/analytics.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, $, Cache, GenericModule, Mixins, Transition, TransitionCatalog, analytics) {\n  // Document Title Constants\n  var APP_TITLE = 'Astrophysics Data System';\n  var TITLE_SEP = ' - '; // This function is used to hash the user id before sending it to Analytics\n\n  var digestMessage = function digestMessage(message) {\n    var crypto = window.crypto || window.msCrypto;\n\n    if (!crypto) {\n      return Promise.reject(new Error('Crypto not available'));\n    } // encode as (utf-8) Uint8Array\n\n\n    var msgUi8 = new TextEncoder().encode(message); // hash the message\n\n    return crypto.subtle.digest('SHA-256', msgUi8).then(function (hashBuffer) {\n      var hashArray = Array.from(new Uint8Array(hashBuffer));\n      return hashArray.map(function (b) {\n        return b.toString(16).padStart(2, '0');\n      }).join('');\n    });\n  };\n\n  var Navigator = GenericModule.extend({\n    initialize: function initialize(options) {\n      options = options || {};\n      this.router = options.router;\n      this.catalog = new TransitionCatalog(); // catalog of nagivation points (later we can build FST)\n    },\n\n    /**\n     * Starts listening on the PubSub\n     *\n     * @param beehive - the full access instance; we excpect PubSub to be\n     *    present\n     */\n    activate: function activate(beehive) {\n      this.setBeeHive(beehive);\n      this.storage = beehive.getObject('AppStorage');\n      var pubsub = this.getPubSub();\n      pubsub.subscribe(pubsub.NAVIGATE, _.bind(this.navigate, this));\n      pubsub.subscribe(pubsub.CUSTOM_EVENT, _.bind(this._onCustomEvent, this));\n      pubsub.subscribe(pubsub.USER_ANNOUNCEMENT, _.bind(this._onUserAnnouncement, this));\n    },\n    _onUserAnnouncement: function _onUserAnnouncement(ev, data) {\n      if (ev === 'user_signed_in' && typeof data === 'string') {\n        // the user is signed in, we can associate the user with the session\n        digestMessage(data).then(function (userIdHash) {\n          analytics('send', 'user_update', {\n            user_id: userIdHash\n          });\n        });\n      }\n    },\n    _debouncedAnalyticsCall: _.debounce(function () {\n      analytics.push.apply(analytics, arguments);\n    }, 500),\n    _onCustomEvent: function _onCustomEvent(ev, data) {\n      console.log('Custom Event', ev, data);\n\n      switch (ev) {\n        case 'timing:results-loaded':\n          window.getSentry(function (sentry) {\n            var activeSpan = sentry.getActiveSpan().getSpanJSON();\n            var time = new Date().getTime() - activeSpan.start_timestamp * 1000;\n            sentry.setMeasurement('timing.results.shown', time, 'millisecond');\n          });\n          break;\n\n        case 'update-document-title':\n          this._updateDocumentTitle(data);\n\n          break;\n\n        case 'latest-abstract-data':\n          {\n            if (Array.isArray(data.database)) {\n              analytics.set('items', undefined);\n              data.database.forEach(function (database) {\n                // do not debounce here, since we want multiple\n                analytics.push({\n                  event: 'view_item',\n                  items: [{\n                    item_id: data.bibcode,\n                    item_name: data.title,\n                    item_category: database,\n                    index: data.resultsIndex,\n                    refereed: data.property.includes('REFEREED')\n                  }]\n                });\n              });\n            } else {\n              this._debouncedAnalyticsCall({\n                event: 'view_item',\n                items: [{\n                  item_id: data.bibcode,\n                  item_name: data.title,\n                  item_category: '(no collection)',\n                  index: data.resultsIndex,\n                  refereed: data.property.includes('REFEREED')\n                }]\n              });\n            }\n\n            break;\n          }\n\n        case 'search-page-results':\n          // clear items array on the data layer\n          this._debouncedAnalyticsCall({\n            event: 'view_item_list',\n            item_list_id: 'search_results',\n            item_list_name: 'Search Results',\n            items: data.docs.map(function (doc) {\n              return _objectSpread({\n                item_id: doc.identifier,\n                item_name: doc.title[0]\n              }, doc.database.slice(1).reduce(function (acc, cat, idx) {\n                return _objectSpread({}, acc, _defineProperty({}, \"item_category\".concat(idx + 1), cat));\n              }, {\n                item_category: doc.database[0]\n              }), {\n                item_list_id: 'search_results',\n                item_list_name: 'Search Results',\n                item_variant: 'search_result_item',\n                index: doc.resultsIndex,\n                refereed: doc.property.includes('REFEREED')\n              });\n            })\n          });\n\n          break;\n\n        default: // do nothing\n\n      }\n    },\n    _cleanRoute: function _cleanRoute(route) {\n      var r = route.match(/[#\\/]?([^\\/]*)\\//);\n\n      if (r && r.length > 1) {\n        return '/' + r[1];\n      }\n\n      return route;\n    },\n    _setPageAndEmitEvent: _.debounce(function (route, pageName) {\n      analytics.reset();\n      analytics('send', 'virtual_page_view', {\n        page_name: pageName,\n        clean_route: this._cleanRoute(route)\n      });\n      getSentry(function (sentry) {\n        sentry.setTag('page.name', pageName);\n      });\n    }, 300),\n\n    /**\n     * Responds to PubSubEvents.NAVIGATE signal\n     */\n    navigate: function navigate(ev, arg1, arg2) {\n      var defer = $.Deferred();\n      var self = this;\n\n      if (!this.router || !(this.router instanceof Backbone.Router)) {\n        defer.reject(new Error(\"Navigator must be given 'router' instance\"));\n        return defer.promise();\n      }\n\n      var transition = this.catalog.get(ev);\n\n      if (!transition) {\n        this.handleMissingTransition(arguments);\n        defer.reject(new Error('Missing route; going to 404'));\n        return defer.promise();\n      }\n\n      if (!transition.execute) {\n        // do nothing\n        return defer.resolve().promise();\n      }\n\n      var afterNavigation = _.bind(function () {\n        // router can communicate directly with navigator to replace url\n        var replace = !!(transition.replace || arg1 && arg1.replace);\n\n        if (transition.route === '' || transition.route) {\n          var route = transition.route === '' ? '/' : transition.route;\n\n          this._setPageAndEmitEvent(route, ev);\n\n          this.router.navigate(route, {\n            trigger: false,\n            replace: replace\n          });\n        } // clear any metadata added to head on the previous page\n\n\n        $('head').find('meta[data-highwire]').remove();\n\n        this._updateDocumentTitle(transition.title);\n\n        defer.resolve();\n      }, this);\n\n      var p;\n\n      try {\n        p = transition.execute.apply(transition, arguments);\n        p && _.isFunction(p.then) ? p.then(afterNavigation) : afterNavigation();\n      } catch (e) {\n        this.handleTransitionError(transition, e, arguments);\n        var err = new Error('Error transitioning to route; going to 404');\n        return defer.reject(err).promise();\n      }\n\n      return defer.promise();\n    },\n    _updateDocumentTitle: function _updateDocumentTitle(title) {\n      if (_.isUndefined(title) || title === false) return;\n      var currTitle = this.storage.getDocumentTitle();\n\n      var setDocTitle = _.bind(function (t) {\n        document.title = t === '' ? APP_TITLE : t + TITLE_SEP + APP_TITLE;\n        this.storage.setDocumentTitle(t);\n      }, this); // title is defined and it is different from the current one, it should be updated\n\n\n      if (title !== currTitle) {\n        setDocTitle(title);\n      }\n    },\n    handleMissingTransition: function handleMissingTransition(transition) {\n      console.error(\"Cannot handle 'navigate' event: \" + JSON.stringify(arguments));\n      var ps = this.getPubSub();\n      ps.publish(ps.BIG_FIRE, 'navigation-error', arguments);\n      if (this.catalog.get('404')) ps.publish(ps.NAVIGATE, '404');\n    },\n    handleTransitionError: function handleTransitionError(transition, error, args) {\n      console.error('Error while executing transition', transition, args);\n      console.error(error.stack);\n      var ps = this.getPubSub();\n      ps.publish(ps.CITY_BURNING, 'navigation-error', arguments);\n      if (this.catalog.get('404')) ps.publish(ps.NAVIGATE, '404');\n    },\n\n    /**\n     * Sets the transition inside the catalog; you can pass simplified\n     * list of options or the Transition instance\n     */\n    set: function set() {\n      if (arguments.length == 1) {\n        if (arguments[1] instanceof Transition) {\n          return this.catalog.add(arguments[1]);\n        }\n\n        throw new Error(\"You must be kiddin' sir!\");\n      } else if (arguments.length == 2) {\n        var endpoint = arguments[0];\n\n        if (_.isFunction(arguments[1])) {\n          return this.catalog.add(new Transition(endpoint, {\n            execute: arguments[1]\n          }));\n        }\n\n        if (_.isObject(arguments[1]) && arguments[1].execute) {\n          return this.catalog.add(new Transition(endpoint, arguments[1]));\n        }\n\n        throw new Error('Himmm, I dont know how to create a catalog rule with this input:', arguments);\n      } else {\n        // var args = array.slice.call(arguments, 1);\n        throw new Error('Himmm, I dont know how to create a catalog rule with this input:', arguments);\n      }\n    },\n    get: function get(endpoint) {\n      return this.catalog.get(endpoint);\n    }\n  });\n\n  _.extend(Navigator.prototype, Mixins.BeeHive);\n\n  return Navigator;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/navigator.js?");

/***/ }),

/***/ "./src/js/components/pubsub_events.js":
/*!********************************************!*\
  !*** ./src/js/components/pubsub_events.js ***!
  \********************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Created by rchyla on 3/30/14.\n */\n\n/**\n * Catalogue of PubSub events; we assume this:\n *\n *  - FC = the component lives in the 'Forbidden City'\n *         inside Application, typically this is a PubSub or Api, Mediator\n *         or any component with elevated access\n *\n *  - OC = Outer City: the suburbs of the application; these are typically\n *         UI components (behind the wall), untrusted citizens of the\n *         BumbleBee state\n *\n *  WARNING: do not use spaces; events with spaces are considered to be\n *        multiple events! (e.g. '[PubSub] New-Query' will be two events)\n *\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n  var PubSubEvents = {\n    /**\n     * Usually called by OC's as a first step in the query processing.\n     * It means: 'user did something', we need to start reacting. The OC\n     * will build a new ApiQuery and send it together with this event\n     */\n    START_SEARCH: '[PubSub]-New-Query',\n\n    /**\n     * Called by FC's (usually: Mediator) - this is a signal to *all* OC's\n     * they should receive ApiQuery object, compare it against their\n     * own query; find diff and create a new ApiRequest (asking for a data)\n     * and send that back\n     */\n    INVITING_REQUEST: '[PubSub]-Inviting-Request',\n\n    /**\n     * Will be called by OC's, this is response to ApiQuery input.\n     */\n    DELIVERING_REQUEST: '[PubSub]-New-Request',\n\n    /**\n     * Will be called by OC's, this is one-time forget action (outside of the\n     * the search cycle); use this for any query that needs to be executed\n     * and not be tracked by search cycle\n     */\n    EXECUTE_REQUEST: '[PubSub]-Execute-Request',\n\n    /**\n     * Called from the router, the QID will be passed; the query needs to be\n     * loaded and executed\n     */\n    EXECUTE_STORED_QUERY: '[PubSub]-Execute-Stored-Query',\n\n    /**\n     * Published by FC's - typically Mediator - when a response has been retrieved\n     * for a given ApiRequest.\n     *\n     * OC's should subscribe to this event when they want to receive data\n     * from the treasury (api)\n     *\n     *  - input: ApiRequest\n     *  - output: ApiResponse\n     */\n    DELIVERING_RESPONSE: '[PubSub]-New-Response',\n\n    /**\n     * The walls of the FC are being closed; and no new requests will be served\n     */\n    CLOSING_GATES: '[PubSub]-Closing',\n\n    /**\n     * PubSub will not receive any requests any more\n     */\n    CLOSED_FOR_BUSINESS: '[PubSub]-Closed',\n\n    /**\n     * ForbiddenCity is about to receive requests\n     */\n    OPENING_GATES: '[PubSub]-Opening',\n\n    /**\n     * Called after PubSub became ready - it is fully operational\n     */\n    OPEN_FOR_BUSINESS: '[PubSub]-Ready',\n\n    /**\n     *  Set of error warnings issues by PubSub - or by some other FC's - to\n     *  deal with congestion or other problems\n     */\n    SMALL_FIRE: '[PubSub]-Problem',\n    BIG_FIRE: '[PubSub]-Big-Problem',\n    CITY_BURNING: '[PubSub]-Disaster',\n\n    /**\n     * A message containing feedback from the FC; traveling towards OC\n     * The feedback will be instance of ApiFeedback\n     */\n    FEEDBACK: '[FC]-FeedBack',\n\n    /**\n     * A message from the router requesting showing citizens of the\n     * city\n     */\n    DISPLAY_DOCUMENTS: '[Router]-Display-Documents',\n    DISPLAY_DOCUMENTS_DETAILS: '[Router]-Display-Documents-Details',\n\n    /**\n     * Used by OC to request parsed query tree - to check a query\n     * for example\n     */\n    GET_QTREE: '[FC]-GetQTree',\n    NAVIGATE: '[Router]-Navigate-With-Trigger',\n\n    /*\n     * so navigator can notify interested widgets about a change\n     * from search page to user page, for instance-- navigator cannot\n     * to this since it listens to many events including widget-show events\n     * */\n    PAGE_CHANGE: '[Navigator]Page-Changed',\n\n    /* for custom widget-to-widget events */\n    CUSTOM_EVENT: '[PubSub]-Custom-Event',\n    ARIA_ANNOUNCEMENT: '[PubSub]-Aria-Announcement',\n\n    /* anything to do with changing the state of the user, including session events */\n    USER_ANNOUNCEMENT: '[PubSub]-User-Announcement',\n\n    /**\n     * A message/action that should be displayed to the user (on prominent)\n     * place\n     */\n    ALERT: '[Alert]-Message',\n    ORCID_ANNOUNCEMENT: '[PubSub]-Orcid-Announcement',\n\n    /**\n     * Happens during the main cycle of the application birth\n     *  LOADED = when all components were successfuly loaded\n     *  BOOTSTRAPPED = + when all dynamic config was loaded\n     *  STARTING = + right before the router and history objects start()\n     *  STARTED = app is alive and handling requests\n     */\n    APP_LOADED: '[App]-Application-Loaded',\n    APP_BOOTSTRAPPED: '[App]-Application-Bootstrapped',\n    APP_STARTING: '[App]-Application-Starting',\n    APP_STARTED: '[App]-Application-Started',\n    APP_EXIT: '[App]-Exit',\n\n    /**\n     * Is triggered when user selects/deselects records\n     */\n    PAPER_SELECTION: '[User]-Paper-Selection',\n    // instead of toggling, adds all papers\n    BULK_PAPER_SELECTION: '[User]-Bulk-Paper-Selection',\n\n    /*\n     * is triggered by app storage itself when list of selected papers changes\n     * */\n    STORAGE_PAPER_UPDATE: '[User]-Paper-Update',\n    LIBRARY_CHANGE: '[PubSub]-Library-Change'\n  };\n  return PubSubEvents;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/pubsub_events.js?");

/***/ }),

/***/ "./src/js/components/pubsub_key.js":
/*!*****************************************!*\
  !*** ./src/js/components/pubsub_key.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Created by rchyla on 3/14/14.\n */\n\n/*\n * A simple, yet important, class - every subscriber\n * to the PubSub must contain one key. This class\n * should be instantiated in a safe manner. ie.\n *\n * PubSubKey.newInstance({creator: this});\n *\n * But beware that as long as the subscriber is alive\n * reference to the creator will be saved inside\n * the key! So choose carefully whether you use this\n * functionality\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_) {\n  var PubSubKey = function PubSubKey(options) {\n    _.extend(this, options);\n  };\n\n  _.extend(PubSubKey, {\n    /*\n     * Creates a new Instances of the PubSubKey\n     * with a storage that cannot be changed.\n     * To double sign the key, you can pass\n     * an object that identifies creator of the\n     * key and test identity, eg.\n     *\n     * var creator = {};\n     * var k = PubSubKey(creator);\n     * k.getCreator() === k;\n     *\n     */\n    newInstance: function newInstance(options) {\n      var priv = {\n        id: _.has(options, 'id') ? options.id : _.uniqueId(':psk'),\n        creator: _.has(options, 'creator') ? options.creator : null\n      };\n      return new PubSubKey({\n        getId: function getId() {\n          return priv.id;\n        },\n        getCreator: function getCreator() {\n          return priv.creator;\n        }\n      });\n    }\n  });\n\n  return PubSubKey;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/pubsub_key.js?");

/***/ }),

/***/ "./src/js/components/solr_params.js":
/*!******************************************!*\
  !*** ./src/js/components/solr_params.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\nSubclass of the multi-param with a functionality specific for\nSOLR queries. Do not use this class directly inside your app!\nInstead, import 'api_query' and configure it properly\n\n * <p>For a list of possible parameters, please consult the links below.</p>\n *\n * @see http://wiki.apache.org/solr/CoreQueryParameters\n * @see http://wiki.apache.org/solr/CommonQueryParameters\n * @see http://wiki.apache.org/solr/SimpleFacetParameters\n * @see http://wiki.apache.org/solr/HighlightingParameters\n * @see http://wiki.apache.org/solr/MoreLikeThis\n * @see http://wiki.apache.org/solr/SpellCheckComponent\n * @see http://wiki.apache.org/solr/StatsComponent\n * @see http://wiki.apache.org/solr/TermsComponent\n * @see http://wiki.apache.org/solr/TermVectorComponent\n * @see http://wiki.apache.org/solr/LocalParams\n *\n * @param properties A map of fields to set. Refer to the list of public fields.\n * @class ParameterStore\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! js/components/multi_params */ \"./src/js/components/multi_params.js\"), __webpack_require__(/*! backbone */ \"./src/libs/backbone.js\"), __webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! jquery */ \"./src/libs/jquery.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (MultiParams, Backbone, _, $) {\n  var SolrParams = MultiParams.extend({\n    fieldsToConcatenate: [],\n    defaultOperator: ' ',\n    fieldProcessors: {\n      '*': function _(vals, self) {\n        return [vals.join(self.defaultOperator)];\n      }\n    },\n    initialize: function initialize(attributes, options) {\n      if (options) {\n        _.extend(this, _.pick(options, ['fieldsToConcatenate', 'defaultOperator', 'fieldProcessors']));\n      }\n    },\n    url: function url(resp, options) {\n      // first massage the fields, but do not touch the original values\n      // lodash has a parameter isDeep that can be set to true, but\n      // for compatibility reasons with underscore, lets' not use it\n      // the values should always be only one level deep\n      var values = _.clone(this.attributes);\n\n      var l = this.fieldsToConcatenate.length;\n      var k = '';\n\n      for (var i = 0; i < l; i++) {\n        k = this.fieldsToConcatenate[i];\n\n        if (this.has(k)) {\n          if (this.fieldProcessors[k]) {\n            values[k] = this.fieldProcessors[k](this.get(k), this);\n          } else {\n            values[k] = this.fieldProcessors['*'](this.get(k), this);\n          }\n        }\n      } // then call the default implementation of the url handling\n\n\n      return MultiParams.prototype.url.call(this, values);\n    }\n  });\n  return SolrParams;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/solr_params.js?");

/***/ }),

/***/ "./src/js/components/transition.js":
/*!*****************************************!*\
  !*** ./src/js/components/transition.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_) {\n  var Transition = function Transition(endpoint, options) {\n    if (!_.isString(endpoint)) {\n      throw new Error('Endpoint name must be a string');\n    }\n\n    this.endpoint = endpoint;\n\n    _.extend(this, options);\n  };\n\n  _.extend(Transition.prototype, {\n    route: false,\n    trigger: false,\n    replace: false,\n    title: false,\n    execute: function execute() {\n      throw new Error('You must override this method');\n    }\n  });\n\n  return Transition;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/transition.js?");

/***/ }),

/***/ "./src/js/components/transition_catalog.js":
/*!*************************************************!*\
  !*** ./src/js/components/transition_catalog.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! js/components/transition */ \"./src/js/components/transition.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, Transition) {\n  var TransitionCatalog = function TransitionCatalog(options) {\n    this._catalog = {};\n  };\n\n  _.extend(TransitionCatalog.prototype, {\n    add: function add(transition) {\n      if (!(transition instanceof Transition)) {\n        throw new Error('You can add only Transition objects');\n      }\n\n      this._catalog[transition.endpoint] = transition;\n      return transition;\n    },\n    get: function get(name) {\n      return this._catalog[name];\n    },\n    remove: function remove(name) {\n      delete this._catalog[name];\n    }\n  });\n\n  return TransitionCatalog;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/transition_catalog.js?");

/***/ }),

/***/ "./src/js/mixins/api_access.js":
/*!*************************************!*\
  !*** ./src/js/mixins/api_access.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! backbone */ \"./src/libs/backbone.js\"), __webpack_require__(/*! js/components/api_query */ \"./src/js/components/api_query.js\"), __webpack_require__(/*! js/components/api_request */ \"./src/js/components/api_request.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, Backbone, ApiQuery, ApiRequest) {\n  /*\n   * this simple mixin contacts the api (getApiAccess), and if the {reconnect: true} option\n   * is passed to getApiAccess, will save the relevant data.\n   * */\n  return {\n    /**\n     * After bootstrap receives all data, this routine should decide what to do with\n     * them\n     */\n    onBootstrap: function onBootstrap(data) {\n      var beehive = this.getBeeHive(); // set the API key and other data from bootstrap\n\n      if (data.access_token) {\n        beehive.getService('Api').setVals({\n          access_token: \"\".concat(data.token_type, \" \").concat(data.access_token),\n          refresh_token: data.refresh_token,\n          expires_at: data.expires_at\n        });\n        console.warn('Redefining access_token: ' + data.access_token);\n        var userObject = beehive.getObject('User');\n        var userName = data.anonymous ? undefined : data.username;\n        userObject.setUser(userName);\n        var storage = beehive.getService('PersistentStorage');\n        storage && storage.set && storage.set('appConfig', data);\n      } else {\n        console.warn(\"bootstrap didn't provide access_token!\");\n      }\n    },\n    getApiAccess: function getApiAccess(options) {\n      options = options || {};\n      var api = this.getBeeHive().getService('Api');\n      var self = this;\n      var defer = $.Deferred(); // if token expired, make a _request\n\n      var request = options.tokenRefresh ? '_request' : 'request';\n      api[request](new ApiRequest({\n        query: new ApiQuery(),\n        target: this.bootstrapUrls ? this.bootstrapUrls[0] : '/accounts/bootstrap'\n      }), {\n        done: function done(data) {\n          window.getSentry(function (sentry) {\n            sentry.setUser({\n              id: data.access_token,\n              anonymous: data.anonymous\n            });\n          });\n\n          if (options.reconnect) {\n            self.onBootstrap(data);\n          }\n\n          defer.resolve(data);\n        },\n        fail: function fail() {\n          defer.reject.apply(defer, arguments);\n        },\n        type: 'GET'\n      });\n      return defer;\n    }\n  };\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/mixins/api_access.js?");

/***/ }),

/***/ "./src/js/mixins/dependon.js":
/*!***********************************!*\
  !*** ./src/js/mixins/dependon.js ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Created by rchyla on 3/13/14.\n */\n\n/*\n * This module contains a set of utilities that can be added to classes\n * to give them certain functionality\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! js/components/pubsub_events */ \"./src/js/components/pubsub_events.js\"), __webpack_require__(/*! js/components/pubsub_key */ \"./src/js/components/pubsub_key.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, PubSubEvents, PubSubKey) {\n  var Mixin = {\n    /*\n     * BeeHive is the object that allows modules to get access to objects\n     * of the application (but we make sure these objects are protected\n     * and only application can set/change them). This mixin gives objects\n     * functions to query 'BeeHive'\n     */\n    BeeHive: {\n      // called by parents (app) to give modules access\n      setBeeHive: function setBeeHive(brundibar) {\n        if (_.isEmpty(brundibar)) throw new Error('Huh? Empty Beehive? Trying to be funny?');\n        this.__beehive = brundibar;\n      },\n      getBeeHive: function getBeeHive() {\n        if (!this.hasBeeHive()) throw new Error('The BeeHive is inactivate (or dead :<})');\n        return this.__beehive;\n      },\n      hasBeeHive: function hasBeeHive() {\n        if (this.__beehive && (this.__beehive.active || this.__beehive.__facade__ && this.__beehive.getActive())) {\n          return true;\n        }\n\n        return false;\n      },\n\n      /**\n       * Method which returns a masked instance of PubSub (unless the PubSub\n       * is already a hardened instance; which carries its own key)\n       *\n       * You can call pubsub.publish() without having to supply the pubsub key\n       * (which is what most controllers want to do; there are only some\n       * exceptions to this rule; ie. query-mediator). If you need to get\n       * access to the full PubSub (and you have it inside BeeHive) then do\n       * this.getBeeHive().getService('PubSub')\n       */\n      getPubSub: function getPubSub() {\n        if (!this.hasBeeHive()) throw new Error('The BeeHive is inactive (or dead >:})');\n        if (!this.__ctx) this.__ctx = {};\n        if (this.__ctx.pubsub) return this.__ctx.pubsub;\n\n        var pubsub = this.__beehive.getService('PubSub');\n\n        if (pubsub && pubsub.__facade__) return pubsub; // build a unique key for this instance\n\n        this.__ctx.pubsub = {\n          _key: pubsub.getPubSubKey(),\n          _exec: function _exec(name, args) {\n            args = _.toArray(args);\n            if (args[0] instanceof PubSubKey) throw Error('You have given us a PubSub key, this.publish() method does not need it.');\n            args.unshift(this._key);\n            pubsub[name].apply(pubsub, args);\n          },\n          publish: function publish() {\n            this._exec('publish', arguments);\n          },\n          subscribe: function subscribe() {\n            this._exec('subscribe', arguments);\n          },\n          subscribeOnce: function subscribeOnce() {\n            this._exec('subscribeOnce', arguments);\n          },\n          unsubscribe: function unsubscribe() {\n            this._exec('unsubscribe', arguments);\n          },\n          getCurrentPubSubKey: function getCurrentPubSubKey() {\n            return this._key;\n          }\n        };\n\n        _.extend(this.__ctx.pubsub, PubSubEvents);\n\n        return this.__ctx.pubsub;\n      },\n      hasPubSub: function hasPubSub() {\n        if (this.hasBeeHive()) return _.isObject(this.__beehive.getService('PubSub'));\n        return false;\n      }\n    },\n    App: {\n      setApp: function setApp(app) {\n        if (_.isUndefined(app)) throw new Error('App object cannot be empty');\n        this.__app = app;\n      },\n      getApp: function getApp() {\n        return this.__app;\n      },\n      hasApp: function hasApp() {\n        return !_.isEmpty(this.__app);\n      }\n    }\n  };\n  return Mixin;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/mixins/dependon.js?");

/***/ }),

/***/ "./src/js/mixins/hardened.js":
/*!***********************************!*\
  !*** ./src/js/mixins/hardened.js ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Created by rchyla on 3/18/14.\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! js/components/facade */ \"./src/js/components/facade.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, Facade) {\n  var Mixin = {\n    /*\n     * Creates a hardened instance of itself, it uses\n     * interface description from 'hardenedInterface'\n     * Implementations need to populate 'hardenedInterface'\n     * with list of properties and methods that should be exposed\n     * through the Facade\n     */\n    _getHardenedInstance: function _getHardenedInstance(iface, objectIn) {\n      if (!('hardenedInterface' in this) && !iface) {\n        throw Error('Error: this.hardenedInterface is not defined');\n      }\n\n      return new Facade(iface || ('hardenedInterface' in this ? this.hardenedInterface : {}), objectIn);\n    },\n    getHardenedInstance: function getHardenedInstance(iface) {\n      return this._getHardenedInstance(iface, this);\n    }\n  };\n  return Mixin;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/mixins/hardened.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd define */
/******/ 	!function() {
/******/ 		__webpack_require__.amdD = function () {
/******/ 			throw new Error('define cannot be used indirect');
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/amd options */
/******/ 	!function() {
/******/ 		__webpack_require__.amdO = {};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	!function() {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = function(result, chunkIds, fn, priority) {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var chunkIds = deferred[i][0];
/******/ 				var fn = deferred[i][1];
/******/ 				var priority = deferred[i][2];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	!function() {
/******/ 		__webpack_require__.nmd = function(module) {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	!function() {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"Navigator": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = function(chunkId) { return installedChunks[chunkId] === 0; };
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = function(parentChunkLoadingFunction, data) {
/******/ 			var chunkIds = data[0];
/******/ 			var moreModules = data[1];
/******/ 			var runtime = data[2];
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some(function(id) { return installedChunks[id] !== 0; })) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkbumblebee"] = self["webpackChunkbumblebee"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	!function() {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["vendor"], function() { return __webpack_require__("./src/js/apps/discovery/navigator.js"); })
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;