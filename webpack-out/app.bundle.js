/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/apps/discovery/main.js":
/*!***************************************!*\
  !*** ./src/js/apps/discovery/main.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var js_components_application__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! js/components/application */ \"./src/js/components/application.js\");\n/* harmony import */ var js_components_application__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(js_components_application__WEBPACK_IMPORTED_MODULE_0__);\n/* eslint-disable global-require */\n\n/**\n * Discovery application: main bootstrapping routine\n *\n * Here we will bring up to life the discovery application,\n * all configuration is provided through the discovery.config.js\n *\n * Inside the config, there are sections for:\n *\n *  - where to find js libraries\n *  - which widgets to load (for this application)\n *  - which environmental variables are used\n *        (and how to bootstrap run-time values)\n *\n */\n// import Router from 'router';\n // import DiscoveryBootstrap from 'js/mixins/discovery_bootstrap';\n// import ApiAccess from 'js/mixins/api_access';\n// import ApiFeedback from 'js/components/api_feedback';\n// import analytics from 'analytics';\n// const app = new (Application.extend(DiscoveryBootstrap))();\n\nvar app = new (js_components_application__WEBPACK_IMPORTED_MODULE_0___default())();\ndocument.write(JSON.stringify(app, null, 2)); // define(['config/discovery.config', 'module'], function(config, module) {\n//   // eslint-disable-next-line import/no-dynamic-require\n//   require([\n//     'router',\n//     'js/components/application',\n//     'js/mixins/discovery_bootstrap',\n//     'js/mixins/api_access',\n//     'js/components/api_feedback',\n//     'analytics',\n//   ], function(\n//     Router,\n//     Application,\n//     DiscoveryBootstrap,\n//     ApiAccess,\n//     ApiFeedback,\n//     analytics\n//   ) {\n//     const updateProgress =\n//       typeof window.__setAppLoadingProgress === 'function'\n//         ? window.__setAppLoadingProgress\n//         : function() {};\n//\n//     Application.prototype.shim();\n//\n//     // at the beginning, we don't know anything about ourselves...\n//     var debug = window.location.href.indexOf('debug=true') > -1;\n//\n//     // app object will load everything\n//     var app = new (Application.extend(DiscoveryBootstrap))({\n//       debug: debug,\n//\n//       // This is a general timeout which is only used per-module (plugins, controllers, etc.)\n//       timeout: 60 * 1000, // 60 * 1000, // 60 seconds\n//     });\n//\n//     // load the objects/widgets/modules (using discovery.config.js)\n//     var appPromise = app.loadModules(module.config());\n//\n//     updateProgress(30, 'Loading Modules');\n//\n//     var startApp = function() {\n//       updateProgress(80, 'App Loaded');\n//\n//       // this will activate all loaded modules\n//       app.activate();\n//\n//       var pubsub = app.getService('PubSub');\n//       pubsub.publish(pubsub.getCurrentPubSubKey(), pubsub.APP_LOADED);\n//\n//       // set some important urls, parameters before doing anything\n//       app.configure();\n//\n//       updateProgress(95, 'Finishing Up...');\n//       app.bootstrap().done(function(data) {\n//         updateProgress(100);\n//\n//         app.onBootstrap(data);\n//\n//         var dynConf = app.getObject('DynamicConfig');\n//         if (dynConf && dynConf.debugExportBBB) {\n//           window.bbb = app;\n//         }\n//\n//         pubsub.publish(pubsub.getCurrentPubSubKey(), pubsub.APP_BOOTSTRAPPED);\n//\n//         pubsub.publish(pubsub.getCurrentPubSubKey(), pubsub.APP_STARTING);\n//         app.start(Router).done(function() {\n//           pubsub.publish(pubsub.getCurrentPubSubKey(), pubsub.APP_STARTED);\n//\n//           var getUserData = function() {\n//             try {\n//               var beehive = _.isFunction(this.getBeeHive) && this.getBeeHive();\n//               var user =\n//                 _.isFunction(beehive.getObject) && beehive.getObject('User');\n//               if (user) {\n//                 return user.getUserData('USER_DATA');\n//               }\n//             } catch (e) {\n//               // do nothing\n//             }\n//             return {};\n//           };\n//\n//           // handle user preferences for external link actions\n//           var updateExternalLinkBehavior = _.debounce(\n//             function() {\n//               var userData = getUserData.call(app);\n//               var action =\n//                 (userData.externalLinkAction &&\n//                   userData.externalLinkAction.toUpperCase()) ||\n//                 'AUTO';\n//               if (action === 'OPEN IN CURRENT TAB') {\n//                 var max = 10;\n//                 var timeout;\n//                 (function updateLinks(count) {\n//                   clearTimeout(timeout);\n//                   if (count < max) {\n//                     $('a[target=\"_blank\"]').attr('target', '');\n//                     timeout = setTimeout(updateLinks, 1000, count + 1);\n//                   }\n//                 })(0);\n//               }\n//             },\n//             3000,\n//             { leading: true, trailing: false },\n//             false\n//           );\n//           pubsub.subscribe(\n//             pubsub.getCurrentPubSubKey(),\n//             pubsub.NAVIGATE,\n//             updateExternalLinkBehavior\n//           );\n//           updateExternalLinkBehavior();\n//\n//           const toggle = ($sidebar, $content, $button) => {\n//             $sidebar.toggleClass('show');\n//             let text =\n//               '<i class=\"fa fa-close\" aria-hidden=\"true\"></i> Close Menu';\n//             if ($sidebar.hasClass('show')) {\n//               $content.removeClass('full-width');\n//             } else {\n//               text = '<i class=\"fa fa-bars\" aria-hidden=\"true\"></i> Show Menu';\n//               $content.addClass('full-width');\n//             }\n//             $button.html(text);\n//           };\n//\n//           // some global event handlers, not sure if right place\n//           $('body').on('click', 'button.toggle-menu', function(e) {\n//             var $button = $(e.target);\n//             var $sidebar = $button\n//               .parents()\n//               .eq(1)\n//               .find('.nav-container');\n//\n//             var $content = $button\n//               .parents()\n//               .eq(1)\n//               .find('.user-pages__main-content');\n//\n//             toggle($sidebar, $content, $button);\n//\n//             $('a', $sidebar).on('click', () => {\n//               toggle($sidebar, $content, $button);\n//             });\n//           });\n//\n//           $('body').on('click', '#abs-full-txt-toggle', function() {\n//             $('#resources-container').toggleClass('show');\n//             if ($('#resources-container').hasClass('show')) {\n//               $('#abs-full-txt-toggle').text('Hide Sources');\n//             } else {\n//               $('#abs-full-txt-toggle').text('Full Text Sources');\n//             }\n//           });\n//\n//           $('body').on('click', '#results-actions-toggle', function() {\n//             $('#query-info-container').toggleClass('show');\n//             if ($('#query-info-container').hasClass('show')) {\n//               $('#results-actions-toggle').html(\n//                 '<i class=\"fa fa-times\" title=\"close actions\" aria-hidden=\"true\"></i> Actions'\n//               );\n//             } else {\n//               $('#results-actions-toggle').html(\n//                 '<i class=\"fa fa-book\" title=\"open actions\" aria-hidden=\"true\"></i> Actions'\n//               );\n//             }\n//           });\n//\n//           // accessibility: skip to main content\n//           $('body').on('click', '#skip-to-main-content', function() {\n//             $('#main-content').trigger('focus');\n//             return false;\n//           });\n//\n//           // check for is-proxied class, and if present, send alert\n//           if ($('body').hasClass('is-proxied')) {\n//             const url = window.getCanonicalUrl();\n//             const msg = `\n//               <p>\n//                 You are using a proxied version of ADS, we recommend you switch to the regular non-proxied URL:\n//                 <a href=\"${url}${location.pathname}\" rel=\"noopener noreferrer\">${url}</a></p>\n//               <p>\n//                 Configure authenticated access to publisher content via the Library Link Server in your account\n//                 <a href=\"${url}/user/settings/librarylink\" rel=\"noopener noreferrer\">preferences</a>.\n//               </p>\n//             `;\n//\n//             pubsub.publish(\n//               pubsub.getCurrentPubSubKey(),\n//               pubsub.ALERT,\n//               new ApiFeedback({\n//                 type: 'danger',\n//                 msg,\n//               })\n//             );\n//           }\n//\n//           // app is loaded, send timing event\n//\n//           if (window.__PAGE_LOAD_TIMESTAMP) {\n//             var time = new Date() - window.__PAGE_LOAD_TIMESTAMP;\n//             analytics('send',\n//               'timing',\n//               {\n//               timingCategory: 'Application',\n//               timingVar: 'Loaded',\n//               timingValue: time,\n//             });\n//\n//             // send to analytics the theme user is using\n//             const darkSwitch = localStorage.getItem('darkSwitch');\n//             let action = 'systemSetting';\n//             let label = 'light';\n//             if (darkSwitch !== null) {\n//               if (darkSwitch === 'on') {\n//                 action = 'appSetting';\n//                 label = 'dark';\n//               } else {\n//                 action = 'appSetting';\n//                 label = 'light';\n//               }\n//             } else if (\n//               window.matchMedia('(prefers-color-scheme: dark)').matches\n//             ) {\n//               action = 'systemSetting';\n//               label = 'dark';\n//             }\n//             analytics(\n//               'send',\n//               'event',\n//               'uitheme', // category\n//               action,\n//               label\n//             );\n//\n//             if (debug) {\n//               console.log('Application Started: ' + time + 'ms');\n//             }\n//           }\n//\n//           // clear the app loading timer\n//           window.clearTimeout(window.APP_LOADING_TIMER);\n//         });\n//       });\n//     };\n//\n//     var failedLoad = function() {\n//       analytics('send', 'event', 'introspection', 'failed-load', arguments);\n//\n//       if (!debug) {\n//         app.redirect('500.html');\n//       }\n//     };\n//\n//     var failedReload = function() {\n//       analytics(\n//         'send',\n//         'event',\n//         'introspection',\n//         'failed-reloading',\n//         arguments\n//       );\n//\n//       if (debug) {\n//         // so error messages remain in the console\n//         return;\n//       }\n//       // if we failed loading, retry *once again* (and give up eventually)\n//       app.reload('404.html');\n//     };\n//\n//     // after they are loaded; we'll kick off the application\n//     appPromise\n//       .done(startApp)\n//       .fail(failedLoad)\n//       .fail(failedReload);\n//   });\n// });\n\n//# sourceURL=webpack://bumblebee/./src/js/apps/discovery/main.js?");

/***/ }),

/***/ "./src/js/components/api_query.js":
/*!****************************************!*\
  !*** ./src/js/components/api_query.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n A facade: api query exposing only the set of functions that we allow. This is\n the module that you want to load in the application (do not load the concrete\n implementaions, such as solr_params !)\n\n Put in your config:\n map: {\n 'your/module': {\n 'api_query_impl': 'js/components/specific_impl_of_the_api_query'\n }\n },\n\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! backbone */ \"./src/libs/backbone.js\"), __webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! js/components/solr_params */ \"./src/js/components/solr_params.js\"), __webpack_require__(/*! js/components/facade */ \"./src/js/components/facade.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Backbone, _, ApiQueryImplementation, Facade) {\n  var hardenedInterface = {\n    add: 'add values',\n    set: 'set (replace existing)',\n    get: 'get values',\n    has: 'has a key',\n    hasVal: 'more specific `has` using _.isEmpty',\n    url: 'url string of the params',\n    load: 'loads query as a string',\n    clear: 'clears all values',\n    unset: 'removes a key',\n    toJSON: 'values back as JSON object',\n    clone: 'make a copy',\n    isLocked: true,\n    lock: true,\n    unlock: true,\n    pairs: 'get all values as pairs',\n    keys: 'as keys',\n    values: 'only values',\n    hasChanged: 'whether this object has modification (since its creation)',\n    previousAttributes: 'get all changed attributes',\n    previous: 'previous values for a given attribute'\n  };\n\n  var ApiQuery = function ApiQuery(data, options) {\n    // Facade pattern, we want to expose only limited API\n    // despite the fact that the underlying instance has\n    // all power of the Backbone.Model\n    if (data instanceof ApiQueryImplementation) {\n      this.innerQuery = new Facade(hardenedInterface, data);\n    } else {\n      this.innerQuery = new Facade(hardenedInterface, new ApiQueryImplementation(data, options));\n    }\n  };\n\n  var toInsert = {};\n\n  _.each(_.keys(hardenedInterface), function (element, index, list) {\n    toInsert[element] = function () {\n      return this.innerQuery[element].apply(this.innerQuery, arguments);\n    };\n  });\n\n  _.extend(ApiQuery.prototype, toInsert, {\n    clone: function clone() {\n      var clone = this.innerQuery.clone.apply(this.innerQuery, arguments);\n      return new ApiQuery(clone);\n    },\n    load: function load() {\n      var clone = this.innerQuery.load.apply(this.innerQuery, arguments);\n      return new ApiQuery(clone);\n    }\n  });\n\n  return ApiQuery;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/api_query.js?");

/***/ }),

/***/ "./src/js/components/api_request.js":
/*!******************************************!*\
  !*** ./src/js/components/api_request.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Created by rchyla on 3/28/14.\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! backbone */ \"./src/libs/backbone.js\"), __webpack_require__(/*! js/components/facade */ \"./src/js/components/facade.js\"), __webpack_require__(/*! js/components/default_request */ \"./src/js/components/default_request.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, Backbone, Facade, ApiRequestImpl) {\n  var hardenedInterface = {\n    // add makes no sense with request\n    get: 'get a key',\n    set: 'set (replace existing)',\n    url: 'url string defining this request',\n    has: 'has a key',\n    load: 'loads request as a string',\n    clear: 'clears all values',\n    unset: 'removes a key',\n    toJSON: 'values back as JSON object',\n    clone: 'make a copy',\n    isLocked: true,\n    lock: true,\n    unlock: true,\n    pairs: 'get all values as pairs',\n    keys: 'as keys',\n    values: 'only values',\n    hasChanged: 'whether this object has modification (since its creation)',\n    previousAttributes: 'get all changed attributes',\n    previous: 'previous values for a given attribute'\n  };\n\n  var ApiRequest = function ApiRequest(data, options) {\n    // Facade pattern, we want to expose only limited API\n    // despite the fact that the underlying instance has\n    // all power of the Backbone.Model\n    if (data instanceof ApiRequestImpl) {\n      this.innerRequest = new Facade(hardenedInterface, data);\n    } else {\n      this.innerRequest = new Facade(hardenedInterface, new ApiRequestImpl(data, options));\n    }\n  };\n\n  var toInsert = {};\n\n  _.each(_.keys(hardenedInterface), function (element, index, list) {\n    toInsert[element] = function () {\n      return this.innerRequest[element].apply(this.innerRequest, arguments);\n    };\n  });\n\n  _.extend(ApiRequest.prototype, toInsert, {\n    clone: function clone() {\n      var clone = this.innerRequest.clone.apply(this.innerRequest, arguments);\n      return new ApiRequest(clone);\n    },\n    load: function load() {\n      var clone = this.innerRequest.load.apply(this.innerRequest, arguments);\n      return new ApiRequest(clone);\n    }\n  });\n\n  return ApiRequest;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/api_request.js?");

/***/ }),

/***/ "./src/js/components/application.js":
/*!******************************************!*\
  !*** ./src/js/components/application.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Application object contains methods for asynochronous loading of other modules\n * It will load BeeHive by default, and it recognizes the following types of\n * objects\n *\n *  core:\n *    modules - any module you want to load and give it access to the full\n *              BeeHive (these guys are loaded first)\n *    services - these instances will be inserted into Beehive.Services\n *              (loaded after modules)\n *    objects - these will be inserted into BeeHive.Objects\n *              (loaded after services)\n *\n *  plugins - any object you want to instantiate\n *  widgets - any visual object you want to instantiate\n *\n *\n *  this is the normal workflow\n *\n *  var app = new Application();\n *  var promise = app.loadModules({\n *       core: {\n *         services: {\n *           PubSub: 'js/services/pubsub',\n *           Api: 'js/services/api'\n *         },\n *         modules: {\n *           QueryMediator: 'js/components/query_mediator'\n *         }\n *       },\n *       widgets: {\n *         YearFacet: 'js/widgets/facets/factory'\n *       }\n *     });\n *   promise.done(function() {\n *     app.activate();\n *     //....continue setting up layout etc\n *   });\n *\n *\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! jquery */ \"./src/libs/jquery.js\"), __webpack_require__(/*! backbone */ \"./src/libs/backbone.js\"), module, __webpack_require__(/*! js/components/beehive */ \"./src/js/components/beehive.js\"), __webpack_require__(/*! js/mixins/api_access */ \"./src/js/mixins/api_access.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, $, Backbone, module, BeeHive, ApiAccess) {\n  var DEFAULT_MODULE_TIMEOUT = 60 * 1000; // 60 seconds\n\n  var updateProgress = typeof window.__setAppLoadingProgress === 'function' ? window.__setAppLoadingProgress : function () {};\n\n  var Application = function Application(options) {\n    options || (options = {});\n    this.aid = _.uniqueId('application');\n    this.debug = true;\n\n    _.extend(this, _.pick(options, ['timeout', 'debug']));\n\n    this.initialize.apply(this, arguments);\n  };\n\n  var Container = function Container() {\n    this.container = {};\n  };\n\n  _.extend(Container.prototype, {\n    has: function has(name) {\n      return this.container.hasOwnProperty(name);\n    },\n    get: function get(name) {\n      return this.container[name];\n    },\n    remove: function remove(name) {\n      delete this.container[name];\n    },\n    add: function add(name, obj) {\n      this.container[name] = obj;\n    }\n  });\n\n  _.extend(Application.prototype, {\n    initialize: function initialize(config, options) {\n      // these are core (elevated access)\n      this.__beehive = new BeeHive();\n      this.__modules = new Container();\n      this.__controllers = new Container(); // these are barbarians behind the gates\n\n      this.__widgets = new Container();\n      this.__plugins = new Container();\n      this.__barbarianRegistry = {};\n      this.__barbarianInstances = {};\n    },\n\n    /*\n     * code that accounts for browser deficiencies\n     */\n    shim: function shim() {\n      if (!window.location.origin) {\n        window.location.origin = window.location.protocol + '//' + window.location.hostname + (window.location.port ? ':' + window.location.port : '');\n      }\n    },\n\n    /**\n     * Purpose of this call is to load dynamically all modules\n     * that you pass in a configuration. We'll load them using\n     * requirejs and set them into BeeHive\n     *\n     * This method returns 'Deferred' object, which tells you\n     * whether initialization has finished. You *have to* use it\n     * in the following way;\n     *\n     * app = new Application();\n     * defer = app.loadModules(config, options);\n     * defer.done(function() {\n     *    // .... do something with the application\n     * })\n     *\n     * @param config\n     * @param options\n     */\n    loadModules: function loadModules(config, options) {// var promises = [];\n      // var self = this;\n      // var promise;\n      //\n      // var core = config.core;\n      // if (core) {\n      //   _.each(['controllers', 'modules', 'services', 'objects'], function(\n      //     name\n      //   ) {\n      //     if (core[name]) {\n      //       promise = self._loadModules(name, core[name]);\n      //       if (promise) {\n      //         promises.push(promise);\n      //       }\n      //     }\n      //   });\n      // }\n      //\n      // // plugins and widgets will be lazy-loaded (default)\n      //\n      // var plugins = config.plugins;\n      // var widgets = config.widgets;\n      //\n      // if (options && options.eagerLoad) {\n      //   if (plugins) {\n      //     promise = self._loadModules('plugins', plugins);\n      //     if (promise) promises.push(promise);\n      //   }\n      //\n      //   if (widgets) {\n      //     promise = self._loadModules('widgets', widgets);\n      //     if (promise) promises.push(promise);\n      //   }\n      // } else {\n      //   if (plugins) {\n      //     _.each(plugins, function(value, key) {\n      //       var x = {};\n      //       x[key] = value;\n      //       self.__plugins.add(\n      //         key,\n      //         self._loadModules('plugins', x, false, true)\n      //       );\n      //     });\n      //   }\n      //   if (widgets) {\n      //     _.each(widgets, function(value, key) {\n      //       var x = {};\n      //       x[key] = value;\n      //       self.__widgets.add(\n      //         key,\n      //         self._loadModules('widgets', x, false, true)\n      //       );\n      //     });\n      //   }\n      // }\n      //\n      // // hack, so that $.when() always returns []\n      // promises.length === 1 && promises.push(promise);\n      //\n      // // add a handler for updating the app loading bar\n      // let count = 0;\n      // promises.map((p) =>\n      //   p.then(() => {\n      //     self.logModuleLoaded((count += 1), promises.length);\n      //   })\n      // );\n      //\n      // var bigPromise = $.Deferred();\n      // $.when\n      //   .apply($, promises)\n      //   .then(function() {\n      //     _.each(arguments, function(promisedValues, idx) {\n      //       if (_.isArray(promisedValues)) {\n      //         if (self.debug) {\n      //           console.log('application: registering ' + promisedValues[0]);\n      //         }\n      //\n      //         self._registerLoadedModules.apply(self, promisedValues);\n      //       }\n      //     });\n      //   })\n      //   .done(function() {\n      //     bigPromise.resolve();\n      //   })\n      //   .fail(function() {\n      //     console.error(\n      //       'Generic error - we were not successul in loading all modules for config',\n      //       config\n      //     );\n      //     if (arguments.length) console.error(arguments);\n      //     bigPromise.reject.apply(bigPromise, arguments);\n      //   });\n      //\n      // return bigPromise.promise();\n    },\n    getBeeHive: function getBeeHive() {\n      return this.__beehive;\n    },\n    _registerLoadedModules: function _registerLoadedModules(section, modules) {\n      var beehive = this.getBeeHive();\n      var key;\n      var module;\n      var hasKey;\n      var addKey;\n      var removeKey;\n      var createInstance;\n      var self = this;\n\n      createInstance = function createInstance(key, module) {\n        if (!module) {\n          console.warn('Object ' + key + ' is empty, cannot instantiate it!');\n          return;\n        }\n\n        if (self.debug) {\n          console.log('Creating instance of: ' + key);\n        }\n\n        if (module.prototype) {\n          return new module();\n        }\n\n        if (module && module.hasOwnProperty(key)) {\n          return module[key];\n        }\n\n        return module;\n      }; // console.log('registering', section, modules);\n\n\n      if (section === 'controllers') {\n        hasKey = _.bind(this.hasController, this);\n        removeKey = _.bind(function (key) {\n          this.__controllers.remove(key);\n        }, this);\n        addKey = _.bind(function (key, module) {\n          this.__controllers.add(key, module);\n        }, this);\n      } else if (section === 'services') {\n        hasKey = _.bind(beehive.hasService, beehive);\n        removeKey = _.bind(beehive.removeService, beehive);\n        addKey = _.bind(beehive.addService, beehive);\n      } else if (section === 'objects') {\n        hasKey = _.bind(beehive.hasObject, beehive);\n        removeKey = _.bind(beehive.removeObject, beehive);\n        addKey = _.bind(beehive.addObject, beehive);\n      } else if (section === 'modules') {\n        createInstance = function createInstance(key, module) {\n          return module;\n        };\n\n        hasKey = _.bind(this.hasModule, this);\n        removeKey = _.bind(function (key) {\n          this.__modules.remove(key);\n        }, this);\n        addKey = _.bind(function (key, module) {\n          this.__modules.add(key, module);\n        }, this);\n      } else if (section === 'widgets') {\n        hasKey = _.bind(this.hasWidget, this);\n        removeKey = _.bind(function (key) {\n          this.__widgets.remove(key);\n        }, this);\n        addKey = _.bind(function (key, module) {\n          this.__widgets.add(key, module);\n        }, this);\n\n        createInstance = function createInstance(key, module) {\n          return module;\n        };\n      } else if (section === 'plugins') {\n        hasKey = _.bind(this.hasPlugin, this);\n        removeKey = _.bind(function (key) {\n          this.__plugins.remove(key);\n        }, this);\n        addKey = _.bind(function (key, module) {\n          this.__plugins.add(key, module);\n        }, this);\n\n        createInstance = function createInstance(key, module) {\n          return module;\n        };\n      } else {\n        throw new Error('Unknown section: ' + section);\n      }\n\n      _.each(_.pairs(modules), function (m) {\n        key = m[0], module = m[1];\n\n        if (hasKey(key)) {\n          removeKey(key);\n        }\n\n        var inst = createInstance(key, module);\n\n        if (!inst) {\n          console.warn('Removing ' + key + '(because it is null!)');\n          return;\n        }\n\n        addKey(key, inst);\n      });\n    },\n    _checkPrescription: function _checkPrescription(modulePrescription) {\n      // basic checking\n      _.each(_.pairs(modulePrescription), function (module, idx, list) {\n        var symbolicName = module[0];\n        var impl = module[1];\n        if (!_.isString(symbolicName) || !_.isString(impl)) throw new Error('You are kidding me, the key/implementation must be string values');\n      });\n    },\n\n    /**\n     * Loads modules *asynchronously* from the following structure\n     *\n     * {\n     *  'Api': 'js/services/api',\n     *  'PubSub': 'js/services/pubsub'\n     * },\n     *\n     * Returns Deferred - once that deferred object is resolved\n     * all modules have been loaded.\n     *\n     * @param modulePrescription\n     * @private\n     */\n    _loadModules: function _loadModules(sectionName, modulePrescription, ignoreErrors, lazyLoad) {// var self = this;\n      // this._checkPrescription(modulePrescription);\n      //\n      // if (this.debug) {\n      //   console.log('application: loading ' + sectionName, modulePrescription);\n      // }\n      //\n      // var ret = {};\n      //\n      // // create the promise object - load the modules asynchronously\n      // var implNames = _.keys(modulePrescription);\n      // var impls = _.values(modulePrescription);\n      // var defer = $.Deferred();\n      //\n      // var callback = function() {\n      //   if (self.debug) console.timeEnd('startLoading' + sectionName);\n      //   var modules = arguments;\n      //   _.each(implNames, function(name, idx, implList) {\n      //     ret[name] = modules[idx];\n      //   });\n      //   try {\n      //     defer.resolve(sectionName, ret);\n      //   } catch (e) {\n      //     /**\n      //      * CATCH ALL\n      //      *\n      //      * This will capture run-away errors from any loaded module.\n      //      * For now, just dump them into the 404 page (if its loaded)\n      //      */\n      //     const pubsub = self.getService('PubSub').getHardenedInstance();\n      //     pubsub.publish(pubsub.NAVIGATE, '404', {\n      //       message: `Page Not Found or Internal Error\n      //         <p>Error: <code>${e.message}</code></p>\n      //       `,\n      //     });\n      //   }\n      //   if (self.debug) {\n      //     console.log(\n      //       'Loaded: type=' + sectionName + ' state=' + defer.state(),\n      //       ret\n      //     );\n      //   }\n      // };\n      //\n      // var errback = function(err) {\n      //   var symbolicName = err.requireModules && err.requireModules[0];\n      //   if (self.debug)\n      //     console.warn('Error loading impl=' + symbolicName, err.requireMap);\n      //   if (ignoreErrors) {\n      //     if (self.debug) console.warn('Ignoring error');\n      //     return;\n      //   }\n      //   defer.reject(err);\n      // };\n      //\n      // var run = function() {\n      //   if (self.debug) console.time('startLoading' + sectionName);\n      //   // start loading the modules\n      //   // console.log('loading', implNames, impls)\n      //   require(impls, callback, errback);\n      //   return self._setTimeout(defer).promise();\n      // };\n      //\n      // run.lazyLoad = lazyLoad;\n      // return lazyLoad ? run : run();\n    },\n    _setTimeout: function _setTimeout(deferred) {\n      setTimeout(function () {\n        if (deferred.state() !== 'resolved') {\n          deferred.reject('Timeout, application is loading too long');\n        }\n      }, this.timeout || DEFAULT_MODULE_TIMEOUT);\n      return deferred;\n    },\n    logModuleLoaded: function logModuleLoaded(idx, total) {\n      updateProgress(function (val) {\n        return val + 50 / total;\n      }, \"Loading Modules \".concat(idx, \" of \").concat(total));\n    },\n    destroy: function destroy() {\n      this.getBeeHive().destroy();\n    },\n    activate: function activate(options) {\n      var beehive = this.getBeeHive();\n      var self = this; // services are activated by beehive itself\n\n      if (self.debug) {\n        console.log('application: beehive.activate()');\n      }\n\n      beehive.activate(beehive); // controllers receive application itself and elevated beehive object\n      // all of them must succeed; we don't catch errors\n\n      _.each(this.getAllControllers(), function (el) {\n        if (self.debug) {\n          console.log('application: controllers: ' + el[0] + '.activate(beehive, app)');\n        }\n\n        var plugin = el[1];\n\n        if ('activate' in plugin) {\n          plugin.activate(beehive, self);\n        }\n      }); // modules receive elevated beehive object\n\n\n      _.each(this.getAllModules(), function (el) {\n        try {\n          if (self.debug) {\n            console.log('application: modules: ' + el[0] + '.activate(beehive)');\n          }\n\n          var plugin = el[1];\n\n          if ('activate' in plugin) {\n            plugin.activate(beehive);\n          }\n        } catch (e) {\n          console.error('Error activating:' + el[0]);\n          console.error(e);\n        }\n      });\n\n      this.__activated = true;\n    },\n    isActivated: function isActivated() {\n      return this.__activated || false;\n    },\n    hasService: function hasService(name) {\n      return this.getBeeHive().hasService(name);\n    },\n    getService: function getService(name) {\n      return this.getBeeHive().getService(name);\n    },\n    hasObject: function hasObject(name) {\n      return this.getBeeHive().hasObject(name);\n    },\n    getObject: function getObject(name) {\n      return this.getBeeHive().getObject(name);\n    },\n    hasController: function hasController(name) {\n      return this.__controllers.has(name);\n    },\n    getController: function getController(name) {\n      return this.__controllers.get(name);\n    },\n    hasModule: function hasModule(name) {\n      return this.__modules.has(name);\n    },\n    getModule: function getModule(name) {\n      return this.__modules.get(name);\n    },\n    hasWidget: function hasWidget(name) {\n      return this.__widgets.has(name);\n    },\n    getWidgetRefCount: function getWidgetRefCount(name, prefix) {\n      var ds = this.__barbarianInstances[(prefix || 'widget:') + name];\n\n      if (ds) {\n        return ds.counter;\n      }\n\n      return -1;\n    },\n    incrRefCount: function incrRefCount(cat, name) {\n      var symbolicName = cat + ':' + name;\n\n      if (this.__barbarianInstances[symbolicName]) {\n        this.__barbarianInstances[symbolicName].counter++;\n      } else {\n        throw Error('Invalid operation' + symbolicName + ' is not initialized');\n      }\n    },\n    getWidget: function getWidget(name) {\n      var defer = $.Deferred();\n      var self = this;\n\n      if (arguments.length > 1) {\n        var w = {};\n        var promises = [];\n\n        _.each(arguments, function (x) {\n          var wName = x;\n          promises.push(self._getWidget(x).fail(function () {\n            console.error('Error loading: ' + x);\n\n            _.each(w, function (val, key) {\n              self.returnWidget(key);\n              delete w[key];\n            });\n\n            throw er;\n          }).done(function (widget) {\n            w[wName] = widget;\n          }));\n        });\n\n        $.when.apply($, promises).done(function () {\n          defer.resolve(w);\n        });\n      } else if (name) {\n        this._getWidget(name).done(function (widget) {\n          defer.resolve(widget);\n        });\n      } // this happens right after the callback\n\n\n      setTimeout(function () {\n        defer.done(function (widget) {\n          if (_.isArray(name)) {\n            _.each(name, function (x) {\n              self.returnWidget(x);\n            });\n          } else {\n            self.returnWidget(name);\n          }\n        });\n      }, 1);\n      return defer.promise();\n    },\n    _getWidget: function _getWidget(name) {\n      return this._getThing('widget', name); // returns a promise\n    },\n    _getThing: function _getThing(cat, name) {\n      var defer = $.Deferred();\n      var self = this;\n\n      this._lazyLoadIfNecessary(cat, name).done(function () {\n        var w = self._getOrCreateBarbarian(cat, name);\n\n        self.incrRefCount(cat, name);\n        defer.resolve(w);\n      });\n\n      return defer.promise();\n    },\n    returnWidget: function returnWidget(name) {\n      var ds = this.__barbarianInstances['widget:' + name]; // very rarely, a widget will want to be kept in memory\n\n      if (ds && ds.parent.dontKillMe) return;\n\n      if (ds) {\n        ds.counter--;\n\n        this._killBarbarian('widget:' + name);\n\n        return ds.counter;\n      }\n\n      return -1;\n    },\n    hasPlugin: function hasPlugin(name) {\n      return this.__plugins.has(name);\n    },\n\n    /**\n     * Increase the plugin counter and return the instance\n     * (already activated, with proper beehive in place)\n     *\n     * @param name\n     * @return {*}\n     */\n    getPlugin: function getPlugin(name) {\n      var defer = $.Deferred();\n      var self = this;\n      var w = {};\n\n      if (arguments.length > 1) {\n        w = {};\n\n        _.each(arguments, function (x) {\n          if (!x) return;\n\n          try {\n            w[x] = self._getPlugin(x);\n          } catch (er) {\n            console.error('Error loading: ' + x);\n\n            _.each(w, function (val, key) {\n              self.returnPlugin(key);\n              delete w[key];\n            });\n\n            throw er;\n          }\n        });\n      } else if (name) {\n        w = this._getPlugin(name);\n      }\n\n      setTimeout(function () {\n        defer.done(function (widget) {\n          if (_.isArray(name)) {\n            _.each(name, function (x) {\n              self.returnPlugin(x);\n            });\n          } else {\n            self.returnPlugin(name);\n          }\n        });\n      }, 1);\n      defer.resolve(w);\n      return defer.promise();\n    },\n    getPluginRefCount: function getPluginRefCount(name) {\n      return this.getWidgetRefCount(name, 'plugin:');\n    },\n    _getPlugin: function _getPlugin(name) {\n      return this._getThing('plugin', name);\n    },\n\n    /**\n     * Decrease the instance counter; when we reach zero\n     * the plugin will be destroyed automatically\n     *\n     * @param name\n     */\n    returnPlugin: function returnPlugin(name) {\n      var ds = this.__barbarianInstances['plugin:' + name];\n\n      if (ds) {\n        ds.counter--;\n\n        this._killBarbarian('plugin:' + name);\n\n        return ds.counter;\n      }\n\n      return -1;\n    },\n\n    /**\n     * Given the pubsub key, it finds the name of the widget\n     * (provided the widget is registered with the application)\n     * Returns undefined for other components, such as controllers\n     * objects etc (it searches only plugins and widgets)\n     *\n     * @param psk\n     * @returns {*}\n     */\n    getPluginOrWidgetName: function getPluginOrWidgetName(psk) {\n      if (!_.isString(psk)) throw Error('The psk argument must be a string');\n      var k;\n\n      if (this.__barbarianRegistry[psk]) {\n        k = this.__barbarianRegistry[psk];\n      } else {\n        return undefined;\n      }\n\n      return k;\n    },\n    getPluginOrWidgetByPubSubKey: function getPluginOrWidgetByPubSubKey(psk) {\n      var k = this.getPluginOrWidgetName(psk);\n      if (k === undefined) return undefined;\n      if (this._isBarbarianAlive(k)) return this._getBarbarian(k);\n      throw new Error('Eeeek, thisis unexpectEED bEhAvjor! Cant find barbarian with ID: ' + psk);\n    },\n    getPskOfPluginOrWidget: function getPskOfPluginOrWidget(symbolicName) {\n      var parts = symbolicName.split(':');\n      var psk;\n\n      if (this._isBarbarianAlive(symbolicName)) {\n        var b = this._getBarbarian(symbolicName);\n\n        if (b.getPubSub && b.getPubSub().getCurrentPubSubKey) return b.getPubSub().getCurrentPubSubKey().getId();\n      }\n\n      return psk;\n    },\n\n    /**\n     * I think the analogy is getting over-stretched; it is true that the author of this application\n     * loves history, and you could find many analogies...but let me hope that I would never treat\n     * humans in the same way I name variable names and methods :_)\n     *\n     * @param category\n     * @param name\n     * @private\n     */\n    _getOrCreateBarbarian: function _getOrCreateBarbarian(cat, name) {\n      var symbolicName = cat + ':' + name;\n\n      if (cat === 'plugin' && !this.hasPlugin(name) || cat === 'widget' && !this.hasWidget(name)) {\n        throw new Error('We cannot give you ' + symbolicName + ' (cause there is no constructor for it)');\n      }\n\n      if (this._isBarbarianAlive(symbolicName)) return this._getBarbarian(symbolicName);\n      var constructor = cat === 'plugin' ? this.__plugins.get(name) : this.__widgets.get(name);\n      var instance = new constructor();\n      var hardenedBee = this.getBeeHive().getHardenedInstance();\n      var children; // we'll monitor all new pubsub instances (created by the widget) - we don't want to rely\n      // on widgets to do the right thing (and tells us what children they made)\n\n      var pubsub = this.getService('PubSub');\n\n      var existingSubscribers = _.keys(pubsub._issuedKeys);\n\n      if ('activate' in instance) {\n        if (this.debug) {\n          console.log('application: ' + symbolicName + '.activate(beehive)');\n        }\n\n        children = instance.activate(hardenedBee);\n      }\n\n      var newSubscribers = _.without(_.keys(pubsub._issuedKeys), _.keys(pubsub._issuedKeys));\n\n      this._registerBarbarian(symbolicName, instance, children, hardenedBee, newSubscribers);\n\n      return instance;\n    },\n    _lazyLoadIfNecessary: function _lazyLoadIfNecessary(cat, name) {\n      var defer = $.Deferred();\n      var self = this;\n      var loader;\n      var placeholder;\n\n      if (cat === 'plugin') {\n        placeholder = self.__plugins;\n      } else if (cat === 'widget') {\n        placeholder = self.__widgets;\n      } else {\n        throw new Error(cat + ' cannot be lazy loaded, sorry');\n      }\n\n      var thing = placeholder.get(name);\n\n      if (typeof thing === 'undefined' || thing === null) {\n        defer.reject(name + ' does not exist');\n      } else if (thing && thing.lazyLoad) {\n        // load it\n        thing().done(function (cat, loadedModule) {\n          self._registerLoadedModules(cat, loadedModule);\n\n          defer.resolve();\n        });\n      } else {\n        // has already been loaded\n        defer.resolve();\n      }\n\n      return defer.promise();\n    },\n    _isBarbarianAlive: function _isBarbarianAlive(symbolicName) {\n      return !!this.__barbarianInstances[symbolicName];\n    },\n    _getBarbarian: function _getBarbarian(symbolicName) {\n      return this.__barbarianInstances[symbolicName].parent;\n    },\n    _registerBarbarian: function _registerBarbarian(symbolicName, instance, children, hardenedBee, illegitimateChildren) {\n      this._killBarbarian(symbolicName);\n\n      if ('getBeeHive' in instance) {\n        this.__barbarianRegistry[instance.getBeeHive().getService('PubSub').getCurrentPubSubKey().getId()] = symbolicName;\n      } else {\n        this.__barbarianRegistry[hardenedBee.getService('PubSub').getCurrentPubSubKey().getId()] = symbolicName;\n      }\n\n      var childNames = [];\n\n      if (children) {\n        childNames = this._registerBarbarianChildren(symbolicName, children);\n      }\n\n      if (illegitimateChildren) {\n        _.each(illegitimateChildren, function (childKey) {\n          if (this.__barbarianRegistry[childKey]) {\n            // already declared\n            delete illegitimateChildren[childKey];\n          }\n        }, this);\n      }\n\n      this.__barbarianInstances[symbolicName] = {\n        parent: instance,\n        children: childNames,\n        beehive: hardenedBee,\n        counter: 0,\n        psk: hardenedBee.getService('PubSub').getCurrentPubSubKey(),\n        bastards: illegitimateChildren // no, i'm not mean, i'm French\n\n      };\n    },\n\n    /**\n     *\n     * @param prefix\n     *  (String) the name of the father\n     * @param children\n     *  (Object) where keys are the 'strings' (names) and values are\n     *  instances (of the widgets)\n     * @return {Array}\n     * @private\n     */\n    _registerBarbarianChildren: function _registerBarbarianChildren(prefix, children) {\n      var childrenNames = [];\n\n      _.each(children, function (child, key) {\n        var name = prefix + '-' + (child.name || key);\n        if (this.debug) console.log('adding child object to registry: ' + name);\n\n        if (this._isBarbarianAlive(name)) {\n          throw new Error('Contract breach, there already exists instance with a name: ' + name);\n        }\n\n        if ('getBeeHive' in child) {\n          var childPubKey = child.getBeeHive().getService('PubSub').getCurrentPubSubKey().getId();\n          if (this.__barbarianRegistry[childPubKey]) throw new Error('Contract breach, the child of ' + prefix + 'is using the same pub-sub-key');\n          this.__barbarianRegistry[childPubKey] = name;\n        }\n\n        childrenNames.unshift(name);\n      }, this);\n\n      return childrenNames;\n    },\n\n    /**\n     * Remove/destroy the instance - but only if the counter reaches zero (or if the\n     * force parameter is true) - that means that the children are exterminated together\n     * with their parents. this is to avoid polluting the memory, because every child\n     * has a name of the parent. So if the parent is not used by anyone, then the\n     * counter is zero\n     *\n     * @param symbolicName\n     * @param force\n     * @private\n     */\n    _killBarbarian: function _killBarbarian(symbolicName, force) {\n      var b = this.__barbarianInstances[symbolicName];\n      if (!b) return;\n\n      if (b.counter > 0 && force !== true) {\n        // keep it alive, it is referenced somewhere else\n        return;\n      }\n\n      if (b.children) {\n        _.each(b.children, function (childName) {\n          this._killBarbarian(childName, true);\n        }, this);\n      }\n\n      _.each(this.__barbarianRegistry, function (value, key) {\n        if (value === symbolicName) delete this.__barbarianRegistry[key];\n      }, this); // unsubscribe this widget from pubsub (don't rely on the widget\n      // doing the right thing)\n\n\n      var pubsub = this.getService('PubSub');\n\n      if (b.psk) {\n        pubsub.unsubscribe(b.psk);\n      } // painstaikingly discover undeclared children and unsubscribe them\n\n\n      if (b.bastards && false) { var kmap; }\n\n      b.parent.destroy();\n      delete this.__barbarianInstances[symbolicName];\n      if ('setBeeHive' in b.parent) b.parent.setBeeHive({\n        fake: 'one'\n      });\n      b = null;\n      if (this.debug) console.log('Destroyed: ' + symbolicName);\n    },\n    getAllControllers: function getAllControllers() {\n      return _.pairs(this.__controllers.container);\n    },\n    getAllModules: function getAllModules() {\n      return _.pairs(this.__modules.container);\n    },\n    getAllPlugins: function getAllPlugins(key) {\n      key = key || 'plugin:';\n      var defer = $.Deferred();\n      var w = [];\n\n      _.each(this.__barbarianInstances, function (val, k) {\n        if (k.indexOf(key) > -1) w.unshift(k.replace(key, ''));\n      });\n\n      var getter = key.indexOf('plugin:') > -1 ? this.getPlugin : this.getWidget;\n      getter.apply(this, w).done(function (widget) {\n        var out = [];\n\n        if (w.length > 1) {\n          out = _.pairs(widget);\n        } else if (w.length === 1) {\n          out = [[w[0], widget]];\n        }\n\n        defer.resolve(out);\n      });\n      return defer.promise();\n    },\n    getAllWidgets: function getAllWidgets() {\n      return this.getAllPlugins('widget:');\n    },\n    getAllServices: function getAllServices() {\n      return this.getBeeHive().getAllServices();\n    },\n    getAllObjects: function getAllObjects() {\n      return this.getBeeHive().getAllObjects();\n    },\n\n    /**\n     * Helper method to invoke a 'function' on all objects\n     * that are inside the application\n     *\n     * @param funcName\n     * @param options\n     */\n    triggerMethodOnAll: function triggerMethodOnAll(funcName, options) {\n      this.triggerMethod(this.getAllControllers(), 'controllers', funcName, options);\n      this.triggerMethod(this.getAllModules(), 'modules', funcName, options);\n      var self = this;\n      this.getAllPlugins().done(function (plugins) {\n        if (plugins.length) self.triggerMethod(plugins, 'plugins', funcName, options);\n      });\n      this.getAllWidgets().done(function (widgets) {\n        if (widgets.length) self.triggerMethod(widgets, 'widgets', funcName, options);\n      });\n      this.triggerMethod(this.getBeeHive().getAllServices(), 'BeeHive:services', funcName, options);\n      this.triggerMethod(this.getBeeHive().getAllObjects(), 'BeeHive:objects', funcName, options);\n    },\n    triggerMethod: function triggerMethod(objects, msg, funcName, options) {\n      var self = this;\n\n      var rets = _.map(objects, function (el) {\n        var obj = el[1];\n\n        if (funcName in obj) {\n          if (self.debug) {\n            console.log('application.triggerMethod: ' + msg + ': ' + el[0] + '.' + funcName + '()');\n          }\n\n          obj[funcName].call(obj, options);\n        } else if (_.isFunction(funcName)) {\n          if (self.debug) {\n            console.log('application.triggerMethod: ' + msg + ': ' + el[0] + ' customCallback()');\n          }\n\n          funcName.call(obj, msg + ':' + el[0], options);\n        }\n      });\n\n      return rets;\n    }\n  }); // give it subclassing functionality\n\n\n  Application.extend = Backbone.Model.extend;\n  return Application.extend(ApiAccess);\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/application.js?");

/***/ }),

/***/ "./src/js/components/beehive.js":
/*!**************************************!*\
  !*** ./src/js/components/beehive.js ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Created by rchyla on 3/16/14.\n *\n * Beehive is where all the communication happens ('Application' object\n * is where setup happens; application will load beehive)\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! backbone */ \"./src/libs/backbone.js\"), __webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! js/components/generic_module */ \"./src/js/components/generic_module.js\"), __webpack_require__(/*! js/mixins/dependon */ \"./src/js/mixins/dependon.js\"), __webpack_require__(/*! js/mixins/hardened */ \"./src/js/mixins/hardened.js\"), __webpack_require__(/*! js/components/services_container */ \"./src/js/components/services_container.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Backbone, _, GenericModule, Dependon, Hardened, ServicesContainer) {\n  var hiveOptions = [];\n  var BeeHive = GenericModule.extend({\n    initialize: function initialize(options) {\n      _.extend(this, _.pick(options, hiveOptions));\n\n      this.Services = new ServicesContainer();\n      this.Objects = new ServicesContainer();\n      this.debug = false;\n      this.active = true;\n    },\n    activate: function activate() {\n      this.Services.activate.apply(this.Services, arguments);\n      this.Objects.activate(this);\n      this.active = true;\n    },\n    destroy: function destroy() {\n      this.Services.destroy(arguments);\n      this.Objects.destroy(arguments);\n      this.active = false;\n    },\n    getService: function getService(name) {\n      return this.Services.get(name);\n    },\n    hasService: function hasService(name) {\n      return this.Services.has(name);\n    },\n    addService: function addService(name, service) {\n      return this.Services.add(name, service);\n    },\n    removeService: function removeService(name) {\n      return this.Services.remove(name);\n    },\n    getObject: function getObject(name) {\n      return this.Objects.get(name);\n    },\n    hasObject: function hasObject(name) {\n      return this.Objects.has(name);\n    },\n    addObject: function addObject(name, service) {\n      return this.Objects.add(name, service);\n    },\n    removeObject: function removeObject(name) {\n      return this.Objects.remove(name);\n    },\n    getDebug: function getDebug() {\n      return this.debug;\n    },\n    getAllServices: function getAllServices() {\n      return this.Services.getAll();\n    },\n    getAllObjects: function getAllObjects() {\n      return this.Objects.getAll();\n    },\n\n    /*\n     * Wraps itself into a Facade that can be shared with other modules\n     * (it is read-only); absolutely non-modifiable and provides the\n     * following callbacks and properties:\n     *  - Services\n     */\n    hardenedInterface: {\n      Services: 'services container',\n      Objects: 'objects container',\n      debug: 'state of the app',\n      active: 'active or not',\n      getHardenedInstance: 'allow to create clone of the already hardened instance'\n    }\n  });\n\n  _.extend(BeeHive.prototype, Hardened, {\n    getHardenedInstance: function getHardenedInstance(iface) {\n      iface = _.clone(iface || this.hardenedInterface); // because 'facade' functions are normally bound to the\n      // original object, we have to do this to access 'facade'\n\n      iface.getService = function (name) {\n        // 'get service X (but only the hardened ones)',\n        return hardened.Services.get(name);\n      };\n\n      iface.hasService = function (name) {\n        return hardened.Services.has(name);\n      };\n\n      iface.getObject = function (name) {\n        // 'get object X (but only the hardened ones)',\n        return hardened.Objects.get(name);\n      };\n\n      iface.hasObject = function (name) {\n        return hardened.Objects.has(name);\n      };\n\n      var hardened = this._getHardenedInstance(iface, this);\n\n      return hardened;\n    }\n  });\n\n  return BeeHive;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/beehive.js?");

/***/ }),

/***/ "./src/js/components/default_request.js":
/*!**********************************************!*\
  !*** ./src/js/components/default_request.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Created by rchyla on 3/28/14.\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! backbone */ \"./src/libs/backbone.js\"), __webpack_require__(/*! js/components/api_query */ \"./src/js/components/api_query.js\"), __webpack_require__(/*! js/components/multi_params */ \"./src/js/components/multi_params.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, Backbone, ApiQuery, MultiParams) {\n  var basicCheck = function basicCheck(s) {\n    if (_.isString(s)) {\n      return true;\n    }\n\n    if (_.isArray(s)) {\n      var l = s.length;\n\n      for (var i = 0; i < l; i++) {\n        var x = s[i];\n\n        if (!(_.isString(x) || _.isNumber(x))) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n\n  var allowedAttrs = {\n    query: function query(v) {\n      if (_.isUndefined(v)) {\n        return true;\n      }\n\n      return v instanceof ApiQuery;\n    },\n    target: basicCheck,\n    sender: basicCheck,\n    options: basicCheck\n  };\n  var checker = {\n    target: function target(s) {\n      if (s && s.substring(0, 1) !== '/') {\n        return '/' + s;\n      }\n    }\n  };\n  var Request = MultiParams.extend({\n    /**\n     * Internal method: we allow only certain keys\n     *\n     * @param attributes\n     * @param options\n     * @returns {boolean}\n     * @private\n     */\n    _validate: function _validate(attributes, options) {\n      _.forOwn(attributes, function (val, attr) {\n        var tempVal = attributes[attr];\n\n        if (!(attr in allowedAttrs)) {\n          throw new Error('Invalid attr: ' + attr);\n        }\n\n        if (!allowedAttrs[attr].call(allowedAttrs, tempVal)) {\n          throw new Error('Invalid value:key ' + attr + tempVal);\n        }\n      });\n\n      return true;\n    },\n\n    /**\n     * Modified version of the multi-valued set(); we do not insist\n     * on having the values in array\n     *\n     * @param key\n     * @param val\n     * @param options\n     * @returns {Request}\n     */\n    set: function set(key, val, options) {\n      this._checkLock();\n\n      var attrs;\n      if (key == null) return this; // Handle both `\"key\", value` and `{key: value}` -style arguments.\n\n      if (_typeof(key) === 'object') {\n        attrs = key;\n        options = val;\n      } else {\n        (attrs = {})[key] = val;\n      }\n\n      Backbone.Model.prototype.set.call(this, attrs, options);\n    },\n    // for requests, we use all components: path, query, hash\n    _checkParsed: function _checkParsed(attrs) {\n      if (_.isObject(attrs)) {\n        var ret = {};\n\n        if ('#query' in attrs && !_.isEmpty(attrs['#query'])) {\n          ret.query = new ApiQuery(attrs['#query']);\n        }\n\n        if ('#path' in attrs) {\n          ret.target = attrs['#path'][0];\n        }\n\n        if ('#hash' in attrs) {\n          _.extend(ret, _.each(attrs['#hash'], function (val, key, obj) {\n            if (val.length == 1) {\n              obj[key] = val[0];\n            }\n          }));\n        }\n\n        return ret;\n      }\n\n      return attrs;\n    },\n\n    /*\n     * Return the url string encoding all parameters that made\n     * this request. The parameters will be sorted alphabetically\n     * by their keys and URL encoded so that they can be used\n     * in requests.\n     */\n    url: function url(whatToSort) {\n      if (!whatToSort) {\n        whatToSort = this.attributes;\n      }\n\n      var target = whatToSort.target;\n      var url = target ? _.isArray(target) ? target.join('/') : target : '';\n\n      if ('query' in whatToSort) {\n        url += '?' + whatToSort.query.url();\n      }\n\n      if ('sender' in whatToSort) {\n        url += '#' + MultiParams.prototype.url.call(this, {\n          sender: whatToSort.sender\n        });\n      }\n\n      return url;\n    },\n\n    /**\n     * Re-constructs the query from the url string, returns the json attributes;\n     * cannot be used it the instance is locked\n     *\n     * @param query (String)\n     * @returns {Model}\n     */\n    load: function load(query) {\n      return MultiParams.prototype.load.call(this, query.indexOf('?') > -1 ? query : query + '?');\n    }\n  });\n  return Request;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/default_request.js?");

/***/ }),

/***/ "./src/js/components/facade.js":
/*!*************************************!*\
  !*** ./src/js/components/facade.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Created by rchyla on 3/16/14. inspiration: http://jsfiddle.net/pajtai/GD5qR/35/\n */\n\n/*\n * // Interface\n *  var remoteInterface = {\n *    on: 'turn on'\n *  };\n *  // Implementation\n *  var htmlRemote = {\n *    on: function() { console.log(\"remote on\"); return this; }\n *  };\n *  // Protecting the implementation\n *  var htmlInterface = new Facade(remoteInterface, htmlRemote);\n *\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! js/components/facade */ \"./src/js/components/facade.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, Facade) {\n  // The Facade encapsulates objectIn according to the description\n  // The exposed facade is guaranteed to have exactly the functions described in description.\n  var Facade = function Facade(description, objectIn) {\n    var facade; // TODO: add enforce of \"new\"\n\n    facade = {};\n    this.mixIn(description, objectIn, facade); // TODO: check that \"mixIn\" is not taken\n\n    facade.mixIn = this.mixIn;\n    return facade;\n  };\n\n  Facade.prototype.mixIn = function (description, objectIn, facade) {\n    var property;\n    var propertyValue;\n    facade = facade || this;\n\n    for (property in description) {\n      propertyValue = description[property];\n\n      if (property in objectIn) {\n        var p = objectIn[property];\n\n        if (typeof propertyValue === 'function') {\n          // redefining the method\n          facade[property] = _.bind(propertyValue, objectIn);\n        } else if (typeof p === 'function') {\n          // exposing the method\n          facade[property] = _.bind(p, objectIn);\n        } else if (_.isUndefined(p)) {// pass\n        } else if (_.isString(p) || _.isNumber(p) || _.isBoolean(p) || _.isDate(p) || _.isNull(p) || _.isRegExp(p)) {\n          // build getter method\n          facade['get' + property.substring(0, 1).toUpperCase() + property.substring(1)] = _.bind(function () {\n            return this.ctx[this.name];\n          }, {\n            ctx: objectIn,\n            name: property\n          });\n          facade[property] = p; // copy the value (it is immutable anyways)\n        } else if (p.hasOwnProperty('__facade__') && p.__facade__) {\n          // exposing internal facade\n          facade[property] = p;\n        } else if (_.isObject(p) && 'getHardenedInstance' in p) {\n          // builds a facade\n          facade[property] = p.getHardenedInstance();\n        } else {\n          throw new Error(\"Sorry, you can't wrap '\" + property + \"': \" + p);\n        }\n      } else if (typeof propertyValue === 'function') {\n        facade[property] = _.bind(propertyValue, objectIn);\n      } else {\n        throw new Error('Unknown key: ' + property + '(' + propertyValue + ')');\n      }\n    }\n\n    if (objectIn) {\n      // .name is not supported in IE\n      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n      facade.__facade__ = Boolean(objectIn.constructor ? objectIn.constructor.name ? objectIn.constructor.name : true : true);\n    } else {\n      facade.__facade__ = true;\n    } // TODO:rca - shall we use?\n    // if (Object.freeze)\n    //  facade = Object.freeze(facade);\n\n\n    return facade;\n  };\n\n  return Facade;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/facade.js?");

/***/ }),

/***/ "./src/js/components/generic_module.js":
/*!*********************************************!*\
  !*** ./src/js/components/generic_module.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * A generic class to be used for building modules (the Marionette.Module)\n * just complicates things. For simple things, just use this class.\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! backbone */ \"./src/libs/backbone.js\"), __webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Backbone, _) {\n  // A list of options to be attached directly to the module, if provided.\n  var moduleOptions = ['className', 'activate'];\n\n  var Module = function Module(options) {\n    var defaults;\n    options = options || {};\n    this.mid = _.uniqueId('module');\n\n    _.extend(this, _.pick(options, moduleOptions));\n\n    this.initialize.call(this, options);\n  }; // every module has the Events mixin\n\n\n  _.extend(Module.prototype, Backbone.Events, {\n    className: 'GenericModule',\n    initialize: function initialize() {},\n    destroy: function destroy() {},\n    activate: function activate(options) {\n      _.extend(this, _.pick(options, moduleOptions));\n    }\n  }); // give the module subclassing functionality\n\n\n  Module.extend = Backbone.Model.extend;\n  return Module;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/generic_module.js?");

/***/ }),

/***/ "./src/js/components/multi_params.js":
/*!*******************************************!*\
  !*** ./src/js/components/multi_params.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*\n multi_params is a generic class to store any parameters;\n it is backed by BB.Model and has all the functionality\n the values are always stored as an array of values; so\n even if you try to set strings, you will always have\n list of strings\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! backbone */ \"./src/libs/backbone.js\"), __webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! jquery */ \"./src/libs/jquery.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Backbone, _, $) {\n  var Model = Backbone.Model.extend({\n    locked: false,\n    _checkLock: function _checkLock() {\n      if (this.locked === true) {\n        throw Error('Object locked for modifications');\n      }\n    },\n    isLocked: function isLocked() {\n      return this.locked;\n    },\n    lock: function lock() {\n      this.locked = true;\n    },\n    unlock: function unlock() {\n      this.locked = false;\n    },\n    clone: function clone() {\n      if (this.isLocked()) {\n        var c = new this.constructor(this.attributes);\n        c.lock();\n        return c;\n      }\n\n      return new this.constructor(this.attributes);\n    },\n    hasVal: function hasVal(key) {\n      return !_.isEmpty(this.get(key));\n    },\n    // we allow only strings and numbers; instead of sending\n    // signal we throw a direct error\n    _validate: function _validate(attributes, options) {\n      // check we have only numbers and/or finite numbers\n      for (var attr in attributes) {\n        if (!_.isString(attr)) {\n          throw new Error('Keys must be strings, not: ' + attr);\n        } // remove empty strings\n\n\n        var tempVal = attributes[attr];\n        tempVal = _.without(_.flatten(tempVal), '', false, null, undefined, NaN);\n\n        if (!_.isArray(tempVal)) {\n          throw new Error('Values were not converted to an Array');\n        }\n\n        if (_.isEmpty(tempVal) && options.unset !== true) {\n          throw new Error('Empty values not allowed');\n        }\n\n        if (!_.every(tempVal, function (v) {\n          return _.isString(v) || _.isNumber(v) && !_.isNaN(v);\n        })) {\n          throw new Error('Invalid value (not a string or number): ' + tempVal);\n        }\n\n        attributes[attr] = tempVal;\n      }\n\n      return true;\n    },\n    // Every value is going to be multi-valued by default\n    // in this way we can treat all objects in the same way\n    set: function set(key, val, options) {\n      this._checkLock();\n\n      var attrs;\n      if (key == null) return this; // Handle both `\"key\", value` and `{key: value}` -style arguments.\n\n      if (_typeof(key) === 'object') {\n        attrs = key;\n        options = val;\n      } else {\n        (attrs = {})[key] = val;\n      }\n\n      for (var attr in attrs) {\n        var tempVal = attrs[attr]; // convert to array if necessary\n\n        if (!_.isArray(tempVal)) {\n          attrs[attr] = _.flatten([tempVal]);\n        }\n      }\n\n      Backbone.Model.prototype.set.call(this, attrs, options);\n    },\n    unset: function unset() {\n      this._checkLock();\n\n      Backbone.Model.prototype.unset.apply(this, arguments);\n    },\n    // adds values to existing (like set, but keeps the old vals)\n    add: function add(key, val, options) {\n      this._checkLock();\n\n      var attrs;\n      if (key == null) return this; // Handle both `\"key\", value` and `{key: value}` -style arguments.\n\n      if (_typeof(key) === 'object') {\n        attrs = key;\n        options = val;\n      } else {\n        (attrs = {})[key] = val;\n      }\n\n      for (var attr in attrs) {\n        var tempVal = attrs[attr]; // convert to array if necessary\n\n        if (!_.isArray(tempVal)) {\n          tempVal = _.flatten([tempVal]);\n        }\n\n        if (this.has(attr)) {\n          tempVal = _.clone(this.get(attr)).concat(tempVal);\n        }\n\n        attrs[attr] = tempVal;\n      }\n\n      Backbone.Model.prototype.set.call(this, attrs, options);\n    },\n    // synchronization is disabled\n    sync: function sync() {\n      throw Error('MultiParams cannot be saved to server');\n    },\n\n    /*\n     * Return the url string encoding all parameters that made\n     * this query. The parameters will be sorted alphabetically\n     * by their keys and URL encoded so that they can be used\n     * in requests.\n     */\n    url: function url(whatToSort) {\n      if (!whatToSort) {\n        whatToSort = this.attributes;\n      } // sort keys alphabetically\n\n\n      var sorted = _.pairs(whatToSort).sort(function (a, b) {\n        return a[0] > b[0] ? 1 : a[0] < b[0] ? -1 : 0;\n      }); // June1:rca - I need to preserve order of values (becuaes of the query modifications/updates) the logic\n      // just requires us to be careful and we need order to be preserved when the query is cloned\n      // also sort values\n      // var s = {};\n      // sorted.map(function(item) { s[item[0]] = (_.isArray(item[1]) ? item[1].sort() : item[1]) });\n      // we have to double encode certain elements\n      // sorted = _.map(sorted, function(pair) { return [pair[0], _.map(pair[1], function(v) {return (v.indexOf && v.indexOf('=') > -1) ? encodeURIComponent(v) : v })]});\n      // use traditional encoding\n      // use %20 instead of + (url encoding instead of form encoding)\n\n\n      var encoded = $.param(_.object(sorted), true);\n      encoded = encoded.replace(/\\+/g, '%20'); // Replace funky unicode quotes with normal ones\n\n      encoded = encoded.replace(/%E2%80%9[ECD]/g, '%22');\n      return encoded;\n    },\n\n    /**\n     * Parses string (urlparams) and returns it as an object\n     * @param resp\n     * @param options\n     * @returns {*}\n     */\n    parse: function parse(resp, options) {\n      if (_.isString(resp)) {\n        var attrs = {};\n        resp = decodeURI(resp);\n\n        if (resp.indexOf('?') > -1) {\n          attrs['#path'] = [resp.slice(0, resp.indexOf('?'))];\n          resp = resp.slice(resp.indexOf('?') + 1);\n        }\n\n        if (resp.indexOf('#') > -1) {\n          attrs['#hash'] = this._parse(resp.slice(resp.indexOf('#') + 1));\n          resp = resp.slice(0, resp.indexOf('#'));\n        }\n\n        attrs['#query'] = this._parse(resp);\n        return this._checkParsed(attrs);\n      }\n\n      return this._checkParsed(resp); // else return resp object\n    },\n    _parse: function _parse(resp) {\n      var attrs = {};\n      var hash;\n\n      if (!resp.trim()) {\n        return attrs;\n      }\n\n      var hashes = resp.slice(resp.indexOf('?') + 1).split('&'); // resp = decodeURIComponent(resp);\n\n      var key;\n      var value;\n\n      for (var i = 0; i < hashes.length; i++) {\n        hash = hashes[i].split('=');\n        key = decodeURIComponent(hash[0].split('+').join(' ')); // optimized: .replace(/\\+/g, \" \")\n\n        var vall = hash[1];\n\n        if (hash.length > 2) {\n          hash.shift();\n          vall = hash.join('=');\n        } // replace literal '%' with code and '+' become literal spaces\n\n\n        value = decodeURIComponent(vall.replace(/%(?!\\d|[ABCDEF]+)/gi, '%25').split('+').join(' '));\n\n        if (attrs[key] !== undefined) {\n          attrs[key].push(value);\n        } else {\n          attrs[key] = [value];\n        }\n      }\n\n      return attrs;\n    },\n    // default behaviour is just to keep the query parameters\n    // after the string was parsed, you can override it to suit other needs\n    _checkParsed: function _checkParsed(attrs) {\n      if (_.isObject(attrs)) {\n        if ('#query' in attrs) {\n          return attrs['#query'];\n        }\n      }\n\n      return attrs;\n    },\n\n    /**\n     * Re-constructs the query from the url string, returns the json attributes;\n     * cannot be used it the instance is locked\n     *\n     * @param query (String)\n     * @returns {Model}\n     */\n    load: function load(query) {\n      this._checkLock();\n\n      var vals = this.parse(query);\n      this.clear();\n      this.set(vals);\n      return this;\n    }\n  });\n  return Model;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/multi_params.js?");

/***/ }),

/***/ "./src/js/components/pubsub_events.js":
/*!********************************************!*\
  !*** ./src/js/components/pubsub_events.js ***!
  \********************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Created by rchyla on 3/30/14.\n */\n\n/**\n * Catalogue of PubSub events; we assume this:\n *\n *  - FC = the component lives in the 'Forbidden City'\n *         inside Application, typically this is a PubSub or Api, Mediator\n *         or any component with elevated access\n *\n *  - OC = Outer City: the suburbs of the application; these are typically\n *         UI components (behind the wall), untrusted citizens of the\n *         BumbleBee state\n *\n *  WARNING: do not use spaces; events with spaces are considered to be\n *        multiple events! (e.g. '[PubSub] New-Query' will be two events)\n *\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n  var PubSubEvents = {\n    /**\n     * Usually called by OC's as a first step in the query processing.\n     * It means: 'user did something', we need to start reacting. The OC\n     * will build a new ApiQuery and send it together with this event\n     */\n    START_SEARCH: '[PubSub]-New-Query',\n\n    /**\n     * Called by FC's (usually: Mediator) - this is a signal to *all* OC's\n     * they should receive ApiQuery object, compare it against their\n     * own query; find diff and create a new ApiRequest (asking for a data)\n     * and send that back\n     */\n    INVITING_REQUEST: '[PubSub]-Inviting-Request',\n\n    /**\n     * Will be called by OC's, this is response to ApiQuery input.\n     */\n    DELIVERING_REQUEST: '[PubSub]-New-Request',\n\n    /**\n     * Will be called by OC's, this is one-time forget action (outside of the\n     * the search cycle); use this for any query that needs to be executed\n     * and not be tracked by search cycle\n     */\n    EXECUTE_REQUEST: '[PubSub]-Execute-Request',\n\n    /**\n     * Called from the router, the QID will be passed; the query needs to be\n     * loaded and executed\n     */\n    EXECUTE_STORED_QUERY: '[PubSub]-Execute-Stored-Query',\n\n    /**\n     * Published by FC's - typically Mediator - when a response has been retrieved\n     * for a given ApiRequest.\n     *\n     * OC's should subscribe to this event when they want to receive data\n     * from the treasury (api)\n     *\n     *  - input: ApiRequest\n     *  - output: ApiResponse\n     */\n    DELIVERING_RESPONSE: '[PubSub]-New-Response',\n\n    /**\n     * The walls of the FC are being closed; and no new requests will be served\n     */\n    CLOSING_GATES: '[PubSub]-Closing',\n\n    /**\n     * PubSub will not receive any requests any more\n     */\n    CLOSED_FOR_BUSINESS: '[PubSub]-Closed',\n\n    /**\n     * ForbiddenCity is about to receive requests\n     */\n    OPENING_GATES: '[PubSub]-Opening',\n\n    /**\n     * Called after PubSub became ready - it is fully operational\n     */\n    OPEN_FOR_BUSINESS: '[PubSub]-Ready',\n\n    /**\n     *  Set of error warnings issues by PubSub - or by some other FC's - to\n     *  deal with congestion or other problems\n     */\n    SMALL_FIRE: '[PubSub]-Problem',\n    BIG_FIRE: '[PubSub]-Big-Problem',\n    CITY_BURNING: '[PubSub]-Disaster',\n\n    /**\n     * A message containing feedback from the FC; traveling towards OC\n     * The feedback will be instance of ApiFeedback\n     */\n    FEEDBACK: '[FC]-FeedBack',\n\n    /**\n     * A message from the router requesting showing citizens of the\n     * city\n     */\n    DISPLAY_DOCUMENTS: '[Router]-Display-Documents',\n    DISPLAY_DOCUMENTS_DETAILS: '[Router]-Display-Documents-Details',\n\n    /**\n     * Used by OC to request parsed query tree - to check a query\n     * for example\n     */\n    GET_QTREE: '[FC]-GetQTree',\n    NAVIGATE: '[Router]-Navigate-With-Trigger',\n\n    /*\n     * so navigator can notify interested widgets about a change\n     * from search page to user page, for instance-- navigator cannot\n     * to this since it listens to many events including widget-show events\n     * */\n    PAGE_CHANGE: '[Navigator]Page-Changed',\n\n    /* for custom widget-to-widget events */\n    CUSTOM_EVENT: '[PubSub]-Custom-Event',\n    ARIA_ANNOUNCEMENT: '[PubSub]-Aria-Announcement',\n\n    /* anything to do with changing the state of the user, including session events */\n    USER_ANNOUNCEMENT: '[PubSub]-User-Announcement',\n\n    /**\n     * A message/action that should be displayed to the user (on prominent)\n     * place\n     */\n    ALERT: '[Alert]-Message',\n    ORCID_ANNOUNCEMENT: '[PubSub]-Orcid-Announcement',\n\n    /**\n     * Happens during the main cycle of the application birth\n     *  LOADED = when all components were successfuly loaded\n     *  BOOTSTRAPPED = + when all dynamic config was loaded\n     *  STARTING = + right before the router and history objects start()\n     *  STARTED = app is alive and handling requests\n     */\n    APP_LOADED: '[App]-Application-Loaded',\n    APP_BOOTSTRAPPED: '[App]-Application-Bootstrapped',\n    APP_STARTING: '[App]-Application-Starting',\n    APP_STARTED: '[App]-Application-Started',\n    APP_EXIT: '[App]-Exit',\n\n    /**\n     * Is triggered when user selects/deselects records\n     */\n    PAPER_SELECTION: '[User]-Paper-Selection',\n    // instead of toggling, adds all papers\n    BULK_PAPER_SELECTION: '[User]-Bulk-Paper-Selection',\n\n    /*\n     * is triggered by app storage itself when list of selected papers changes\n     * */\n    STORAGE_PAPER_UPDATE: '[User]-Paper-Update',\n    LIBRARY_CHANGE: '[PubSub]-Library-Change'\n  };\n  return PubSubEvents;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/pubsub_events.js?");

/***/ }),

/***/ "./src/js/components/pubsub_key.js":
/*!*****************************************!*\
  !*** ./src/js/components/pubsub_key.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Created by rchyla on 3/14/14.\n */\n\n/*\n * A simple, yet important, class - every subscriber\n * to the PubSub must contain one key. This class\n * should be instantiated in a safe manner. ie.\n *\n * PubSubKey.newInstance({creator: this});\n *\n * But beware that as long as the subscriber is alive\n * reference to the creator will be saved inside\n * the key! So choose carefully whether you use this\n * functionality\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_) {\n  var PubSubKey = function PubSubKey(options) {\n    _.extend(this, options);\n  };\n\n  _.extend(PubSubKey, {\n    /*\n     * Creates a new Instances of the PubSubKey\n     * with a storage that cannot be changed.\n     * To double sign the key, you can pass\n     * an object that identifies creator of the\n     * key and test identity, eg.\n     *\n     * var creator = {};\n     * var k = PubSubKey(creator);\n     * k.getCreator() === k;\n     *\n     */\n    newInstance: function newInstance(options) {\n      var priv = {\n        id: _.has(options, 'id') ? options.id : _.uniqueId(':psk'),\n        creator: _.has(options, 'creator') ? options.creator : null\n      };\n      return new PubSubKey({\n        getId: function getId() {\n          return priv.id;\n        },\n        getCreator: function getCreator() {\n          return priv.creator;\n        }\n      });\n    }\n  });\n\n  return PubSubKey;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/pubsub_key.js?");

/***/ }),

/***/ "./src/js/components/services_container.js":
/*!*************************************************!*\
  !*** ./src/js/components/services_container.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Created by rchyla on 3/18/14.\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! js/components/facade */ \"./src/js/components/facade.js\"), __webpack_require__(/*! js/components/generic_module */ \"./src/js/components/generic_module.js\"), __webpack_require__(/*! js/mixins/hardened */ \"./src/js/mixins/hardened.js\"), __webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Facade, GenericModule, Hardened, _) {\n  var Services = GenericModule.extend({\n    initialize: function initialize(options) {\n      this._services = _.has(options, 'services') ? _.clone(options.services) : {};\n    },\n    activate: function activate() {\n      var args = arguments;\n\n      _.each(_.values(this._services), function (service) {\n        // _.keys() preserves access order\n        if (_.isObject(service) && 'activate' in service) {\n          service.activate.apply(service, args);\n        }\n      });\n    },\n    destroy: function destroy() {\n      for (var service in this._services) {\n        this.remove(service);\n      }\n    },\n    add: function add(name, service) {\n      if (this._services.hasOwnProperty(name)) {\n        throw new Error('The service: ' + name + ' is already registered, remove it first!');\n      }\n\n      if (!(name && service) || !_.isString(name)) {\n        throw new Error('The key must be a string and the service is an object');\n      }\n\n      this._services[name] = service;\n    },\n    remove: function remove(name, service) {\n      if (this._services.hasOwnProperty(name)) {\n        var s = this._services[name];\n\n        if ('destroy' in s) {\n          s.destroy();\n        }\n\n        delete this._services[name];\n        return s;\n      }\n\n      return null;\n    },\n    has: function has(name) {\n      return this._services.hasOwnProperty(name);\n    },\n    get: function get(name) {\n      return this._services[name];\n    },\n    getAll: function getAll() {\n      return _.pairs(this._services);\n    }\n  });\n\n  _.extend(Services.prototype, Hardened, {\n    /*\n     * A simple facade, we'll expose only services that\n     * have 'getHardenedMethod' (ie. they know to protect\n     * themselves)\n     */\n    getHardenedInstance: function getHardenedInstance() {\n      var iface = {};\n      var s;\n\n      for (var service in this._services) {\n        s = this._services[service];\n\n        if (_.isObject(s) && 'getHardenedInstance' in s) {\n          iface[service] = true;\n        }\n      }\n\n      var newContainer = new this.constructor({\n        services: this._getHardenedInstance(iface, this._services)\n      });\n      return this._getHardenedInstance({\n        get: true,\n        has: true\n      }, newContainer);\n    }\n  });\n\n  return Services;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/services_container.js?");

/***/ }),

/***/ "./src/js/components/solr_params.js":
/*!******************************************!*\
  !*** ./src/js/components/solr_params.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\nSubclass of the multi-param with a functionality specific for\nSOLR queries. Do not use this class directly inside your app!\nInstead, import 'api_query' and configure it properly\n\n * <p>For a list of possible parameters, please consult the links below.</p>\n *\n * @see http://wiki.apache.org/solr/CoreQueryParameters\n * @see http://wiki.apache.org/solr/CommonQueryParameters\n * @see http://wiki.apache.org/solr/SimpleFacetParameters\n * @see http://wiki.apache.org/solr/HighlightingParameters\n * @see http://wiki.apache.org/solr/MoreLikeThis\n * @see http://wiki.apache.org/solr/SpellCheckComponent\n * @see http://wiki.apache.org/solr/StatsComponent\n * @see http://wiki.apache.org/solr/TermsComponent\n * @see http://wiki.apache.org/solr/TermVectorComponent\n * @see http://wiki.apache.org/solr/LocalParams\n *\n * @param properties A map of fields to set. Refer to the list of public fields.\n * @class ParameterStore\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! js/components/multi_params */ \"./src/js/components/multi_params.js\"), __webpack_require__(/*! backbone */ \"./src/libs/backbone.js\"), __webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! jquery */ \"./src/libs/jquery.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (MultiParams, Backbone, _, $) {\n  var SolrParams = MultiParams.extend({\n    fieldsToConcatenate: [],\n    defaultOperator: ' ',\n    fieldProcessors: {\n      '*': function _(vals, self) {\n        return [vals.join(self.defaultOperator)];\n      }\n    },\n    initialize: function initialize(attributes, options) {\n      if (options) {\n        _.extend(this, _.pick(options, ['fieldsToConcatenate', 'defaultOperator', 'fieldProcessors']));\n      }\n    },\n    url: function url(resp, options) {\n      // first massage the fields, but do not touch the original values\n      // lodash has a parameter isDeep that can be set to true, but\n      // for compatibility reasons with underscore, lets' not use it\n      // the values should always be only one level deep\n      var values = _.clone(this.attributes);\n\n      var l = this.fieldsToConcatenate.length;\n      var k = '';\n\n      for (var i = 0; i < l; i++) {\n        k = this.fieldsToConcatenate[i];\n\n        if (this.has(k)) {\n          if (this.fieldProcessors[k]) {\n            values[k] = this.fieldProcessors[k](this.get(k), this);\n          } else {\n            values[k] = this.fieldProcessors['*'](this.get(k), this);\n          }\n        }\n      } // then call the default implementation of the url handling\n\n\n      return MultiParams.prototype.url.call(this, values);\n    }\n  });\n  return SolrParams;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/components/solr_params.js?");

/***/ }),

/***/ "./src/js/mixins/api_access.js":
/*!*************************************!*\
  !*** ./src/js/mixins/api_access.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! backbone */ \"./src/libs/backbone.js\"), __webpack_require__(/*! js/components/api_query */ \"./src/js/components/api_query.js\"), __webpack_require__(/*! js/components/api_request */ \"./src/js/components/api_request.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, Backbone, ApiQuery, ApiRequest) {\n  /*\n   * this simple mixin contacts the api (getApiAccess), and if the {reconnect: true} option\n   * is passed to getApiAccess, will save the relevant data.\n   * */\n  return {\n    /**\n     * After bootstrap receives all data, this routine should decide what to do with\n     * them\n     */\n    onBootstrap: function onBootstrap(data) {\n      var beehive = this.getBeeHive(); // set the API key and other data from bootstrap\n\n      if (data.access_token) {\n        beehive.getService('Api').setVals({\n          access_token: \"\".concat(data.token_type, \" \").concat(data.access_token),\n          refresh_token: data.refresh_token,\n          expires_at: data.expires_at\n        });\n        console.warn('Redefining access_token: ' + data.access_token);\n        var userObject = beehive.getObject('User');\n        var userName = data.anonymous ? undefined : data.username;\n        userObject.setUser(userName);\n        var storage = beehive.getService('PersistentStorage');\n        storage && storage.set && storage.set('appConfig', data);\n      } else {\n        console.warn(\"bootstrap didn't provide access_token!\");\n      }\n    },\n    getApiAccess: function getApiAccess(options) {\n      options = options || {};\n      var api = this.getBeeHive().getService('Api');\n      var self = this;\n      var defer = $.Deferred(); // if token expired, make a _request\n\n      var request = options.tokenRefresh ? '_request' : 'request';\n      api[request](new ApiRequest({\n        query: new ApiQuery(),\n        target: this.bootstrapUrls ? this.bootstrapUrls[0] : '/accounts/bootstrap'\n      }), {\n        done: function done(data) {\n          window.getSentry(function (sentry) {\n            sentry.setUser({\n              id: data.access_token,\n              anonymous: data.anonymous\n            });\n          });\n\n          if (options.reconnect) {\n            self.onBootstrap(data);\n          }\n\n          defer.resolve(data);\n        },\n        fail: function fail() {\n          defer.reject.apply(defer, arguments);\n        },\n        type: 'GET'\n      });\n      return defer;\n    }\n  };\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/mixins/api_access.js?");

/***/ }),

/***/ "./src/js/mixins/dependon.js":
/*!***********************************!*\
  !*** ./src/js/mixins/dependon.js ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Created by rchyla on 3/13/14.\n */\n\n/*\n * This module contains a set of utilities that can be added to classes\n * to give them certain functionality\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! js/components/pubsub_events */ \"./src/js/components/pubsub_events.js\"), __webpack_require__(/*! js/components/pubsub_key */ \"./src/js/components/pubsub_key.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, PubSubEvents, PubSubKey) {\n  var Mixin = {\n    /*\n     * BeeHive is the object that allows modules to get access to objects\n     * of the application (but we make sure these objects are protected\n     * and only application can set/change them). This mixin gives objects\n     * functions to query 'BeeHive'\n     */\n    BeeHive: {\n      // called by parents (app) to give modules access\n      setBeeHive: function setBeeHive(brundibar) {\n        if (_.isEmpty(brundibar)) throw new Error('Huh? Empty Beehive? Trying to be funny?');\n        this.__beehive = brundibar;\n      },\n      getBeeHive: function getBeeHive() {\n        if (!this.hasBeeHive()) throw new Error('The BeeHive is inactivate (or dead :<})');\n        return this.__beehive;\n      },\n      hasBeeHive: function hasBeeHive() {\n        if (this.__beehive && (this.__beehive.active || this.__beehive.__facade__ && this.__beehive.getActive())) {\n          return true;\n        }\n\n        return false;\n      },\n\n      /**\n       * Method which returns a masked instance of PubSub (unless the PubSub\n       * is already a hardened instance; which carries its own key)\n       *\n       * You can call pubsub.publish() without having to supply the pubsub key\n       * (which is what most controllers want to do; there are only some\n       * exceptions to this rule; ie. query-mediator). If you need to get\n       * access to the full PubSub (and you have it inside BeeHive) then do\n       * this.getBeeHive().getService('PubSub')\n       */\n      getPubSub: function getPubSub() {\n        if (!this.hasBeeHive()) throw new Error('The BeeHive is inactive (or dead >:})');\n        if (!this.__ctx) this.__ctx = {};\n        if (this.__ctx.pubsub) return this.__ctx.pubsub;\n\n        var pubsub = this.__beehive.getService('PubSub');\n\n        if (pubsub && pubsub.__facade__) return pubsub; // build a unique key for this instance\n\n        this.__ctx.pubsub = {\n          _key: pubsub.getPubSubKey(),\n          _exec: function _exec(name, args) {\n            args = _.toArray(args);\n            if (args[0] instanceof PubSubKey) throw Error('You have given us a PubSub key, this.publish() method does not need it.');\n            args.unshift(this._key);\n            pubsub[name].apply(pubsub, args);\n          },\n          publish: function publish() {\n            this._exec('publish', arguments);\n          },\n          subscribe: function subscribe() {\n            this._exec('subscribe', arguments);\n          },\n          subscribeOnce: function subscribeOnce() {\n            this._exec('subscribeOnce', arguments);\n          },\n          unsubscribe: function unsubscribe() {\n            this._exec('unsubscribe', arguments);\n          },\n          getCurrentPubSubKey: function getCurrentPubSubKey() {\n            return this._key;\n          }\n        };\n\n        _.extend(this.__ctx.pubsub, PubSubEvents);\n\n        return this.__ctx.pubsub;\n      },\n      hasPubSub: function hasPubSub() {\n        if (this.hasBeeHive()) return _.isObject(this.__beehive.getService('PubSub'));\n        return false;\n      }\n    },\n    App: {\n      setApp: function setApp(app) {\n        if (_.isUndefined(app)) throw new Error('App object cannot be empty');\n        this.__app = app;\n      },\n      getApp: function getApp() {\n        return this.__app;\n      },\n      hasApp: function hasApp() {\n        return !_.isEmpty(this.__app);\n      }\n    }\n  };\n  return Mixin;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/mixins/dependon.js?");

/***/ }),

/***/ "./src/js/mixins/hardened.js":
/*!***********************************!*\
  !*** ./src/js/mixins/hardened.js ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Created by rchyla on 3/18/14.\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore-umd.js\"), __webpack_require__(/*! js/components/facade */ \"./src/js/components/facade.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, Facade) {\n  var Mixin = {\n    /*\n     * Creates a hardened instance of itself, it uses\n     * interface description from 'hardenedInterface'\n     * Implementations need to populate 'hardenedInterface'\n     * with list of properties and methods that should be exposed\n     * through the Facade\n     */\n    _getHardenedInstance: function _getHardenedInstance(iface, objectIn) {\n      if (!('hardenedInterface' in this) && !iface) {\n        throw Error('Error: this.hardenedInterface is not defined');\n      }\n\n      return new Facade(iface || ('hardenedInterface' in this ? this.hardenedInterface : {}), objectIn);\n    },\n    getHardenedInstance: function getHardenedInstance(iface) {\n      return this._getHardenedInstance(iface, this);\n    }\n  };\n  return Mixin;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://bumblebee/./src/js/mixins/hardened.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	!function() {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = function(result, chunkIds, fn, priority) {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var chunkIds = deferred[i][0];
/******/ 				var fn = deferred[i][1];
/******/ 				var priority = deferred[i][2];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	!function() {
/******/ 		__webpack_require__.nmd = function(module) {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	!function() {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"app": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = function(chunkId) { return installedChunks[chunkId] === 0; };
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = function(parentChunkLoadingFunction, data) {
/******/ 			var chunkIds = data[0];
/******/ 			var moreModules = data[1];
/******/ 			var runtime = data[2];
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some(function(id) { return installedChunks[id] !== 0; })) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkbumblebee"] = self["webpackChunkbumblebee"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["vendor"], function() { return __webpack_require__("./src/js/apps/discovery/main.js"); })
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;